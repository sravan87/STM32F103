
main.elf:     file format elf32-littlearm


Disassembly of section .text:

08000000 <g_pfnVectors>:
 8000000:	00 50 00 20 e5 01 00 08 00 00 00 00 00 00 00 00     .P. ............
 8000010:	e1 01 00 08 e1 01 00 08 e1 01 00 08 00 00 00 00     ................
	...
 800002c:	1d 1c 00 08 e1 01 00 08 00 00 00 00 fd 1c 00 08     ................
 800003c:	41 1d 00 08 e1 01 00 08 e1 01 00 08 e1 01 00 08     A...............
 800004c:	e1 01 00 08 e1 01 00 08 e1 01 00 08 e1 01 00 08     ................
 800005c:	e1 01 00 08 e1 01 00 08 e1 01 00 08 e1 01 00 08     ................
 800006c:	e1 01 00 08 e1 01 00 08 e1 01 00 08 e1 01 00 08     ................
 800007c:	e1 01 00 08 e1 01 00 08 e1 01 00 08 e1 01 00 08     ................
 800008c:	e1 01 00 08 e1 01 00 08 e1 01 00 08 e1 01 00 08     ................
 800009c:	e1 01 00 08 e1 01 00 08 e1 01 00 08 e1 01 00 08     ................
 80000ac:	e1 01 00 08 e1 01 00 08 e1 01 00 08 e1 01 00 08     ................
 80000bc:	e1 01 00 08 e1 01 00 08 e1 01 00 08 e1 01 00 08     ................
 80000cc:	e1 01 00 08 e1 01 00 08 e1 01 00 08 e1 01 00 08     ................
 80000dc:	e1 01 00 08 e1 01 00 08 e1 01 00 08 e1 01 00 08     ................
 80000ec:	e1 01 00 08 e1 01 00 08 e1 01 00 08 e1 01 00 08     ................
 80000fc:	e1 01 00 08 e1 01 00 08 e1 01 00 08 e1 01 00 08     ................
 800010c:	e1 01 00 08 e1 01 00 08 e1 01 00 08 e1 01 00 08     ................
 800011c:	e1 01 00 08 e1 01 00 08 e1 01 00 08 e1 01 00 08     ................
 800012c:	e1 01 00 08 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
 80001dc:	5f f8 e0 f1                                         _...

080001e0 <Default_Handler>:
#pragma weak DMA2_Channel2_IRQHandler= Default_Handler
#pragma weak DMA2_Channel3_IRQHandler= Default_Handler
#pragma weak DMA2_Channel4_5_IRQHandler= Default_Handler
void Default_Handler(void)
{
while (1) {}
 80001e0:	e7fe      	b.n	80001e0 <Default_Handler>
 80001e2:	bf00      	nop

080001e4 <Reset_Handler>:

	while(dst < &_ebss)
		*(dst++) = 0;
}

void Reset_Handler(void) {
 80001e4:	4668      	mov	r0, sp
 80001e6:	f020 0107 	bic.w	r1, r0, #7
 80001ea:	468d      	mov	sp, r1
	unsigned long *src, *dst;
	/* copy the data segment into ram */
	src = &_sidata;
	dst = &_sdata;

	if (src != dst)
 80001ec:	4814      	ldr	r0, [pc, #80]	; (8000240 <Reset_Handler+0x5c>)
 80001ee:	4915      	ldr	r1, [pc, #84]	; (8000244 <Reset_Handler+0x60>)

	while(dst < &_ebss)
		*(dst++) = 0;
}

void Reset_Handler(void) {
 80001f0:	b508      	push	{r3, lr}
	unsigned long *src, *dst;
	/* copy the data segment into ram */
	src = &_sidata;
	dst = &_sdata;

	if (src != dst)
 80001f2:	4281      	cmp	r1, r0
 80001f4:	d009      	beq.n	800020a <Reset_Handler+0x26>
	while(dst < &_edata)
 80001f6:	4b14      	ldr	r3, [pc, #80]	; (8000248 <Reset_Handler+0x64>)
 80001f8:	4298      	cmp	r0, r3
 80001fa:	d206      	bcs.n	800020a <Reset_Handler+0x26>
		*(dst++) = *(src++);
 80001fc:	43c2      	mvns	r2, r0
 80001fe:	4413      	add	r3, r2
 8000200:	f023 0203 	bic.w	r2, r3, #3
 8000204:	3204      	adds	r2, #4
 8000206:	f004 fac3 	bl	8004790 <memcpy>
		/* zero the bss segment */
		dst = &_sbss;

	while(dst < &_ebss)
 800020a:	4810      	ldr	r0, [pc, #64]	; (800024c <Reset_Handler+0x68>)
 800020c:	4b10      	ldr	r3, [pc, #64]	; (8000250 <Reset_Handler+0x6c>)
 800020e:	4298      	cmp	r0, r3
 8000210:	d207      	bcs.n	8000222 <Reset_Handler+0x3e>
		*(dst++) = 0;
 8000212:	43c2      	mvns	r2, r0
 8000214:	4413      	add	r3, r2
 8000216:	f023 0203 	bic.w	r2, r3, #3
 800021a:	3204      	adds	r2, #4
 800021c:	2100      	movs	r1, #0
 800021e:	f004 fb2d 	bl	800487c <memset>
void Reset_Handler(void) {

	__Init_Data(); /* Initialize memory, data and bss */

	extern u32 _isr_vectors_offs; /* the offset to the vector table in ram */
	SCB->VTOR = 0x08000000 | ((u32)&_isr_vectors_offs & (u32)0x1FFFFF80); /* set interrupt vector table address */
 8000222:	4b0c      	ldr	r3, [pc, #48]	; (8000254 <Reset_Handler+0x70>)
 8000224:	4a0c      	ldr	r2, [pc, #48]	; (8000258 <Reset_Handler+0x74>)
 8000226:	f023 4368 	bic.w	r3, r3, #3892314112	; 0xe8000000
 800022a:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800022e:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8000232:	6093      	str	r3, [r2, #8]

	SystemInit(); /* configure the clock */
 8000234:	f000 f91a 	bl	800046c <SystemInit>

	main(); /* start execution of the program */
 8000238:	f000 f8d4 	bl	80003e4 <main>

	while(1) {}
 800023c:	e7fe      	b.n	800023c <Reset_Handler+0x58>
 800023e:	bf00      	nop
 8000240:	20000000 	.word	0x20000000
 8000244:	08004928 	.word	0x08004928
 8000248:	20000030 	.word	0x20000030
 800024c:	20000030 	.word	0x20000030
 8000250:	20001d80 	.word	0x20001d80
 8000254:	00000000 	.word	0x00000000
 8000258:	e000ed00 	.word	0xe000ed00

0800025c <__Init_Data>:
	unsigned long *src, *dst;
	/* copy the data segment into ram */
	src = &_sidata;
	dst = &_sdata;

	if (src != dst)
 800025c:	490e      	ldr	r1, [pc, #56]	; (8000298 <__Init_Data+0x3c>)
 800025e:	480f      	ldr	r0, [pc, #60]	; (800029c <__Init_Data+0x40>)
0, 0, 0,
(intfunc)0xF1E0F85F
/* @0x1E0. This is for boot in RAM mode for STM32F10x High Density devices. */
};

void __Init_Data(void) {
 8000260:	b508      	push	{r3, lr}
	unsigned long *src, *dst;
	/* copy the data segment into ram */
	src = &_sidata;
	dst = &_sdata;

	if (src != dst)
 8000262:	4281      	cmp	r1, r0
 8000264:	d009      	beq.n	800027a <__Init_Data+0x1e>
	while(dst < &_edata)
 8000266:	4b0e      	ldr	r3, [pc, #56]	; (80002a0 <__Init_Data+0x44>)
 8000268:	4298      	cmp	r0, r3
 800026a:	d206      	bcs.n	800027a <__Init_Data+0x1e>
		*(dst++) = *(src++);
 800026c:	43c2      	mvns	r2, r0
 800026e:	441a      	add	r2, r3
 8000270:	f022 0203 	bic.w	r2, r2, #3
 8000274:	3204      	adds	r2, #4
 8000276:	f004 fa8b 	bl	8004790 <memcpy>
		/* zero the bss segment */
		dst = &_sbss;

	while(dst < &_ebss)
 800027a:	480a      	ldr	r0, [pc, #40]	; (80002a4 <__Init_Data+0x48>)
 800027c:	4b0a      	ldr	r3, [pc, #40]	; (80002a8 <__Init_Data+0x4c>)
 800027e:	4298      	cmp	r0, r3
 8000280:	d209      	bcs.n	8000296 <__Init_Data+0x3a>
		*(dst++) = 0;
 8000282:	43c2      	mvns	r2, r0
 8000284:	441a      	add	r2, r3
 8000286:	f022 0203 	bic.w	r2, r2, #3
 800028a:	3204      	adds	r2, #4
 800028c:	2100      	movs	r1, #0
}
 800028e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8000292:	f004 baf3 	b.w	800487c <memset>
 8000296:	bd08      	pop	{r3, pc}
 8000298:	08004928 	.word	0x08004928
 800029c:	20000000 	.word	0x20000000
 80002a0:	20000030 	.word	0x20000030
 80002a4:	20000030 	.word	0x20000030
 80002a8:	20001d80 	.word	0x20001d80

080002ac <BlinkLedOff>:
	taskDISABLE_INTERRUPTS();
	for( ;; );
}

void BlinkLedOff ( void )
{
 80002ac:	b570      	push	{r4, r5, r6, lr}

	volatile unsigned int * pioc_addr = ( unsigned int *)0x40011010;
	unsigned long ulReceivedValue;
	const unsigned long ulValueToSend = 100UL;
 80002ae:	2364      	movs	r3, #100	; 0x64
	taskDISABLE_INTERRUPTS();
	for( ;; );
}

void BlinkLedOff ( void )
{
 80002b0:	b082      	sub	sp, #8
 80002b2:	4e10      	ldr	r6, [pc, #64]	; (80002f4 <BlinkLedOff+0x48>)

	while(1)
	{

		xQueueReceive( xQueueOff, &ulReceivedValue, portMAX_DELAY );
		*pioc_addr = * pioc_addr |  0x20000000;
 80002b4:	4d10      	ldr	r5, [pc, #64]	; (80002f8 <BlinkLedOff+0x4c>)
void BlinkLedOff ( void )
{

	volatile unsigned int * pioc_addr = ( unsigned int *)0x40011010;
	unsigned long ulReceivedValue;
	const unsigned long ulValueToSend = 100UL;
 80002b6:	9301      	str	r3, [sp, #4]

	while(1)
	{

		xQueueReceive( xQueueOff, &ulReceivedValue, portMAX_DELAY );
 80002b8:	2300      	movs	r3, #0
 80002ba:	6830      	ldr	r0, [r6, #0]
 80002bc:	4669      	mov	r1, sp
 80002be:	f04f 32ff 	mov.w	r2, #4294967295
 80002c2:	f002 f8e5 	bl	8002490 <xQueueGenericReceive>
		*pioc_addr = * pioc_addr |  0x20000000;
 80002c6:	682b      	ldr	r3, [r5, #0]

void DelayByDiv(void)
// delay implemented by floating division
// not much compiler optimizer settings dependent
{
	float x=50.0f;
 80002c8:	4c0c      	ldr	r4, [pc, #48]	; (80002fc <BlinkLedOff+0x50>)

	while(1)
	{

		xQueueReceive( xQueueOff, &ulReceivedValue, portMAX_DELAY );
		*pioc_addr = * pioc_addr |  0x20000000;
 80002ca:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 80002ce:	602b      	str	r3, [r5, #0]
// delay implemented by floating division
// not much compiler optimizer settings dependent
{
	float x=50.0f;
	while (x > 0.0001f)
	x = x/1.0001f; // delay loop
 80002d0:	4620      	mov	r0, r4
 80002d2:	490b      	ldr	r1, [pc, #44]	; (8000300 <BlinkLedOff+0x54>)
 80002d4:	f004 f94a 	bl	800456c <__aeabi_fdiv>
void DelayByDiv(void)
// delay implemented by floating division
// not much compiler optimizer settings dependent
{
	float x=50.0f;
	while (x > 0.0001f)
 80002d8:	490a      	ldr	r1, [pc, #40]	; (8000304 <BlinkLedOff+0x58>)
	x = x/1.0001f; // delay loop
 80002da:	4604      	mov	r4, r0
void DelayByDiv(void)
// delay implemented by floating division
// not much compiler optimizer settings dependent
{
	float x=50.0f;
	while (x > 0.0001f)
 80002dc:	f004 fa4e 	bl	800477c <__aeabi_fcmpgt>
 80002e0:	4602      	mov	r2, r0
 80002e2:	2800      	cmp	r0, #0
 80002e4:	d1f4      	bne.n	80002d0 <BlinkLedOff+0x24>
	{

		xQueueReceive( xQueueOff, &ulReceivedValue, portMAX_DELAY );
		*pioc_addr = * pioc_addr |  0x20000000;
		DelayByDiv(); // delay --> not much compiler optimizer settings dependent
		xQueueSend( xQueueOn, &ulValueToSend, 0 );
 80002e6:	6870      	ldr	r0, [r6, #4]
 80002e8:	a901      	add	r1, sp, #4
 80002ea:	4613      	mov	r3, r2
 80002ec:	f001 fe6a 	bl	8001fc4 <xQueueGenericSend>

	}
 80002f0:	e7e2      	b.n	80002b8 <BlinkLedOff+0xc>
 80002f2:	bf00      	nop
 80002f4:	20000030 	.word	0x20000030
 80002f8:	40011010 	.word	0x40011010
 80002fc:	42480000 	.word	0x42480000
 8000300:	3f800347 	.word	0x3f800347
 8000304:	38d1b717 	.word	0x38d1b717

08000308 <BlinkLedOn>:

}

void BlinkLedOn ( void )
{
 8000308:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800030c:	b082      	sub	sp, #8

	volatile unsigned int * pioc_addr = ( unsigned int *)0x40011010;
	const unsigned long ulValueToSend = 100UL;
 800030e:	f10d 0808 	add.w	r8, sp, #8
 8000312:	2364      	movs	r3, #100	; 0x64
 8000314:	4f10      	ldr	r7, [pc, #64]	; (8000358 <BlinkLedOn+0x50>)
	unsigned long ulReceivedValue;

	while(1)
	{
		*pioc_addr = * pioc_addr | 0x2000; 
 8000316:	4e11      	ldr	r6, [pc, #68]	; (800035c <BlinkLedOn+0x54>)

void BlinkLedOn ( void )
{

	volatile unsigned int * pioc_addr = ( unsigned int *)0x40011010;
	const unsigned long ulValueToSend = 100UL;
 8000318:	f848 3d08 	str.w	r3, [r8, #-8]!
	unsigned long ulReceivedValue;

	while(1)
	{
		*pioc_addr = * pioc_addr | 0x2000; 
 800031c:	6833      	ldr	r3, [r6, #0]

void DelayByDiv(void)
// delay implemented by floating division
// not much compiler optimizer settings dependent
{
	float x=50.0f;
 800031e:	4d10      	ldr	r5, [pc, #64]	; (8000360 <BlinkLedOn+0x58>)
	const unsigned long ulValueToSend = 100UL;
	unsigned long ulReceivedValue;

	while(1)
	{
		*pioc_addr = * pioc_addr | 0x2000; 
 8000320:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8000324:	6033      	str	r3, [r6, #0]
// delay implemented by floating division
// not much compiler optimizer settings dependent
{
	float x=50.0f;
	while (x > 0.0001f)
	x = x/1.0001f; // delay loop
 8000326:	4628      	mov	r0, r5
 8000328:	490e      	ldr	r1, [pc, #56]	; (8000364 <BlinkLedOn+0x5c>)
 800032a:	f004 f91f 	bl	800456c <__aeabi_fdiv>
void DelayByDiv(void)
// delay implemented by floating division
// not much compiler optimizer settings dependent
{
	float x=50.0f;
	while (x > 0.0001f)
 800032e:	490e      	ldr	r1, [pc, #56]	; (8000368 <BlinkLedOn+0x60>)
	x = x/1.0001f; // delay loop
 8000330:	4605      	mov	r5, r0
void DelayByDiv(void)
// delay implemented by floating division
// not much compiler optimizer settings dependent
{
	float x=50.0f;
	while (x > 0.0001f)
 8000332:	f004 fa23 	bl	800477c <__aeabi_fcmpgt>
 8000336:	4604      	mov	r4, r0
 8000338:	2800      	cmp	r0, #0
 800033a:	d1f4      	bne.n	8000326 <BlinkLedOn+0x1e>

	while(1)
	{
		*pioc_addr = * pioc_addr | 0x2000; 
		DelayByDiv(); // delay --> not much compiler optimizer settings dependent
		xQueueSend( xQueueOff, &ulValueToSend, 0 );
 800033c:	4641      	mov	r1, r8
 800033e:	4622      	mov	r2, r4
 8000340:	4623      	mov	r3, r4
 8000342:	6838      	ldr	r0, [r7, #0]
 8000344:	f001 fe3e 	bl	8001fc4 <xQueueGenericSend>
		xQueueReceive( xQueueOn, &ulReceivedValue, portMAX_DELAY );
 8000348:	4623      	mov	r3, r4
 800034a:	6878      	ldr	r0, [r7, #4]
 800034c:	a901      	add	r1, sp, #4
 800034e:	f04f 32ff 	mov.w	r2, #4294967295
 8000352:	f002 f89d 	bl	8002490 <xQueueGenericReceive>



	}
 8000356:	e7e1      	b.n	800031c <BlinkLedOn+0x14>
 8000358:	20000030 	.word	0x20000030
 800035c:	40011010 	.word	0x40011010
 8000360:	42480000 	.word	0x42480000
 8000364:	3f800347 	.word	0x3f800347
 8000368:	38d1b717 	.word	0x38d1b717

0800036c <vApplicationMallocFailedHook>:
/* The queue used by both tasks. */
static QueueHandle_t xQueueOn = NULL;
static QueueHandle_t xQueueOff = NULL;

void vApplicationMallocFailedHook( void )
{
 800036c:	b508      	push	{r3, lr}
	demo application.  If heap_1.c, heap_2.c or heap_4.c are used, then the size
	of the heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE
	in FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
	to query the size of free heap space that remains (although it does not
	provide information on how the remaining heap might be fragmented). */
	taskDISABLE_INTERRUPTS();
 800036e:	f001 fc73 	bl	8001c58 <ulPortSetInterruptMask>
	for( ;; );
 8000372:	e7fe      	b.n	8000372 <vApplicationMallocFailedHook+0x6>

08000374 <vApplicationIdleHook>:
}
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
 8000374:	4770      	bx	lr
 8000376:	bf00      	nop

08000378 <vApplicationStackOverflowHook>:
	memory allocated by the kernel to any task that has since been deleted. */
}
/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName )
{
 8000378:	b508      	push	{r3, lr}
	( void ) pxTask;

	/* Run time stack overflow checking is performed if
	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook	function is
	called if a stack overflow is detected. */
	taskDISABLE_INTERRUPTS();
 800037a:	f001 fc6d 	bl	8001c58 <ulPortSetInterruptMask>
	for( ;; );
 800037e:	e7fe      	b.n	800037e <vApplicationStackOverflowHook+0x6>

08000380 <FLASH_ReadOutProtection_Enable>:
// NOTES: The user area of the Flash memory can be protected against read by untrusted code.
//Protection is enabled only for firmware compiled with flag RELEASE_PUBLIC set (see makefile).
//When readout protection is set debugging via JTAG is not possible any more.
//If the read protection is set while the debugger is still connected through JTAG/SWD, apply a
//POR (power-on reset) instead of a system reset (without debugger connection).
{
 8000380:	b508      	push	{r3, lr}
	if (FLASH_GetReadOutProtectionStatus() != SET)
 8000382:	f000 febb 	bl	80010fc <FLASH_GetReadOutProtectionStatus>
 8000386:	2801      	cmp	r0, #1
 8000388:	d006      	beq.n	8000398 <FLASH_ReadOutProtection_Enable+0x18>
	{
#ifdef RELEASE_PUBLIC // HINT: define is done via makefile
	FLASH_Unlock();
 800038a:	f000 f93f 	bl	800060c <FLASH_Unlock>
	if (FLASH_ReadOutProtection(ENABLE) != FLASH_COMPLETE) // set readout protection
 800038e:	2001      	movs	r0, #1
 8000390:	f000 fd8e 	bl	8000eb0 <FLASH_ReadOutProtection>
 8000394:	2804      	cmp	r0, #4
 8000396:	d000      	beq.n	800039a <FLASH_ReadOutProtection_Enable+0x1a>
 8000398:	bd08      	pop	{r3, pc}
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
 800039a:	f3bf 8f4f 	dsb	sy
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                     /* Ensure all outstanding memory accesses included
                                                                  buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800039e:	4905      	ldr	r1, [pc, #20]	; (80003b4 <FLASH_ReadOutProtection_Enable+0x34>)
 80003a0:	4b05      	ldr	r3, [pc, #20]	; (80003b8 <FLASH_ReadOutProtection_Enable+0x38>)
 80003a2:	68ca      	ldr	r2, [r1, #12]
 80003a4:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 80003a8:	4313      	orrs	r3, r2
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                     /* Ensure all outstanding memory accesses included
                                                                  buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
 80003aa:	60cb      	str	r3, [r1, #12]
 80003ac:	f3bf 8f4f 	dsb	sy
 80003b0:	e7fe      	b.n	80003b0 <FLASH_ReadOutProtection_Enable+0x30>
 80003b2:	bf00      	nop
 80003b4:	e000ed00 	.word	0xe000ed00
 80003b8:	05fa0004 	.word	0x05fa0004

080003bc <DelayByDiv>:
}

void DelayByDiv(void)
// delay implemented by floating division
// not much compiler optimizer settings dependent
{
 80003bc:	b510      	push	{r4, lr}
	float x=50.0f;
 80003be:	4c06      	ldr	r4, [pc, #24]	; (80003d8 <DelayByDiv+0x1c>)
	while (x > 0.0001f)
	x = x/1.0001f; // delay loop
 80003c0:	4620      	mov	r0, r4
 80003c2:	4906      	ldr	r1, [pc, #24]	; (80003dc <DelayByDiv+0x20>)
 80003c4:	f004 f8d2 	bl	800456c <__aeabi_fdiv>
void DelayByDiv(void)
// delay implemented by floating division
// not much compiler optimizer settings dependent
{
	float x=50.0f;
	while (x > 0.0001f)
 80003c8:	4905      	ldr	r1, [pc, #20]	; (80003e0 <DelayByDiv+0x24>)
	x = x/1.0001f; // delay loop
 80003ca:	4604      	mov	r4, r0
void DelayByDiv(void)
// delay implemented by floating division
// not much compiler optimizer settings dependent
{
	float x=50.0f;
	while (x > 0.0001f)
 80003cc:	f004 f9d6 	bl	800477c <__aeabi_fcmpgt>
 80003d0:	2800      	cmp	r0, #0
 80003d2:	d1f5      	bne.n	80003c0 <DelayByDiv+0x4>
	x = x/1.0001f; // delay loop
}
 80003d4:	bd10      	pop	{r4, pc}
 80003d6:	bf00      	nop
 80003d8:	42480000 	.word	0x42480000
 80003dc:	3f800347 	.word	0x3f800347
 80003e0:	38d1b717 	.word	0x38d1b717

080003e4 <main>:
}



int main(int argc, char *argv[])
{
 80003e4:	b570      	push	{r4, r5, r6, lr}
	GPIO_InitTypeDef GPIO_InitStructure;
	// GPIOC Periph clock enable
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
 80003e6:	2010      	movs	r0, #16
}



int main(int argc, char *argv[])
{
 80003e8:	b086      	sub	sp, #24
	GPIO_InitTypeDef GPIO_InitStructure;
	// GPIOC Periph clock enable
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
 80003ea:	2101      	movs	r1, #1
 80003ec:	f001 fb82 	bl	8001af4 <RCC_APB2PeriphClockCmd>
	// Configure PC12 to mode: slow rise-time, pushpull output
	//GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12; // GPIO No. 12
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13; // GPIO No. 13
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; // slow rise time
 80003f0:	2502      	movs	r5, #2
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; // push-pull output
 80003f2:	2310      	movs	r3, #16
	GPIO_InitTypeDef GPIO_InitStructure;
	// GPIOC Periph clock enable
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
	// Configure PC12 to mode: slow rise-time, pushpull output
	//GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12; // GPIO No. 12
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13; // GPIO No. 13
 80003f4:	f44f 5200 	mov.w	r2, #8192	; 0x2000
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; // slow rise time
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; // push-pull output
	GPIO_Init(GPIOC, &GPIO_InitStructure); // GPIOC init
 80003f8:	4817      	ldr	r0, [pc, #92]	; (8000458 <main+0x74>)
 80003fa:	a905      	add	r1, sp, #20
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
	// Configure PC12 to mode: slow rise-time, pushpull output
	//GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12; // GPIO No. 12
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13; // GPIO No. 13
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; // slow rise time
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; // push-pull output
 80003fc:	f88d 3017 	strb.w	r3, [sp, #23]
	GPIO_InitTypeDef GPIO_InitStructure;
	// GPIOC Periph clock enable
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
	// Configure PC12 to mode: slow rise-time, pushpull output
	//GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12; // GPIO No. 12
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13; // GPIO No. 13
 8000400:	f8ad 2014 	strh.w	r2, [sp, #20]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; // slow rise time
 8000404:	f88d 5016 	strb.w	r5, [sp, #22]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; // push-pull output
	GPIO_Init(GPIOC, &GPIO_InitStructure); // GPIOC init
 8000408:	f000 ffb4 	bl	8001374 <GPIO_Init>

	//FLASH_ReadOutProtection_Enable(); // enable ReadOutProtection when running Release code


	/* Create the queue. */
	xQueueOn = xQueueCreate( 2, sizeof( unsigned long ) );
 800040c:	2104      	movs	r1, #4
 800040e:	2200      	movs	r2, #0
 8000410:	4628      	mov	r0, r5
 8000412:	f001 fd99 	bl	8001f48 <xQueueGenericCreate>
 8000416:	4e11      	ldr	r6, [pc, #68]	; (800045c <main+0x78>)
	xQueueOff = xQueueCreate( 2, sizeof( unsigned long ) );
 8000418:	2104      	movs	r1, #4

	//FLASH_ReadOutProtection_Enable(); // enable ReadOutProtection when running Release code


	/* Create the queue. */
	xQueueOn = xQueueCreate( 2, sizeof( unsigned long ) );
 800041a:	6070      	str	r0, [r6, #4]
	xQueueOff = xQueueCreate( 2, sizeof( unsigned long ) );
 800041c:	2200      	movs	r2, #0
 800041e:	4628      	mov	r0, r5
 8000420:	f001 fd92 	bl	8001f48 <xQueueGenericCreate>


	/* Start the two tasks as described in the comments at the top of this
	file. */
	xTaskCreate( (TaskFunction_t)BlinkLedOff, "BlkLed", configMINIMAL_STACK_SIZE, NULL, (tskIDLE_PRIORITY + 2), NULL );
 8000424:	2400      	movs	r4, #0
	//FLASH_ReadOutProtection_Enable(); // enable ReadOutProtection when running Release code


	/* Create the queue. */
	xQueueOn = xQueueCreate( 2, sizeof( unsigned long ) );
	xQueueOff = xQueueCreate( 2, sizeof( unsigned long ) );
 8000426:	6030      	str	r0, [r6, #0]


	/* Start the two tasks as described in the comments at the top of this
	file. */
	xTaskCreate( (TaskFunction_t)BlinkLedOff, "BlkLed", configMINIMAL_STACK_SIZE, NULL, (tskIDLE_PRIORITY + 2), NULL );
 8000428:	4623      	mov	r3, r4
 800042a:	490d      	ldr	r1, [pc, #52]	; (8000460 <main+0x7c>)
 800042c:	2246      	movs	r2, #70	; 0x46
 800042e:	9500      	str	r5, [sp, #0]
 8000430:	9401      	str	r4, [sp, #4]
 8000432:	9402      	str	r4, [sp, #8]
 8000434:	9403      	str	r4, [sp, #12]
 8000436:	480b      	ldr	r0, [pc, #44]	; (8000464 <main+0x80>)
 8000438:	f002 fa84 	bl	8002944 <xTaskGenericCreate>
	xTaskCreate( (TaskFunction_t)BlinkLedOn, "BlkLed", configMINIMAL_STACK_SIZE, NULL, (tskIDLE_PRIORITY + 2), NULL );
 800043c:	4623      	mov	r3, r4
 800043e:	4908      	ldr	r1, [pc, #32]	; (8000460 <main+0x7c>)
 8000440:	2246      	movs	r2, #70	; 0x46
 8000442:	9500      	str	r5, [sp, #0]
 8000444:	9401      	str	r4, [sp, #4]
 8000446:	9402      	str	r4, [sp, #8]
 8000448:	9403      	str	r4, [sp, #12]
 800044a:	4807      	ldr	r0, [pc, #28]	; (8000468 <main+0x84>)
 800044c:	f002 fa7a 	bl	8002944 <xTaskGenericCreate>
								( void * ) 0,				/* The ID is not used, so can be set to anything. */
								vLEDTimerCallback			/* The callback function that switches the LED off. */
							);
#endif
	/* Start the tasks and timer running. */
	vTaskStartScheduler();
 8000450:	f002 fcd0 	bl	8002df4 <vTaskStartScheduler>


	for (;;);
 8000454:	e7fe      	b.n	8000454 <main+0x70>
 8000456:	bf00      	nop
 8000458:	40011000 	.word	0x40011000
 800045c:	20000030 	.word	0x20000030
 8000460:	08004918 	.word	0x08004918
 8000464:	080002ad 	.word	0x080002ad
 8000468:	08000309 	.word	0x08000309

0800046c <SystemInit>:
  */
void SystemInit (void)
{
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800046c:	4b3c      	ldr	r3, [pc, #240]	; (8000560 <SystemInit+0xf4>)
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 800046e:	b430      	push	{r4, r5}
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000470:	6818      	ldr	r0, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 8000472:	493c      	ldr	r1, [pc, #240]	; (8000564 <SystemInit+0xf8>)
  */
void SystemInit (void)
{
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000474:	f040 0001 	orr.w	r0, r0, #1
 8000478:	6018      	str	r0, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 800047a:	685d      	ldr	r5, [r3, #4]
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 800047c:	b082      	sub	sp, #8
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 800047e:	4029      	ands	r1, r5
 8000480:	6059      	str	r1, [r3, #4]
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000482:	6819      	ldr	r1, [r3, #0]
  * @param  None
  * @retval None
  */
static void SetSysClockTo72(void)
{
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 8000484:	2000      	movs	r0, #0
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000486:	f021 7184 	bic.w	r1, r1, #17301504	; 0x1080000
 800048a:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 800048e:	6019      	str	r1, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000490:	6819      	ldr	r1, [r3, #0]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 8000492:	f44f 041f 	mov.w	r4, #10420224	; 0x9f0000
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000496:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 800049a:	6019      	str	r1, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 800049c:	6859      	ldr	r1, [r3, #4]
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 800049e:	461a      	mov	r2, r3

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 80004a0:	f421 01fe 	bic.w	r1, r1, #8323072	; 0x7f0000
 80004a4:	6059      	str	r1, [r3, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 80004a6:	609c      	str	r4, [r3, #8]
  * @param  None
  * @retval None
  */
static void SetSysClockTo72(void)
{
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 80004a8:	9000      	str	r0, [sp, #0]
 80004aa:	9001      	str	r0, [sp, #4]
  
  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
  /* Enable HSE */    
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 80004ac:	6819      	ldr	r1, [r3, #0]
 80004ae:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
 80004b2:	6019      	str	r1, [r3, #0]
 80004b4:	e003      	b.n	80004be <SystemInit+0x52>
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
    StartUpCounter++;  
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 80004b6:	9b00      	ldr	r3, [sp, #0]
 80004b8:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80004bc:	d009      	beq.n	80004d2 <SystemInit+0x66>
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 80004be:	6813      	ldr	r3, [r2, #0]
 80004c0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80004c4:	9301      	str	r3, [sp, #4]
    StartUpCounter++;  
 80004c6:	9b00      	ldr	r3, [sp, #0]
 80004c8:	3301      	adds	r3, #1
 80004ca:	9300      	str	r3, [sp, #0]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 80004cc:	9b01      	ldr	r3, [sp, #4]
 80004ce:	2b00      	cmp	r3, #0
 80004d0:	d0f1      	beq.n	80004b6 <SystemInit+0x4a>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 80004d2:	4b23      	ldr	r3, [pc, #140]	; (8000560 <SystemInit+0xf4>)
 80004d4:	681b      	ldr	r3, [r3, #0]
 80004d6:	f413 3300 	ands.w	r3, r3, #131072	; 0x20000
  {
    HSEStatus = (uint32_t)0x01;
 80004da:	bf18      	it	ne
 80004dc:	2301      	movne	r3, #1
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 80004de:	9301      	str	r3, [sp, #4]
  }  

  if (HSEStatus == (uint32_t)0x01)
 80004e0:	9b01      	ldr	r3, [sp, #4]
 80004e2:	2b01      	cmp	r3, #1
 80004e4:	d006      	beq.n	80004f4 <SystemInit+0x88>
  SetSysClock();

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 80004e6:	4b20      	ldr	r3, [pc, #128]	; (8000568 <SystemInit+0xfc>)
 80004e8:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80004ec:	609a      	str	r2, [r3, #8]
#endif 
}
 80004ee:	b002      	add	sp, #8
 80004f0:	bc30      	pop	{r4, r5}
 80004f2:	4770      	bx	lr
  }  

  if (HSEStatus == (uint32_t)0x01)
  {
    /* Enable Prefetch Buffer */
    FLASH->ACR |= FLASH_ACR_PRFTBE;
 80004f4:	4a1d      	ldr	r2, [pc, #116]	; (800056c <SystemInit+0x100>)
    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    

 
    /* HCLK = SYSCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
 80004f6:	4b1a      	ldr	r3, [pc, #104]	; (8000560 <SystemInit+0xf4>)
  }  

  if (HSEStatus == (uint32_t)0x01)
  {
    /* Enable Prefetch Buffer */
    FLASH->ACR |= FLASH_ACR_PRFTBE;
 80004f8:	6810      	ldr	r0, [r2, #0]

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 80004fa:	4619      	mov	r1, r3
  }  

  if (HSEStatus == (uint32_t)0x01)
  {
    /* Enable Prefetch Buffer */
    FLASH->ACR |= FLASH_ACR_PRFTBE;
 80004fc:	f040 0010 	orr.w	r0, r0, #16
 8000500:	6010      	str	r0, [r2, #0]

    /* Flash 2 wait state */
    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
 8000502:	6810      	ldr	r0, [r2, #0]
 8000504:	f020 0003 	bic.w	r0, r0, #3
 8000508:	6010      	str	r0, [r2, #0]
    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
 800050a:	6810      	ldr	r0, [r2, #0]
 800050c:	f040 0002 	orr.w	r0, r0, #2
 8000510:	6010      	str	r0, [r2, #0]

 
    /* HCLK = SYSCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
 8000512:	685a      	ldr	r2, [r3, #4]
 8000514:	605a      	str	r2, [r3, #4]
      
    /* PCLK2 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
 8000516:	685a      	ldr	r2, [r3, #4]
 8000518:	605a      	str	r2, [r3, #4]
    
    /* PCLK1 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
 800051a:	685a      	ldr	r2, [r3, #4]
 800051c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000520:	605a      	str	r2, [r3, #4]
    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
                            RCC_CFGR_PLLMULL9); 
#else    
    /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
 8000522:	685a      	ldr	r2, [r3, #4]
 8000524:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
 8000528:	605a      	str	r2, [r3, #4]
                                        RCC_CFGR_PLLMULL));
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
 800052a:	685a      	ldr	r2, [r3, #4]
 800052c:	f442 12e8 	orr.w	r2, r2, #1900544	; 0x1d0000
 8000530:	605a      	str	r2, [r3, #4]
#endif /* STM32F10X_CL */

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;
 8000532:	681a      	ldr	r2, [r3, #0]
 8000534:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8000538:	601a      	str	r2, [r3, #0]

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 800053a:	680b      	ldr	r3, [r1, #0]
 800053c:	4a08      	ldr	r2, [pc, #32]	; (8000560 <SystemInit+0xf4>)
 800053e:	019b      	lsls	r3, r3, #6
 8000540:	d5fb      	bpl.n	800053a <SystemInit+0xce>
    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
 8000542:	4611      	mov	r1, r2
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
    {
    }
    
    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 8000544:	6853      	ldr	r3, [r2, #4]
 8000546:	f023 0303 	bic.w	r3, r3, #3
 800054a:	6053      	str	r3, [r2, #4]
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
 800054c:	6853      	ldr	r3, [r2, #4]
 800054e:	f043 0302 	orr.w	r3, r3, #2
 8000552:	6053      	str	r3, [r2, #4]

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
 8000554:	684b      	ldr	r3, [r1, #4]
 8000556:	f003 030c 	and.w	r3, r3, #12
 800055a:	2b08      	cmp	r3, #8
 800055c:	d1fa      	bne.n	8000554 <SystemInit+0xe8>
 800055e:	e7c2      	b.n	80004e6 <SystemInit+0x7a>
 8000560:	40021000 	.word	0x40021000
 8000564:	f8ff0000 	.word	0xf8ff0000
 8000568:	e000ed00 	.word	0xe000ed00
 800056c:	40022000 	.word	0x40022000

08000570 <SystemCoreClockUpdate>:
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
  uint32_t prediv1factor = 0;
#endif /* STM32F10X_LD_VL or STM32F10X_MD_VL or STM32F10X_HD_VL */
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8000570:	4a11      	ldr	r2, [pc, #68]	; (80005b8 <SystemCoreClockUpdate+0x48>)
 8000572:	6853      	ldr	r3, [r2, #4]
 8000574:	f003 030c 	and.w	r3, r3, #12
  
  switch (tmp)
 8000578:	2b08      	cmp	r3, #8
 800057a:	d10e      	bne.n	800059a <SystemCoreClockUpdate+0x2a>
      SystemCoreClock = HSE_VALUE;
      break;
    case 0x08:  /* PLL used as system clock */

      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
 800057c:	6853      	ldr	r3, [r2, #4]
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 800057e:	6851      	ldr	r1, [r2, #4]
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
 8000580:	f3c3 4383 	ubfx	r3, r3, #18, #4
      
      if (pllsource == 0x00)
 8000584:	03c9      	lsls	r1, r1, #15
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
 8000586:	f103 0302 	add.w	r3, r3, #2
      
      if (pllsource == 0x00)
 800058a:	d510      	bpl.n	80005ae <SystemCoreClockUpdate+0x3e>
       prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
       /* HSE oscillator clock selected as PREDIV1 clock entry */
       SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull; 
 #else
        /* HSE selected as PLL clock entry */
        if ((RCC->CFGR & RCC_CFGR_PLLXTPRE) != (uint32_t)RESET)
 800058c:	6852      	ldr	r2, [r2, #4]
 800058e:	0392      	lsls	r2, r2, #14
 8000590:	d40d      	bmi.n	80005ae <SystemCoreClockUpdate+0x3e>
        {/* HSE oscillator clock divided by 2 */
          SystemCoreClock = (HSE_VALUE >> 1) * pllmull;
        }
        else
        {
          SystemCoreClock = HSE_VALUE * pllmull;
 8000592:	4a0a      	ldr	r2, [pc, #40]	; (80005bc <SystemCoreClockUpdate+0x4c>)
 8000594:	fb02 f303 	mul.w	r3, r2, r3
 8000598:	e000      	b.n	800059c <SystemCoreClockUpdate+0x2c>
#endif /* STM32F10X_LD_VL or STM32F10X_MD_VL or STM32F10X_HD_VL */
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
  
  switch (tmp)
 800059a:	4b08      	ldr	r3, [pc, #32]	; (80005bc <SystemCoreClockUpdate+0x4c>)
      break;
  }
  
  /* Compute HCLK clock frequency ----------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 800059c:	4a06      	ldr	r2, [pc, #24]	; (80005b8 <SystemCoreClockUpdate+0x48>)
 800059e:	4908      	ldr	r1, [pc, #32]	; (80005c0 <SystemCoreClockUpdate+0x50>)
 80005a0:	6852      	ldr	r2, [r2, #4]
 80005a2:	f3c2 1203 	ubfx	r2, r2, #4, #4
 80005a6:	5c8a      	ldrb	r2, [r1, r2]
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;  
 80005a8:	40d3      	lsrs	r3, r2
 80005aa:	610b      	str	r3, [r1, #16]
 80005ac:	4770      	bx	lr
       SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull; 
 #else
        /* HSE selected as PLL clock entry */
        if ((RCC->CFGR & RCC_CFGR_PLLXTPRE) != (uint32_t)RESET)
        {/* HSE oscillator clock divided by 2 */
          SystemCoreClock = (HSE_VALUE >> 1) * pllmull;
 80005ae:	4a05      	ldr	r2, [pc, #20]	; (80005c4 <SystemCoreClockUpdate+0x54>)
 80005b0:	fb02 f303 	mul.w	r3, r2, r3
 80005b4:	e7f2      	b.n	800059c <SystemCoreClockUpdate+0x2c>
 80005b6:	bf00      	nop
 80005b8:	40021000 	.word	0x40021000
 80005bc:	007a1200 	.word	0x007a1200
 80005c0:	20000000 	.word	0x20000000
 80005c4:	003d0900 	.word	0x003d0900

080005c8 <FLASH_SetLatency>:
  
  /* Check the parameters */
  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
  
  /* Read the ACR register */
  tmpreg = FLASH->ACR;  
 80005c8:	4a03      	ldr	r2, [pc, #12]	; (80005d8 <FLASH_SetLatency+0x10>)
 80005ca:	6813      	ldr	r3, [r2, #0]
  
  /* Sets the Latency value */
  tmpreg &= ACR_LATENCY_Mask;
 80005cc:	f003 0338 	and.w	r3, r3, #56	; 0x38
  tmpreg |= FLASH_Latency;
 80005d0:	4318      	orrs	r0, r3
  
  /* Write the ACR register */
  FLASH->ACR = tmpreg;
 80005d2:	6010      	str	r0, [r2, #0]
 80005d4:	4770      	bx	lr
 80005d6:	bf00      	nop
 80005d8:	40022000 	.word	0x40022000

080005dc <FLASH_HalfCycleAccessCmd>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
  
  /* Enable or disable the Half cycle access */
  FLASH->ACR &= ACR_HLFCYA_Mask;
 80005dc:	4b04      	ldr	r3, [pc, #16]	; (80005f0 <FLASH_HalfCycleAccessCmd+0x14>)
 80005de:	681a      	ldr	r2, [r3, #0]
 80005e0:	f022 0208 	bic.w	r2, r2, #8
 80005e4:	601a      	str	r2, [r3, #0]
  FLASH->ACR |= FLASH_HalfCycleAccess;
 80005e6:	681a      	ldr	r2, [r3, #0]
 80005e8:	4310      	orrs	r0, r2
 80005ea:	6018      	str	r0, [r3, #0]
 80005ec:	4770      	bx	lr
 80005ee:	bf00      	nop
 80005f0:	40022000 	.word	0x40022000

080005f4 <FLASH_PrefetchBufferCmd>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
  
  /* Enable or disable the Prefetch Buffer */
  FLASH->ACR &= ACR_PRFTBE_Mask;
 80005f4:	4b04      	ldr	r3, [pc, #16]	; (8000608 <FLASH_PrefetchBufferCmd+0x14>)
 80005f6:	681a      	ldr	r2, [r3, #0]
 80005f8:	f022 0210 	bic.w	r2, r2, #16
 80005fc:	601a      	str	r2, [r3, #0]
  FLASH->ACR |= FLASH_PrefetchBuffer;
 80005fe:	681a      	ldr	r2, [r3, #0]
 8000600:	4310      	orrs	r0, r2
 8000602:	6018      	str	r0, [r3, #0]
 8000604:	4770      	bx	lr
 8000606:	bf00      	nop
 8000608:	40022000 	.word	0x40022000

0800060c <FLASH_Unlock>:
  * @retval None
  */
void FLASH_Unlock(void)
{
  /* Authorize the FPEC of Bank1 Access */
  FLASH->KEYR = FLASH_KEY1;
 800060c:	4b02      	ldr	r3, [pc, #8]	; (8000618 <FLASH_Unlock+0xc>)
 800060e:	4903      	ldr	r1, [pc, #12]	; (800061c <FLASH_Unlock+0x10>)
  FLASH->KEYR = FLASH_KEY2;
 8000610:	4a03      	ldr	r2, [pc, #12]	; (8000620 <FLASH_Unlock+0x14>)
  * @retval None
  */
void FLASH_Unlock(void)
{
  /* Authorize the FPEC of Bank1 Access */
  FLASH->KEYR = FLASH_KEY1;
 8000612:	6059      	str	r1, [r3, #4]
  FLASH->KEYR = FLASH_KEY2;
 8000614:	605a      	str	r2, [r3, #4]
 8000616:	4770      	bx	lr
 8000618:	40022000 	.word	0x40022000
 800061c:	45670123 	.word	0x45670123
 8000620:	cdef89ab 	.word	0xcdef89ab

08000624 <FLASH_UnlockBank1>:
  * @retval None
  */
void FLASH_UnlockBank1(void)
{
  /* Authorize the FPEC of Bank1 Access */
  FLASH->KEYR = FLASH_KEY1;
 8000624:	4b02      	ldr	r3, [pc, #8]	; (8000630 <FLASH_UnlockBank1+0xc>)
 8000626:	4903      	ldr	r1, [pc, #12]	; (8000634 <FLASH_UnlockBank1+0x10>)
  FLASH->KEYR = FLASH_KEY2;
 8000628:	4a03      	ldr	r2, [pc, #12]	; (8000638 <FLASH_UnlockBank1+0x14>)
  * @retval None
  */
void FLASH_UnlockBank1(void)
{
  /* Authorize the FPEC of Bank1 Access */
  FLASH->KEYR = FLASH_KEY1;
 800062a:	6059      	str	r1, [r3, #4]
  FLASH->KEYR = FLASH_KEY2;
 800062c:	605a      	str	r2, [r3, #4]
 800062e:	4770      	bx	lr
 8000630:	40022000 	.word	0x40022000
 8000634:	45670123 	.word	0x45670123
 8000638:	cdef89ab 	.word	0xcdef89ab

0800063c <FLASH_Lock>:
  * @retval None
  */
void FLASH_Lock(void)
{
  /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
  FLASH->CR |= CR_LOCK_Set;
 800063c:	4a02      	ldr	r2, [pc, #8]	; (8000648 <FLASH_Lock+0xc>)
 800063e:	6913      	ldr	r3, [r2, #16]
 8000640:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000644:	6113      	str	r3, [r2, #16]
 8000646:	4770      	bx	lr
 8000648:	40022000 	.word	0x40022000

0800064c <FLASH_LockBank1>:
  * @retval None
  */
void FLASH_LockBank1(void)
{
  /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
  FLASH->CR |= CR_LOCK_Set;
 800064c:	4a02      	ldr	r2, [pc, #8]	; (8000658 <FLASH_LockBank1+0xc>)
 800064e:	6913      	ldr	r3, [r2, #16]
 8000650:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000654:	6113      	str	r3, [r2, #16]
 8000656:	4770      	bx	lr
 8000658:	40022000 	.word	0x40022000

0800065c <FLASH_ErasePage>:
  * @param  Page_Address: The page address to be erased.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
{
 800065c:	b410      	push	{r4}
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 800065e:	4c34      	ldr	r4, [pc, #208]	; (8000730 <FLASH_ErasePage+0xd4>)
 8000660:	68e3      	ldr	r3, [r4, #12]
 8000662:	07db      	lsls	r3, r3, #31
 8000664:	d423      	bmi.n	80006ae <FLASH_ErasePage+0x52>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000666:	68e3      	ldr	r3, [r4, #12]
 8000668:	0759      	lsls	r1, r3, #29
 800066a:	d503      	bpl.n	8000674 <FLASH_ErasePage+0x18>
    { 
      flashstatus = FLASH_ERROR_PG;
 800066c:	2002      	movs	r0, #2
  }
#endif /* STM32F10X_XL */

  /* Return the Erase Status */
  return status;
}
 800066e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000672:	4770      	bx	lr
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000674:	68e3      	ldr	r3, [r4, #12]
 8000676:	06da      	lsls	r2, r3, #27
 8000678:	d436      	bmi.n	80006e8 <FLASH_ErasePage+0x8c>
  status = FLASH_WaitForLastOperation(EraseTimeout);
  
  if(status == FLASH_COMPLETE)
  { 
    /* if the previous operation is completed, proceed to erase the page */
    FLASH->CR|= CR_PER_Set;
 800067a:	4b2d      	ldr	r3, [pc, #180]	; (8000730 <FLASH_ErasePage+0xd4>)
 800067c:	691a      	ldr	r2, [r3, #16]
 800067e:	f042 0202 	orr.w	r2, r2, #2
 8000682:	611a      	str	r2, [r3, #16]
    FLASH->AR = Page_Address; 
 8000684:	6158      	str	r0, [r3, #20]
    FLASH->CR|= CR_STRT_Set;
 8000686:	691a      	ldr	r2, [r3, #16]
 8000688:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800068c:	611a      	str	r2, [r3, #16]
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 800068e:	68da      	ldr	r2, [r3, #12]
 8000690:	07d1      	lsls	r1, r2, #31
 8000692:	d42b      	bmi.n	80006ec <FLASH_ErasePage+0x90>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000694:	68da      	ldr	r2, [r3, #12]
 8000696:	0752      	lsls	r2, r2, #29
 8000698:	d542      	bpl.n	8000720 <FLASH_ErasePage+0xc4>
    { 
      flashstatus = FLASH_ERROR_PG;
 800069a:	2002      	movs	r0, #2
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
    
    /* Disable the PER Bit */
    FLASH->CR &= CR_PER_Reset;
 800069c:	f641 73fd 	movw	r3, #8189	; 0x1ffd
 80006a0:	4a23      	ldr	r2, [pc, #140]	; (8000730 <FLASH_ErasePage+0xd4>)
  }
#endif /* STM32F10X_XL */

  /* Return the Erase Status */
  return status;
}
 80006a2:	f85d 4b04 	ldr.w	r4, [sp], #4
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
    
    /* Disable the PER Bit */
    FLASH->CR &= CR_PER_Reset;
 80006a6:	6911      	ldr	r1, [r2, #16]
 80006a8:	400b      	ands	r3, r1
 80006aa:	6113      	str	r3, [r2, #16]
  }
#endif /* STM32F10X_XL */

  /* Return the Erase Status */
  return status;
}
 80006ac:	4770      	bx	lr
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 80006ae:	f44f 2230 	mov.w	r2, #720896	; 0xb0000
 80006b2:	68e3      	ldr	r3, [r4, #12]
 80006b4:	491e      	ldr	r1, [pc, #120]	; (8000730 <FLASH_ErasePage+0xd4>)
 80006b6:	07db      	lsls	r3, r3, #31
 80006b8:	d409      	bmi.n	80006ce <FLASH_ErasePage+0x72>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 80006ba:	68cb      	ldr	r3, [r1, #12]
 80006bc:	075b      	lsls	r3, r3, #29
 80006be:	d50a      	bpl.n	80006d6 <FLASH_ErasePage+0x7a>
    { 
      flashstatus = FLASH_ERROR_PG;
 80006c0:	2002      	movs	r0, #2
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 80006c2:	2a01      	cmp	r2, #1
 80006c4:	bf08      	it	eq
 80006c6:	2005      	moveq	r0, #5
  }
#endif /* STM32F10X_XL */

  /* Return the Erase Status */
  return status;
}
 80006c8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80006cc:	4770      	bx	lr
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 80006ce:	3a01      	subs	r2, #1
 80006d0:	d1ef      	bne.n	80006b2 <FLASH_ErasePage+0x56>
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 80006d2:	2005      	movs	r0, #5
 80006d4:	e7cb      	b.n	800066e <FLASH_ErasePage+0x12>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 80006d6:	68cb      	ldr	r3, [r1, #12]
 80006d8:	06dc      	lsls	r4, r3, #27
 80006da:	d501      	bpl.n	80006e0 <FLASH_ErasePage+0x84>
      {
        flashstatus = FLASH_ERROR_WRP;
 80006dc:	2003      	movs	r0, #3
 80006de:	e7f0      	b.n	80006c2 <FLASH_ErasePage+0x66>
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 80006e0:	2a01      	cmp	r2, #1
 80006e2:	d1ca      	bne.n	800067a <FLASH_ErasePage+0x1e>
  {
    status = FLASH_TIMEOUT;
 80006e4:	2005      	movs	r0, #5
 80006e6:	e7c2      	b.n	800066e <FLASH_ErasePage+0x12>
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
      {
        flashstatus = FLASH_ERROR_WRP;
 80006e8:	2003      	movs	r0, #3
 80006ea:	e7c0      	b.n	800066e <FLASH_ErasePage+0x12>
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 80006ec:	4618      	mov	r0, r3
 80006ee:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
 80006f2:	68c3      	ldr	r3, [r0, #12]
 80006f4:	4a0e      	ldr	r2, [pc, #56]	; (8000730 <FLASH_ErasePage+0xd4>)
 80006f6:	07dc      	lsls	r4, r3, #31
 80006f8:	d407      	bmi.n	800070a <FLASH_ErasePage+0xae>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 80006fa:	68d3      	ldr	r3, [r2, #12]
 80006fc:	075b      	lsls	r3, r3, #29
 80006fe:	d508      	bpl.n	8000712 <FLASH_ErasePage+0xb6>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000700:	2002      	movs	r0, #2
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 8000702:	2901      	cmp	r1, #1
 8000704:	bf08      	it	eq
 8000706:	2005      	moveq	r0, #5
 8000708:	e7c8      	b.n	800069c <FLASH_ErasePage+0x40>
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 800070a:	3901      	subs	r1, #1
 800070c:	d1f1      	bne.n	80006f2 <FLASH_ErasePage+0x96>
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 800070e:	2005      	movs	r0, #5
 8000710:	e7c4      	b.n	800069c <FLASH_ErasePage+0x40>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000712:	68d3      	ldr	r3, [r2, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 8000714:	f013 0f10 	tst.w	r3, #16
 8000718:	bf14      	ite	ne
 800071a:	2003      	movne	r0, #3
 800071c:	2004      	moveq	r0, #4
 800071e:	e7f0      	b.n	8000702 <FLASH_ErasePage+0xa6>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000720:	68db      	ldr	r3, [r3, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 8000722:	f013 0f10 	tst.w	r3, #16
 8000726:	bf14      	ite	ne
 8000728:	2003      	movne	r0, #3
 800072a:	2004      	moveq	r0, #4
 800072c:	e7b6      	b.n	800069c <FLASH_ErasePage+0x40>
 800072e:	bf00      	nop
 8000730:	40022000 	.word	0x40022000

08000734 <FLASH_EraseAllPages>:
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000734:	4832      	ldr	r0, [pc, #200]	; (8000800 <FLASH_EraseAllPages+0xcc>)
 8000736:	68c3      	ldr	r3, [r0, #12]
 8000738:	07db      	lsls	r3, r3, #31
 800073a:	d41e      	bmi.n	800077a <FLASH_EraseAllPages+0x46>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 800073c:	68c3      	ldr	r3, [r0, #12]
 800073e:	0759      	lsls	r1, r3, #29
 8000740:	d501      	bpl.n	8000746 <FLASH_EraseAllPages+0x12>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000742:	2002      	movs	r0, #2
 8000744:	4770      	bx	lr
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000746:	68c3      	ldr	r3, [r0, #12]
 8000748:	06da      	lsls	r2, r3, #27
 800074a:	d436      	bmi.n	80007ba <FLASH_EraseAllPages+0x86>
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(EraseTimeout);
  if(status == FLASH_COMPLETE)
  {
    /* if the previous operation is completed, proceed to erase all pages */
     FLASH->CR |= CR_MER_Set;
 800074c:	482c      	ldr	r0, [pc, #176]	; (8000800 <FLASH_EraseAllPages+0xcc>)
 800074e:	6903      	ldr	r3, [r0, #16]
 8000750:	f043 0304 	orr.w	r3, r3, #4
 8000754:	6103      	str	r3, [r0, #16]
     FLASH->CR |= CR_STRT_Set;
 8000756:	6903      	ldr	r3, [r0, #16]
 8000758:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800075c:	6103      	str	r3, [r0, #16]
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 800075e:	68c3      	ldr	r3, [r0, #12]
 8000760:	07d9      	lsls	r1, r3, #31
 8000762:	d42c      	bmi.n	80007be <FLASH_EraseAllPages+0x8a>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000764:	68c3      	ldr	r3, [r0, #12]
 8000766:	075a      	lsls	r2, r3, #29
 8000768:	d542      	bpl.n	80007f0 <FLASH_EraseAllPages+0xbc>
    { 
      flashstatus = FLASH_ERROR_PG;
 800076a:	2002      	movs	r0, #2
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);

    /* Disable the MER Bit */
    FLASH->CR &= CR_MER_Reset;
 800076c:	f641 73fb 	movw	r3, #8187	; 0x1ffb
 8000770:	4a23      	ldr	r2, [pc, #140]	; (8000800 <FLASH_EraseAllPages+0xcc>)
 8000772:	6911      	ldr	r1, [r2, #16]
 8000774:	400b      	ands	r3, r1
 8000776:	6113      	str	r3, [r2, #16]
 8000778:	4770      	bx	lr
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 800077a:	f44f 2230 	mov.w	r2, #720896	; 0xb0000
 800077e:	68c3      	ldr	r3, [r0, #12]
 8000780:	491f      	ldr	r1, [pc, #124]	; (8000800 <FLASH_EraseAllPages+0xcc>)
 8000782:	07db      	lsls	r3, r3, #31
 8000784:	d408      	bmi.n	8000798 <FLASH_EraseAllPages+0x64>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000786:	68cb      	ldr	r3, [r1, #12]
 8000788:	075b      	lsls	r3, r3, #29
 800078a:	d509      	bpl.n	80007a0 <FLASH_EraseAllPages+0x6c>
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 800078c:	2a01      	cmp	r2, #1
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
    { 
      flashstatus = FLASH_ERROR_PG;
 800078e:	f04f 0002 	mov.w	r0, #2
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 8000792:	bf08      	it	eq
 8000794:	2005      	moveq	r0, #5
 8000796:	4770      	bx	lr
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 8000798:	3a01      	subs	r2, #1
 800079a:	d1f0      	bne.n	800077e <FLASH_EraseAllPages+0x4a>
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 800079c:	2005      	movs	r0, #5
 800079e:	4770      	bx	lr
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 80007a0:	68cb      	ldr	r3, [r1, #12]
 80007a2:	06d8      	lsls	r0, r3, #27
 80007a4:	d505      	bpl.n	80007b2 <FLASH_EraseAllPages+0x7e>
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 80007a6:	2a01      	cmp	r2, #1
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
      {
        flashstatus = FLASH_ERROR_WRP;
 80007a8:	f04f 0003 	mov.w	r0, #3
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 80007ac:	bf08      	it	eq
 80007ae:	2005      	moveq	r0, #5
 80007b0:	4770      	bx	lr
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 80007b2:	2a01      	cmp	r2, #1
 80007b4:	d1ca      	bne.n	800074c <FLASH_EraseAllPages+0x18>
  {
    status = FLASH_TIMEOUT;
 80007b6:	2005      	movs	r0, #5
 80007b8:	4770      	bx	lr
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
      {
        flashstatus = FLASH_ERROR_WRP;
 80007ba:	2003      	movs	r0, #3
 80007bc:	4770      	bx	lr
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 80007be:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
 80007c2:	68c3      	ldr	r3, [r0, #12]
 80007c4:	4a0e      	ldr	r2, [pc, #56]	; (8000800 <FLASH_EraseAllPages+0xcc>)
 80007c6:	07db      	lsls	r3, r3, #31
 80007c8:	d407      	bmi.n	80007da <FLASH_EraseAllPages+0xa6>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 80007ca:	68d3      	ldr	r3, [r2, #12]
 80007cc:	075b      	lsls	r3, r3, #29
 80007ce:	d508      	bpl.n	80007e2 <FLASH_EraseAllPages+0xae>
    { 
      flashstatus = FLASH_ERROR_PG;
 80007d0:	2002      	movs	r0, #2
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 80007d2:	2901      	cmp	r1, #1
 80007d4:	bf08      	it	eq
 80007d6:	2005      	moveq	r0, #5
 80007d8:	e7c8      	b.n	800076c <FLASH_EraseAllPages+0x38>
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 80007da:	3901      	subs	r1, #1
 80007dc:	d1f1      	bne.n	80007c2 <FLASH_EraseAllPages+0x8e>
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 80007de:	2005      	movs	r0, #5
 80007e0:	e7c4      	b.n	800076c <FLASH_EraseAllPages+0x38>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 80007e2:	68d3      	ldr	r3, [r2, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 80007e4:	f013 0f10 	tst.w	r3, #16
 80007e8:	bf14      	ite	ne
 80007ea:	2003      	movne	r0, #3
 80007ec:	2004      	moveq	r0, #4
 80007ee:	e7f0      	b.n	80007d2 <FLASH_EraseAllPages+0x9e>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 80007f0:	68c3      	ldr	r3, [r0, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 80007f2:	f013 0f10 	tst.w	r3, #16
 80007f6:	bf14      	ite	ne
 80007f8:	2003      	movne	r0, #3
 80007fa:	2004      	moveq	r0, #4
 80007fc:	e7b6      	b.n	800076c <FLASH_EraseAllPages+0x38>
 80007fe:	bf00      	nop
 8000800:	40022000 	.word	0x40022000

08000804 <FLASH_EraseAllBank1Pages>:
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000804:	4832      	ldr	r0, [pc, #200]	; (80008d0 <FLASH_EraseAllBank1Pages+0xcc>)
 8000806:	68c3      	ldr	r3, [r0, #12]
 8000808:	07db      	lsls	r3, r3, #31
 800080a:	d41e      	bmi.n	800084a <FLASH_EraseAllBank1Pages+0x46>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 800080c:	68c3      	ldr	r3, [r0, #12]
 800080e:	0759      	lsls	r1, r3, #29
 8000810:	d501      	bpl.n	8000816 <FLASH_EraseAllBank1Pages+0x12>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000812:	2002      	movs	r0, #2
 8000814:	4770      	bx	lr
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000816:	68c3      	ldr	r3, [r0, #12]
 8000818:	06da      	lsls	r2, r3, #27
 800081a:	d436      	bmi.n	800088a <FLASH_EraseAllBank1Pages+0x86>
  status = FLASH_WaitForLastBank1Operation(EraseTimeout);
  
  if(status == FLASH_COMPLETE)
  {
    /* if the previous operation is completed, proceed to erase all pages */
     FLASH->CR |= CR_MER_Set;
 800081c:	482c      	ldr	r0, [pc, #176]	; (80008d0 <FLASH_EraseAllBank1Pages+0xcc>)
 800081e:	6903      	ldr	r3, [r0, #16]
 8000820:	f043 0304 	orr.w	r3, r3, #4
 8000824:	6103      	str	r3, [r0, #16]
     FLASH->CR |= CR_STRT_Set;
 8000826:	6903      	ldr	r3, [r0, #16]
 8000828:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800082c:	6103      	str	r3, [r0, #16]
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 800082e:	68c3      	ldr	r3, [r0, #12]
 8000830:	07d9      	lsls	r1, r3, #31
 8000832:	d42c      	bmi.n	800088e <FLASH_EraseAllBank1Pages+0x8a>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000834:	68c3      	ldr	r3, [r0, #12]
 8000836:	075a      	lsls	r2, r3, #29
 8000838:	d542      	bpl.n	80008c0 <FLASH_EraseAllBank1Pages+0xbc>
    { 
      flashstatus = FLASH_ERROR_PG;
 800083a:	2002      	movs	r0, #2
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastBank1Operation(EraseTimeout);
    
    /* Disable the MER Bit */
    FLASH->CR &= CR_MER_Reset;
 800083c:	f641 73fb 	movw	r3, #8187	; 0x1ffb
 8000840:	4a23      	ldr	r2, [pc, #140]	; (80008d0 <FLASH_EraseAllBank1Pages+0xcc>)
 8000842:	6911      	ldr	r1, [r2, #16]
 8000844:	400b      	ands	r3, r1
 8000846:	6113      	str	r3, [r2, #16]
 8000848:	4770      	bx	lr
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 800084a:	f44f 2230 	mov.w	r2, #720896	; 0xb0000
 800084e:	68c3      	ldr	r3, [r0, #12]
 8000850:	491f      	ldr	r1, [pc, #124]	; (80008d0 <FLASH_EraseAllBank1Pages+0xcc>)
 8000852:	07db      	lsls	r3, r3, #31
 8000854:	d408      	bmi.n	8000868 <FLASH_EraseAllBank1Pages+0x64>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000856:	68cb      	ldr	r3, [r1, #12]
 8000858:	075b      	lsls	r3, r3, #29
 800085a:	d509      	bpl.n	8000870 <FLASH_EraseAllBank1Pages+0x6c>
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 800085c:	2a01      	cmp	r2, #1
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
    { 
      flashstatus = FLASH_ERROR_PG;
 800085e:	f04f 0002 	mov.w	r0, #2
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 8000862:	bf08      	it	eq
 8000864:	2005      	moveq	r0, #5
 8000866:	4770      	bx	lr
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_FLAG_BANK1_BSY) && (Timeout != 0x00))
 8000868:	3a01      	subs	r2, #1
 800086a:	d1f0      	bne.n	800084e <FLASH_EraseAllBank1Pages+0x4a>
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 800086c:	2005      	movs	r0, #5
 800086e:	4770      	bx	lr
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000870:	68cb      	ldr	r3, [r1, #12]
 8000872:	06d8      	lsls	r0, r3, #27
 8000874:	d505      	bpl.n	8000882 <FLASH_EraseAllBank1Pages+0x7e>
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 8000876:	2a01      	cmp	r2, #1
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
      {
        flashstatus = FLASH_ERROR_WRP;
 8000878:	f04f 0003 	mov.w	r0, #3
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 800087c:	bf08      	it	eq
 800087e:	2005      	moveq	r0, #5
 8000880:	4770      	bx	lr
  while((status == FLASH_FLAG_BANK1_BSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000882:	2a01      	cmp	r2, #1
 8000884:	d1ca      	bne.n	800081c <FLASH_EraseAllBank1Pages+0x18>
  {
    status = FLASH_TIMEOUT;
 8000886:	2005      	movs	r0, #5
 8000888:	4770      	bx	lr
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
      {
        flashstatus = FLASH_ERROR_WRP;
 800088a:	2003      	movs	r0, #3
 800088c:	4770      	bx	lr
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 800088e:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
 8000892:	68c3      	ldr	r3, [r0, #12]
 8000894:	4a0e      	ldr	r2, [pc, #56]	; (80008d0 <FLASH_EraseAllBank1Pages+0xcc>)
 8000896:	07db      	lsls	r3, r3, #31
 8000898:	d407      	bmi.n	80008aa <FLASH_EraseAllBank1Pages+0xa6>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 800089a:	68d3      	ldr	r3, [r2, #12]
 800089c:	075b      	lsls	r3, r3, #29
 800089e:	d508      	bpl.n	80008b2 <FLASH_EraseAllBank1Pages+0xae>
    { 
      flashstatus = FLASH_ERROR_PG;
 80008a0:	2002      	movs	r0, #2
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 80008a2:	2901      	cmp	r1, #1
 80008a4:	bf08      	it	eq
 80008a6:	2005      	moveq	r0, #5
 80008a8:	e7c8      	b.n	800083c <FLASH_EraseAllBank1Pages+0x38>
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_FLAG_BANK1_BSY) && (Timeout != 0x00))
 80008aa:	3901      	subs	r1, #1
 80008ac:	d1f1      	bne.n	8000892 <FLASH_EraseAllBank1Pages+0x8e>
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 80008ae:	2005      	movs	r0, #5
 80008b0:	e7c4      	b.n	800083c <FLASH_EraseAllBank1Pages+0x38>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 80008b2:	68d3      	ldr	r3, [r2, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 80008b4:	f013 0f10 	tst.w	r3, #16
 80008b8:	bf14      	ite	ne
 80008ba:	2003      	movne	r0, #3
 80008bc:	2004      	moveq	r0, #4
 80008be:	e7f0      	b.n	80008a2 <FLASH_EraseAllBank1Pages+0x9e>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 80008c0:	68c3      	ldr	r3, [r0, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 80008c2:	f013 0f10 	tst.w	r3, #16
 80008c6:	bf14      	ite	ne
 80008c8:	2003      	movne	r0, #3
 80008ca:	2004      	moveq	r0, #4
 80008cc:	e7b6      	b.n	800083c <FLASH_EraseAllBank1Pages+0x38>
 80008ce:	bf00      	nop
 80008d0:	40022000 	.word	0x40022000

080008d4 <FLASH_EraseOptionBytes>:
  * @retval FLASH ReadOut Protection Status(SET or RESET)
  */
FlagStatus FLASH_GetReadOutProtectionStatus(void)
{
  FlagStatus readoutstatus = RESET;
  if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
 80008d4:	484b      	ldr	r0, [pc, #300]	; (8000a04 <FLASH_EraseOptionBytes+0x130>)
  * @param  None
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_EraseOptionBytes(void)
{
 80008d6:	b430      	push	{r4, r5}
  * @retval FLASH ReadOut Protection Status(SET or RESET)
  */
FlagStatus FLASH_GetReadOutProtectionStatus(void)
{
  FlagStatus readoutstatus = RESET;
  if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
 80008d8:	69c2      	ldr	r2, [r0, #28]
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 80008da:	68c3      	ldr	r3, [r0, #12]
  FLASH_Status status = FLASH_COMPLETE;

  /* Get the actual read protection Option Byte value */ 
  if(FLASH_GetReadOutProtectionStatus() != RESET)
  {
    rdptmp = 0x00;  
 80008dc:	f012 0f02 	tst.w	r2, #2
 80008e0:	bf0c      	ite	eq
 80008e2:	25a5      	moveq	r5, #165	; 0xa5
 80008e4:	2500      	movne	r5, #0
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 80008e6:	07d9      	lsls	r1, r3, #31
 80008e8:	d424      	bmi.n	8000934 <FLASH_EraseOptionBytes+0x60>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 80008ea:	68c3      	ldr	r3, [r0, #12]
 80008ec:	075a      	lsls	r2, r3, #29
 80008ee:	d502      	bpl.n	80008f6 <FLASH_EraseOptionBytes+0x22>
    { 
      flashstatus = FLASH_ERROR_PG;
 80008f0:	2002      	movs	r0, #2
      }
    }  
  }
  /* Return the erase status */
  return status;
}
 80008f2:	bc30      	pop	{r4, r5}
 80008f4:	4770      	bx	lr
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 80008f6:	68c3      	ldr	r3, [r0, #12]
 80008f8:	06db      	lsls	r3, r3, #27
 80008fa:	d435      	bmi.n	8000968 <FLASH_EraseOptionBytes+0x94>
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(EraseTimeout);
  if(status == FLASH_COMPLETE)
  {
    /* Authorize the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 80008fc:	4a41      	ldr	r2, [pc, #260]	; (8000a04 <FLASH_EraseOptionBytes+0x130>)
    FLASH->OPTKEYR = FLASH_KEY2;
 80008fe:	4b42      	ldr	r3, [pc, #264]	; (8000a08 <FLASH_EraseOptionBytes+0x134>)
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(EraseTimeout);
  if(status == FLASH_COMPLETE)
  {
    /* Authorize the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 8000900:	4942      	ldr	r1, [pc, #264]	; (8000a0c <FLASH_EraseOptionBytes+0x138>)
 8000902:	6091      	str	r1, [r2, #8]
    FLASH->OPTKEYR = FLASH_KEY2;
 8000904:	6093      	str	r3, [r2, #8]
    
    /* if the previous operation is completed, proceed to erase the option bytes */
    FLASH->CR |= CR_OPTER_Set;
 8000906:	6913      	ldr	r3, [r2, #16]
 8000908:	f043 0320 	orr.w	r3, r3, #32
 800090c:	6113      	str	r3, [r2, #16]
    FLASH->CR |= CR_STRT_Set;
 800090e:	6913      	ldr	r3, [r2, #16]
 8000910:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000914:	6113      	str	r3, [r2, #16]
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000916:	68d3      	ldr	r3, [r2, #12]
 8000918:	07d8      	lsls	r0, r3, #31
 800091a:	d427      	bmi.n	800096c <FLASH_EraseOptionBytes+0x98>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 800091c:	68d3      	ldr	r3, [r2, #12]
 800091e:	0759      	lsls	r1, r3, #29
 8000920:	d554      	bpl.n	80009cc <FLASH_EraseOptionBytes+0xf8>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000922:	2002      	movs	r0, #2
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 
      if(status != FLASH_TIMEOUT)
      {
        /* if the program operation is completed, disable the OPTPG Bit */
        FLASH->CR &= CR_OPTPG_Reset;
 8000924:	f641 73ef 	movw	r3, #8175	; 0x1fef
      }
    }  
  }
  /* Return the erase status */
  return status;
}
 8000928:	bc30      	pop	{r4, r5}
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 
      if(status != FLASH_TIMEOUT)
      {
        /* if the program operation is completed, disable the OPTPG Bit */
        FLASH->CR &= CR_OPTPG_Reset;
 800092a:	4a36      	ldr	r2, [pc, #216]	; (8000a04 <FLASH_EraseOptionBytes+0x130>)
 800092c:	6911      	ldr	r1, [r2, #16]
 800092e:	400b      	ands	r3, r1
 8000930:	6113      	str	r3, [r2, #16]
      }
    }  
  }
  /* Return the erase status */
  return status;
}
 8000932:	4770      	bx	lr
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000934:	f44f 2230 	mov.w	r2, #720896	; 0xb0000
 8000938:	68c3      	ldr	r3, [r0, #12]
 800093a:	4932      	ldr	r1, [pc, #200]	; (8000a04 <FLASH_EraseOptionBytes+0x130>)
 800093c:	07dc      	lsls	r4, r3, #31
 800093e:	d408      	bmi.n	8000952 <FLASH_EraseOptionBytes+0x7e>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000940:	68cb      	ldr	r3, [r1, #12]
 8000942:	075b      	lsls	r3, r3, #29
 8000944:	d508      	bpl.n	8000958 <FLASH_EraseOptionBytes+0x84>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000946:	2002      	movs	r0, #2
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000948:	2a01      	cmp	r2, #1
 800094a:	d1d2      	bne.n	80008f2 <FLASH_EraseOptionBytes+0x1e>
      }
    }  
  }
  /* Return the erase status */
  return status;
}
 800094c:	bc30      	pop	{r4, r5}
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 800094e:	2005      	movs	r0, #5
      }
    }  
  }
  /* Return the erase status */
  return status;
}
 8000950:	4770      	bx	lr
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 8000952:	3a01      	subs	r2, #1
 8000954:	d1f0      	bne.n	8000938 <FLASH_EraseOptionBytes+0x64>
 8000956:	e7f9      	b.n	800094c <FLASH_EraseOptionBytes+0x78>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000958:	68cb      	ldr	r3, [r1, #12]
 800095a:	06dc      	lsls	r4, r3, #27
 800095c:	d501      	bpl.n	8000962 <FLASH_EraseOptionBytes+0x8e>
      {
        flashstatus = FLASH_ERROR_WRP;
 800095e:	2003      	movs	r0, #3
 8000960:	e7f2      	b.n	8000948 <FLASH_EraseOptionBytes+0x74>
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000962:	2a01      	cmp	r2, #1
 8000964:	d0f2      	beq.n	800094c <FLASH_EraseOptionBytes+0x78>
 8000966:	e7c9      	b.n	80008fc <FLASH_EraseOptionBytes+0x28>
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
      {
        flashstatus = FLASH_ERROR_WRP;
 8000968:	2003      	movs	r0, #3
 800096a:	e7c2      	b.n	80008f2 <FLASH_EraseOptionBytes+0x1e>
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 800096c:	f44f 2430 	mov.w	r4, #720896	; 0xb0000
 8000970:	68d3      	ldr	r3, [r2, #12]
 8000972:	4924      	ldr	r1, [pc, #144]	; (8000a04 <FLASH_EraseOptionBytes+0x130>)
 8000974:	07db      	lsls	r3, r3, #31
 8000976:	d406      	bmi.n	8000986 <FLASH_EraseOptionBytes+0xb2>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000978:	68cb      	ldr	r3, [r1, #12]
 800097a:	0758      	lsls	r0, r3, #29
 800097c:	d506      	bpl.n	800098c <FLASH_EraseOptionBytes+0xb8>
    { 
      flashstatus = FLASH_ERROR_PG;
 800097e:	2002      	movs	r0, #2
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000980:	2c01      	cmp	r4, #1
 8000982:	d0e3      	beq.n	800094c <FLASH_EraseOptionBytes+0x78>
 8000984:	e7ce      	b.n	8000924 <FLASH_EraseOptionBytes+0x50>
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 8000986:	3c01      	subs	r4, #1
 8000988:	d1f2      	bne.n	8000970 <FLASH_EraseOptionBytes+0x9c>
 800098a:	e7df      	b.n	800094c <FLASH_EraseOptionBytes+0x78>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 800098c:	68cb      	ldr	r3, [r1, #12]
 800098e:	06da      	lsls	r2, r3, #27
 8000990:	d501      	bpl.n	8000996 <FLASH_EraseOptionBytes+0xc2>
      {
        flashstatus = FLASH_ERROR_WRP;
 8000992:	2003      	movs	r0, #3
 8000994:	e7f4      	b.n	8000980 <FLASH_EraseOptionBytes+0xac>
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000996:	2c01      	cmp	r4, #1
 8000998:	d0d8      	beq.n	800094c <FLASH_EraseOptionBytes+0x78>
    status = FLASH_WaitForLastOperation(EraseTimeout);
    
    if(status == FLASH_COMPLETE)
    {
      /* if the erase operation is completed, disable the OPTER Bit */
      FLASH->CR &= CR_OPTER_Reset;
 800099a:	f641 73df 	movw	r3, #8159	; 0x1fdf
 800099e:	4819      	ldr	r0, [pc, #100]	; (8000a04 <FLASH_EraseOptionBytes+0x130>)
       
      /* Enable the Option Bytes Programming operation */
      FLASH->CR |= CR_OPTPG_Set;
      /* Restore the last read protection Option Byte value */
      OB->RDP = (uint16_t)rdptmp; 
 80009a0:	4a1b      	ldr	r2, [pc, #108]	; (8000a10 <FLASH_EraseOptionBytes+0x13c>)
    status = FLASH_WaitForLastOperation(EraseTimeout);
    
    if(status == FLASH_COMPLETE)
    {
      /* if the erase operation is completed, disable the OPTER Bit */
      FLASH->CR &= CR_OPTER_Reset;
 80009a2:	6901      	ldr	r1, [r0, #16]
 80009a4:	400b      	ands	r3, r1
 80009a6:	6103      	str	r3, [r0, #16]
       
      /* Enable the Option Bytes Programming operation */
      FLASH->CR |= CR_OPTPG_Set;
 80009a8:	6903      	ldr	r3, [r0, #16]
 80009aa:	f043 0310 	orr.w	r3, r3, #16
 80009ae:	6103      	str	r3, [r0, #16]
      /* Restore the last read protection Option Byte value */
      OB->RDP = (uint16_t)rdptmp; 
 80009b0:	8015      	strh	r5, [r2, #0]
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 80009b2:	68c3      	ldr	r3, [r0, #12]
 80009b4:	07db      	lsls	r3, r3, #31
 80009b6:	d40e      	bmi.n	80009d6 <FLASH_EraseOptionBytes+0x102>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 80009b8:	68c3      	ldr	r3, [r0, #12]
 80009ba:	075d      	lsls	r5, r3, #29
 80009bc:	d4b1      	bmi.n	8000922 <FLASH_EraseOptionBytes+0x4e>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 80009be:	68c3      	ldr	r3, [r0, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 80009c0:	f013 0f10 	tst.w	r3, #16
 80009c4:	bf14      	ite	ne
 80009c6:	2003      	movne	r0, #3
 80009c8:	2004      	moveq	r0, #4
 80009ca:	e7ab      	b.n	8000924 <FLASH_EraseOptionBytes+0x50>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 80009cc:	68d3      	ldr	r3, [r2, #12]
 80009ce:	06da      	lsls	r2, r3, #27
 80009d0:	d5e3      	bpl.n	800099a <FLASH_EraseOptionBytes+0xc6>
      {
        flashstatus = FLASH_ERROR_WRP;
 80009d2:	2003      	movs	r0, #3
 80009d4:	e7a6      	b.n	8000924 <FLASH_EraseOptionBytes+0x50>
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 80009d6:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80009da:	68c3      	ldr	r3, [r0, #12]
 80009dc:	4a09      	ldr	r2, [pc, #36]	; (8000a04 <FLASH_EraseOptionBytes+0x130>)
 80009de:	07dc      	lsls	r4, r3, #31
 80009e0:	d406      	bmi.n	80009f0 <FLASH_EraseOptionBytes+0x11c>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 80009e2:	68d3      	ldr	r3, [r2, #12]
 80009e4:	075b      	lsls	r3, r3, #29
 80009e6:	d506      	bpl.n	80009f6 <FLASH_EraseOptionBytes+0x122>
    { 
      flashstatus = FLASH_ERROR_PG;
 80009e8:	2002      	movs	r0, #2
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 80009ea:	2901      	cmp	r1, #1
 80009ec:	d0ae      	beq.n	800094c <FLASH_EraseOptionBytes+0x78>
 80009ee:	e799      	b.n	8000924 <FLASH_EraseOptionBytes+0x50>
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 80009f0:	3901      	subs	r1, #1
 80009f2:	d1f2      	bne.n	80009da <FLASH_EraseOptionBytes+0x106>
 80009f4:	e7aa      	b.n	800094c <FLASH_EraseOptionBytes+0x78>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 80009f6:	68d3      	ldr	r3, [r2, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 80009f8:	f013 0f10 	tst.w	r3, #16
 80009fc:	bf14      	ite	ne
 80009fe:	2003      	movne	r0, #3
 8000a00:	2004      	moveq	r0, #4
 8000a02:	e7f2      	b.n	80009ea <FLASH_EraseOptionBytes+0x116>
 8000a04:	40022000 	.word	0x40022000
 8000a08:	cdef89ab 	.word	0xcdef89ab
 8000a0c:	45670123 	.word	0x45670123
 8000a10:	1ffff800 	.word	0x1ffff800

08000a14 <FLASH_ProgramWord>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
  */
FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
{
 8000a14:	b430      	push	{r4, r5}
  FLASH_Status status = FLASH_COMPLETE;
  __IO uint32_t tmp = 0;
 8000a16:	2300      	movs	r3, #0
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
  */
FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
{
 8000a18:	b082      	sub	sp, #8
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000a1a:	4d48      	ldr	r5, [pc, #288]	; (8000b3c <FLASH_ProgramWord+0x128>)
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
  */
FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
{
  FLASH_Status status = FLASH_COMPLETE;
  __IO uint32_t tmp = 0;
 8000a1c:	9301      	str	r3, [sp, #4]
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000a1e:	68eb      	ldr	r3, [r5, #12]
 8000a20:	07db      	lsls	r3, r3, #31
 8000a22:	d420      	bmi.n	8000a66 <FLASH_ProgramWord+0x52>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000a24:	68eb      	ldr	r3, [r5, #12]
 8000a26:	075c      	lsls	r4, r3, #29
 8000a28:	d503      	bpl.n	8000a32 <FLASH_ProgramWord+0x1e>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000a2a:	2002      	movs	r0, #2
  }         
#endif /* STM32F10X_XL */
   
  /* Return the Program Status */
  return status;
}
 8000a2c:	b002      	add	sp, #8
 8000a2e:	bc30      	pop	{r4, r5}
 8000a30:	4770      	bx	lr
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000a32:	68eb      	ldr	r3, [r5, #12]
 8000a34:	06da      	lsls	r2, r3, #27
 8000a36:	d433      	bmi.n	8000aa0 <FLASH_ProgramWord+0x8c>
  
  if(status == FLASH_COMPLETE)
  {
    /* if the previous operation is completed, proceed to program the new first 
    half word */
    FLASH->CR |= CR_PG_Set;
 8000a38:	4d40      	ldr	r5, [pc, #256]	; (8000b3c <FLASH_ProgramWord+0x128>)
  
    *(__IO uint16_t*)Address = (uint16_t)Data;
 8000a3a:	b28b      	uxth	r3, r1
  
  if(status == FLASH_COMPLETE)
  {
    /* if the previous operation is completed, proceed to program the new first 
    half word */
    FLASH->CR |= CR_PG_Set;
 8000a3c:	692a      	ldr	r2, [r5, #16]
 8000a3e:	f042 0201 	orr.w	r2, r2, #1
 8000a42:	612a      	str	r2, [r5, #16]
  
    *(__IO uint16_t*)Address = (uint16_t)Data;
 8000a44:	8003      	strh	r3, [r0, #0]
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000a46:	68eb      	ldr	r3, [r5, #12]
 8000a48:	07db      	lsls	r3, r3, #31
 8000a4a:	d42b      	bmi.n	8000aa4 <FLASH_ProgramWord+0x90>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000a4c:	68eb      	ldr	r3, [r5, #12]
 8000a4e:	075c      	lsls	r4, r3, #29
 8000a50:	d543      	bpl.n	8000ada <FLASH_ProgramWord+0xc6>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000a52:	2002      	movs	r0, #2
      FLASH->CR &= CR_PG_Reset;
    }
    else
    {
      /* Disable the PG Bit */
      FLASH->CR &= CR_PG_Reset;
 8000a54:	f641 73fe 	movw	r3, #8190	; 0x1ffe
 8000a58:	4a38      	ldr	r2, [pc, #224]	; (8000b3c <FLASH_ProgramWord+0x128>)
 8000a5a:	6911      	ldr	r1, [r2, #16]
 8000a5c:	400b      	ands	r3, r1
 8000a5e:	6113      	str	r3, [r2, #16]
  }         
#endif /* STM32F10X_XL */
   
  /* Return the Program Status */
  return status;
}
 8000a60:	b002      	add	sp, #8
 8000a62:	bc30      	pop	{r4, r5}
 8000a64:	4770      	bx	lr
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000a66:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8000a6a:	68eb      	ldr	r3, [r5, #12]
 8000a6c:	4c33      	ldr	r4, [pc, #204]	; (8000b3c <FLASH_ProgramWord+0x128>)
 8000a6e:	07db      	lsls	r3, r3, #31
 8000a70:	d409      	bmi.n	8000a86 <FLASH_ProgramWord+0x72>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000a72:	68e3      	ldr	r3, [r4, #12]
 8000a74:	075d      	lsls	r5, r3, #29
 8000a76:	d50a      	bpl.n	8000a8e <FLASH_ProgramWord+0x7a>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000a78:	2002      	movs	r0, #2
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 8000a7a:	2a01      	cmp	r2, #1
 8000a7c:	bf08      	it	eq
 8000a7e:	2005      	moveq	r0, #5
  }         
#endif /* STM32F10X_XL */
   
  /* Return the Program Status */
  return status;
}
 8000a80:	b002      	add	sp, #8
 8000a82:	bc30      	pop	{r4, r5}
 8000a84:	4770      	bx	lr
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 8000a86:	3a01      	subs	r2, #1
 8000a88:	d1ef      	bne.n	8000a6a <FLASH_ProgramWord+0x56>
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 8000a8a:	2005      	movs	r0, #5
 8000a8c:	e7ce      	b.n	8000a2c <FLASH_ProgramWord+0x18>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000a8e:	68e3      	ldr	r3, [r4, #12]
 8000a90:	06dc      	lsls	r4, r3, #27
 8000a92:	d501      	bpl.n	8000a98 <FLASH_ProgramWord+0x84>
      {
        flashstatus = FLASH_ERROR_WRP;
 8000a94:	2003      	movs	r0, #3
 8000a96:	e7f0      	b.n	8000a7a <FLASH_ProgramWord+0x66>
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000a98:	2a01      	cmp	r2, #1
 8000a9a:	d1cd      	bne.n	8000a38 <FLASH_ProgramWord+0x24>
  {
    status = FLASH_TIMEOUT;
 8000a9c:	2005      	movs	r0, #5
 8000a9e:	e7c5      	b.n	8000a2c <FLASH_ProgramWord+0x18>
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
      {
        flashstatus = FLASH_ERROR_WRP;
 8000aa0:	2003      	movs	r0, #3
 8000aa2:	e7c3      	b.n	8000a2c <FLASH_ProgramWord+0x18>
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000aa4:	f44f 5400 	mov.w	r4, #8192	; 0x2000
 8000aa8:	68eb      	ldr	r3, [r5, #12]
 8000aaa:	4a24      	ldr	r2, [pc, #144]	; (8000b3c <FLASH_ProgramWord+0x128>)
 8000aac:	07db      	lsls	r3, r3, #31
 8000aae:	d407      	bmi.n	8000ac0 <FLASH_ProgramWord+0xac>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000ab0:	68d3      	ldr	r3, [r2, #12]
 8000ab2:	075d      	lsls	r5, r3, #29
 8000ab4:	d508      	bpl.n	8000ac8 <FLASH_ProgramWord+0xb4>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000ab6:	2002      	movs	r0, #2
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 8000ab8:	2c01      	cmp	r4, #1
 8000aba:	bf08      	it	eq
 8000abc:	2005      	moveq	r0, #5
 8000abe:	e7c9      	b.n	8000a54 <FLASH_ProgramWord+0x40>
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 8000ac0:	3c01      	subs	r4, #1
 8000ac2:	d1f1      	bne.n	8000aa8 <FLASH_ProgramWord+0x94>
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 8000ac4:	2005      	movs	r0, #5
 8000ac6:	e7c5      	b.n	8000a54 <FLASH_ProgramWord+0x40>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000ac8:	68d3      	ldr	r3, [r2, #12]
 8000aca:	06da      	lsls	r2, r3, #27
 8000acc:	d501      	bpl.n	8000ad2 <FLASH_ProgramWord+0xbe>
      {
        flashstatus = FLASH_ERROR_WRP;
 8000ace:	2003      	movs	r0, #3
 8000ad0:	e7f2      	b.n	8000ab8 <FLASH_ProgramWord+0xa4>
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000ad2:	2c01      	cmp	r4, #1
 8000ad4:	d104      	bne.n	8000ae0 <FLASH_ProgramWord+0xcc>
  {
    status = FLASH_TIMEOUT;
 8000ad6:	2005      	movs	r0, #5
 8000ad8:	e7bc      	b.n	8000a54 <FLASH_ProgramWord+0x40>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000ada:	68eb      	ldr	r3, [r5, #12]
 8000adc:	06da      	lsls	r2, r3, #27
 8000ade:	d412      	bmi.n	8000b06 <FLASH_ProgramWord+0xf2>
 
    if(status == FLASH_COMPLETE)
    {
      /* if the previous operation is completed, proceed to program the new second 
      half word */
      tmp = Address + 2;
 8000ae0:	3002      	adds	r0, #2
 8000ae2:	9001      	str	r0, [sp, #4]

      *(__IO uint16_t*) tmp = Data >> 16;
 8000ae4:	9b01      	ldr	r3, [sp, #4]
 8000ae6:	0c09      	lsrs	r1, r1, #16
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000ae8:	4814      	ldr	r0, [pc, #80]	; (8000b3c <FLASH_ProgramWord+0x128>)
    {
      /* if the previous operation is completed, proceed to program the new second 
      half word */
      tmp = Address + 2;

      *(__IO uint16_t*) tmp = Data >> 16;
 8000aea:	8019      	strh	r1, [r3, #0]
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000aec:	68c3      	ldr	r3, [r0, #12]
 8000aee:	07db      	lsls	r3, r3, #31
 8000af0:	d40b      	bmi.n	8000b0a <FLASH_ProgramWord+0xf6>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000af2:	68c3      	ldr	r3, [r0, #12]
 8000af4:	075d      	lsls	r5, r3, #29
 8000af6:	d4ac      	bmi.n	8000a52 <FLASH_ProgramWord+0x3e>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000af8:	68c3      	ldr	r3, [r0, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 8000afa:	f013 0f10 	tst.w	r3, #16
 8000afe:	bf14      	ite	ne
 8000b00:	2003      	movne	r0, #3
 8000b02:	2004      	moveq	r0, #4
 8000b04:	e7a6      	b.n	8000a54 <FLASH_ProgramWord+0x40>
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
      {
        flashstatus = FLASH_ERROR_WRP;
 8000b06:	2003      	movs	r0, #3
 8000b08:	e7a4      	b.n	8000a54 <FLASH_ProgramWord+0x40>
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000b0a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8000b0e:	68c3      	ldr	r3, [r0, #12]
 8000b10:	490a      	ldr	r1, [pc, #40]	; (8000b3c <FLASH_ProgramWord+0x128>)
 8000b12:	07dc      	lsls	r4, r3, #31
 8000b14:	d407      	bmi.n	8000b26 <FLASH_ProgramWord+0x112>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000b16:	68cb      	ldr	r3, [r1, #12]
 8000b18:	075b      	lsls	r3, r3, #29
 8000b1a:	d507      	bpl.n	8000b2c <FLASH_ProgramWord+0x118>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000b1c:	2002      	movs	r0, #2
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 8000b1e:	2a01      	cmp	r2, #1
 8000b20:	bf08      	it	eq
 8000b22:	2005      	moveq	r0, #5
 8000b24:	e796      	b.n	8000a54 <FLASH_ProgramWord+0x40>
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 8000b26:	3a01      	subs	r2, #1
 8000b28:	d1f1      	bne.n	8000b0e <FLASH_ProgramWord+0xfa>
 8000b2a:	e7cb      	b.n	8000ac4 <FLASH_ProgramWord+0xb0>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000b2c:	68cb      	ldr	r3, [r1, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 8000b2e:	f013 0f10 	tst.w	r3, #16
 8000b32:	bf14      	ite	ne
 8000b34:	2003      	movne	r0, #3
 8000b36:	2004      	moveq	r0, #4
 8000b38:	e7f1      	b.n	8000b1e <FLASH_ProgramWord+0x10a>
 8000b3a:	bf00      	nop
 8000b3c:	40022000 	.word	0x40022000

08000b40 <FLASH_ProgramHalfWord>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
  */
FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
{
 8000b40:	b430      	push	{r4, r5}
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000b42:	4d30      	ldr	r5, [pc, #192]	; (8000c04 <FLASH_ProgramHalfWord+0xc4>)
 8000b44:	68eb      	ldr	r3, [r5, #12]
 8000b46:	07db      	lsls	r3, r3, #31
 8000b48:	d41d      	bmi.n	8000b86 <FLASH_ProgramHalfWord+0x46>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000b4a:	68eb      	ldr	r3, [r5, #12]
 8000b4c:	075c      	lsls	r4, r3, #29
 8000b4e:	d502      	bpl.n	8000b56 <FLASH_ProgramHalfWord+0x16>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000b50:	2002      	movs	r0, #2
  } 
#endif  /* STM32F10X_XL */
  
  /* Return the Program Status */
  return status;
}
 8000b52:	bc30      	pop	{r4, r5}
 8000b54:	4770      	bx	lr
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000b56:	68eb      	ldr	r3, [r5, #12]
 8000b58:	06da      	lsls	r2, r3, #27
 8000b5a:	d430      	bmi.n	8000bbe <FLASH_ProgramHalfWord+0x7e>
  status = FLASH_WaitForLastOperation(ProgramTimeout);
  
  if(status == FLASH_COMPLETE)
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR |= CR_PG_Set;
 8000b5c:	4b29      	ldr	r3, [pc, #164]	; (8000c04 <FLASH_ProgramHalfWord+0xc4>)
 8000b5e:	691a      	ldr	r2, [r3, #16]
 8000b60:	f042 0201 	orr.w	r2, r2, #1
 8000b64:	611a      	str	r2, [r3, #16]
  
    *(__IO uint16_t*)Address = Data;
 8000b66:	8001      	strh	r1, [r0, #0]
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000b68:	68da      	ldr	r2, [r3, #12]
 8000b6a:	07d2      	lsls	r2, r2, #31
 8000b6c:	d429      	bmi.n	8000bc2 <FLASH_ProgramHalfWord+0x82>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000b6e:	68da      	ldr	r2, [r3, #12]
 8000b70:	0755      	lsls	r5, r2, #29
 8000b72:	d540      	bpl.n	8000bf6 <FLASH_ProgramHalfWord+0xb6>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000b74:	2002      	movs	r0, #2
    *(__IO uint16_t*)Address = Data;
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
    
    /* Disable the PG Bit */
    FLASH->CR &= CR_PG_Reset;
 8000b76:	f641 73fe 	movw	r3, #8190	; 0x1ffe
  } 
#endif  /* STM32F10X_XL */
  
  /* Return the Program Status */
  return status;
}
 8000b7a:	bc30      	pop	{r4, r5}
    *(__IO uint16_t*)Address = Data;
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
    
    /* Disable the PG Bit */
    FLASH->CR &= CR_PG_Reset;
 8000b7c:	4a21      	ldr	r2, [pc, #132]	; (8000c04 <FLASH_ProgramHalfWord+0xc4>)
 8000b7e:	6911      	ldr	r1, [r2, #16]
 8000b80:	400b      	ands	r3, r1
 8000b82:	6113      	str	r3, [r2, #16]
  } 
#endif  /* STM32F10X_XL */
  
  /* Return the Program Status */
  return status;
}
 8000b84:	4770      	bx	lr
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000b86:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8000b8a:	68eb      	ldr	r3, [r5, #12]
 8000b8c:	4c1d      	ldr	r4, [pc, #116]	; (8000c04 <FLASH_ProgramHalfWord+0xc4>)
 8000b8e:	07db      	lsls	r3, r3, #31
 8000b90:	d408      	bmi.n	8000ba4 <FLASH_ProgramHalfWord+0x64>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000b92:	68e3      	ldr	r3, [r4, #12]
 8000b94:	075d      	lsls	r5, r3, #29
 8000b96:	d509      	bpl.n	8000bac <FLASH_ProgramHalfWord+0x6c>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000b98:	2002      	movs	r0, #2
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 8000b9a:	2a01      	cmp	r2, #1
 8000b9c:	bf08      	it	eq
 8000b9e:	2005      	moveq	r0, #5
  } 
#endif  /* STM32F10X_XL */
  
  /* Return the Program Status */
  return status;
}
 8000ba0:	bc30      	pop	{r4, r5}
 8000ba2:	4770      	bx	lr
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 8000ba4:	3a01      	subs	r2, #1
 8000ba6:	d1f0      	bne.n	8000b8a <FLASH_ProgramHalfWord+0x4a>
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 8000ba8:	2005      	movs	r0, #5
 8000baa:	e7d2      	b.n	8000b52 <FLASH_ProgramHalfWord+0x12>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000bac:	68e3      	ldr	r3, [r4, #12]
 8000bae:	06dc      	lsls	r4, r3, #27
 8000bb0:	d501      	bpl.n	8000bb6 <FLASH_ProgramHalfWord+0x76>
      {
        flashstatus = FLASH_ERROR_WRP;
 8000bb2:	2003      	movs	r0, #3
 8000bb4:	e7f1      	b.n	8000b9a <FLASH_ProgramHalfWord+0x5a>
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000bb6:	2a01      	cmp	r2, #1
 8000bb8:	d1d0      	bne.n	8000b5c <FLASH_ProgramHalfWord+0x1c>
  {
    status = FLASH_TIMEOUT;
 8000bba:	2005      	movs	r0, #5
 8000bbc:	e7c9      	b.n	8000b52 <FLASH_ProgramHalfWord+0x12>
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
      {
        flashstatus = FLASH_ERROR_WRP;
 8000bbe:	2003      	movs	r0, #3
 8000bc0:	e7c7      	b.n	8000b52 <FLASH_ProgramHalfWord+0x12>
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000bc2:	4618      	mov	r0, r3
 8000bc4:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8000bc8:	68c3      	ldr	r3, [r0, #12]
 8000bca:	4a0e      	ldr	r2, [pc, #56]	; (8000c04 <FLASH_ProgramHalfWord+0xc4>)
 8000bcc:	07dc      	lsls	r4, r3, #31
 8000bce:	d407      	bmi.n	8000be0 <FLASH_ProgramHalfWord+0xa0>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000bd0:	68d3      	ldr	r3, [r2, #12]
 8000bd2:	075b      	lsls	r3, r3, #29
 8000bd4:	d508      	bpl.n	8000be8 <FLASH_ProgramHalfWord+0xa8>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000bd6:	2002      	movs	r0, #2
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 8000bd8:	2901      	cmp	r1, #1
 8000bda:	bf08      	it	eq
 8000bdc:	2005      	moveq	r0, #5
 8000bde:	e7ca      	b.n	8000b76 <FLASH_ProgramHalfWord+0x36>
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 8000be0:	3901      	subs	r1, #1
 8000be2:	d1f1      	bne.n	8000bc8 <FLASH_ProgramHalfWord+0x88>
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 8000be4:	2005      	movs	r0, #5
 8000be6:	e7c6      	b.n	8000b76 <FLASH_ProgramHalfWord+0x36>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000be8:	68d3      	ldr	r3, [r2, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 8000bea:	f013 0f10 	tst.w	r3, #16
 8000bee:	bf14      	ite	ne
 8000bf0:	2003      	movne	r0, #3
 8000bf2:	2004      	moveq	r0, #4
 8000bf4:	e7f0      	b.n	8000bd8 <FLASH_ProgramHalfWord+0x98>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000bf6:	68db      	ldr	r3, [r3, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 8000bf8:	f013 0f10 	tst.w	r3, #16
 8000bfc:	bf14      	ite	ne
 8000bfe:	2003      	movne	r0, #3
 8000c00:	2004      	moveq	r0, #4
 8000c02:	e7b8      	b.n	8000b76 <FLASH_ProgramHalfWord+0x36>
 8000c04:	40022000 	.word	0x40022000

08000c08 <FLASH_ProgramOptionByteData>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
  */
FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
{
 8000c08:	b430      	push	{r4, r5}
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000c0a:	4d30      	ldr	r5, [pc, #192]	; (8000ccc <FLASH_ProgramOptionByteData+0xc4>)
 8000c0c:	68eb      	ldr	r3, [r5, #12]
 8000c0e:	07db      	lsls	r3, r3, #31
 8000c10:	d421      	bmi.n	8000c56 <FLASH_ProgramOptionByteData+0x4e>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000c12:	68eb      	ldr	r3, [r5, #12]
 8000c14:	075c      	lsls	r4, r3, #29
 8000c16:	d502      	bpl.n	8000c1e <FLASH_ProgramOptionByteData+0x16>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000c18:	2002      	movs	r0, #2
      FLASH->CR &= CR_OPTPG_Reset;
    }
  }
  /* Return the Option Byte Data Program Status */
  return status;
}
 8000c1a:	bc30      	pop	{r4, r5}
 8000c1c:	4770      	bx	lr
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000c1e:	68eb      	ldr	r3, [r5, #12]
 8000c20:	06da      	lsls	r2, r3, #27
 8000c22:	d432      	bmi.n	8000c8a <FLASH_ProgramOptionByteData+0x82>
  status = FLASH_WaitForLastOperation(ProgramTimeout);

  if(status == FLASH_COMPLETE)
  {
    /* Authorize the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 8000c24:	4b29      	ldr	r3, [pc, #164]	; (8000ccc <FLASH_ProgramOptionByteData+0xc4>)
    FLASH->OPTKEYR = FLASH_KEY2;
 8000c26:	4a2a      	ldr	r2, [pc, #168]	; (8000cd0 <FLASH_ProgramOptionByteData+0xc8>)
  status = FLASH_WaitForLastOperation(ProgramTimeout);

  if(status == FLASH_COMPLETE)
  {
    /* Authorize the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 8000c28:	4c2a      	ldr	r4, [pc, #168]	; (8000cd4 <FLASH_ProgramOptionByteData+0xcc>)
    FLASH->OPTKEYR = FLASH_KEY2;
    /* Enables the Option Bytes Programming operation */
    FLASH->CR |= CR_OPTPG_Set; 
    *(__IO uint16_t*)Address = Data;
 8000c2a:	b289      	uxth	r1, r1
  status = FLASH_WaitForLastOperation(ProgramTimeout);

  if(status == FLASH_COMPLETE)
  {
    /* Authorize the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 8000c2c:	609c      	str	r4, [r3, #8]
    FLASH->OPTKEYR = FLASH_KEY2;
 8000c2e:	609a      	str	r2, [r3, #8]
    /* Enables the Option Bytes Programming operation */
    FLASH->CR |= CR_OPTPG_Set; 
 8000c30:	691a      	ldr	r2, [r3, #16]
 8000c32:	f042 0210 	orr.w	r2, r2, #16
 8000c36:	611a      	str	r2, [r3, #16]
    *(__IO uint16_t*)Address = Data;
 8000c38:	8001      	strh	r1, [r0, #0]
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000c3a:	68da      	ldr	r2, [r3, #12]
 8000c3c:	07d2      	lsls	r2, r2, #31
 8000c3e:	d426      	bmi.n	8000c8e <FLASH_ProgramOptionByteData+0x86>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000c40:	68da      	ldr	r2, [r3, #12]
 8000c42:	0755      	lsls	r5, r2, #29
 8000c44:	d53b      	bpl.n	8000cbe <FLASH_ProgramOptionByteData+0xb6>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000c46:	2002      	movs	r0, #2
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
    if(status != FLASH_TIMEOUT)
    {
      /* if the program operation is completed, disable the OPTPG Bit */
      FLASH->CR &= CR_OPTPG_Reset;
 8000c48:	f641 73ef 	movw	r3, #8175	; 0x1fef
 8000c4c:	4a1f      	ldr	r2, [pc, #124]	; (8000ccc <FLASH_ProgramOptionByteData+0xc4>)
 8000c4e:	6911      	ldr	r1, [r2, #16]
 8000c50:	400b      	ands	r3, r1
 8000c52:	6113      	str	r3, [r2, #16]
 8000c54:	e7e1      	b.n	8000c1a <FLASH_ProgramOptionByteData+0x12>
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000c56:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8000c5a:	68eb      	ldr	r3, [r5, #12]
 8000c5c:	4c1b      	ldr	r4, [pc, #108]	; (8000ccc <FLASH_ProgramOptionByteData+0xc4>)
 8000c5e:	07db      	lsls	r3, r3, #31
 8000c60:	d408      	bmi.n	8000c74 <FLASH_ProgramOptionByteData+0x6c>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000c62:	68e3      	ldr	r3, [r4, #12]
 8000c64:	075d      	lsls	r5, r3, #29
 8000c66:	d508      	bpl.n	8000c7a <FLASH_ProgramOptionByteData+0x72>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000c68:	2002      	movs	r0, #2
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000c6a:	2a01      	cmp	r2, #1
 8000c6c:	d1d5      	bne.n	8000c1a <FLASH_ProgramOptionByteData+0x12>
      FLASH->CR &= CR_OPTPG_Reset;
    }
  }
  /* Return the Option Byte Data Program Status */
  return status;
}
 8000c6e:	bc30      	pop	{r4, r5}
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 8000c70:	2005      	movs	r0, #5
      FLASH->CR &= CR_OPTPG_Reset;
    }
  }
  /* Return the Option Byte Data Program Status */
  return status;
}
 8000c72:	4770      	bx	lr
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 8000c74:	3a01      	subs	r2, #1
 8000c76:	d1f0      	bne.n	8000c5a <FLASH_ProgramOptionByteData+0x52>
 8000c78:	e7f9      	b.n	8000c6e <FLASH_ProgramOptionByteData+0x66>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000c7a:	68e3      	ldr	r3, [r4, #12]
 8000c7c:	06dc      	lsls	r4, r3, #27
 8000c7e:	d501      	bpl.n	8000c84 <FLASH_ProgramOptionByteData+0x7c>
      {
        flashstatus = FLASH_ERROR_WRP;
 8000c80:	2003      	movs	r0, #3
 8000c82:	e7f2      	b.n	8000c6a <FLASH_ProgramOptionByteData+0x62>
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000c84:	2a01      	cmp	r2, #1
 8000c86:	d0f2      	beq.n	8000c6e <FLASH_ProgramOptionByteData+0x66>
 8000c88:	e7cc      	b.n	8000c24 <FLASH_ProgramOptionByteData+0x1c>
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
      {
        flashstatus = FLASH_ERROR_WRP;
 8000c8a:	2003      	movs	r0, #3
 8000c8c:	e7c5      	b.n	8000c1a <FLASH_ProgramOptionByteData+0x12>
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000c8e:	4618      	mov	r0, r3
 8000c90:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8000c94:	68c3      	ldr	r3, [r0, #12]
 8000c96:	4a0d      	ldr	r2, [pc, #52]	; (8000ccc <FLASH_ProgramOptionByteData+0xc4>)
 8000c98:	07dc      	lsls	r4, r3, #31
 8000c9a:	d406      	bmi.n	8000caa <FLASH_ProgramOptionByteData+0xa2>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000c9c:	68d3      	ldr	r3, [r2, #12]
 8000c9e:	075b      	lsls	r3, r3, #29
 8000ca0:	d506      	bpl.n	8000cb0 <FLASH_ProgramOptionByteData+0xa8>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000ca2:	2002      	movs	r0, #2
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000ca4:	2901      	cmp	r1, #1
 8000ca6:	d0e2      	beq.n	8000c6e <FLASH_ProgramOptionByteData+0x66>
 8000ca8:	e7ce      	b.n	8000c48 <FLASH_ProgramOptionByteData+0x40>
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 8000caa:	3901      	subs	r1, #1
 8000cac:	d1f2      	bne.n	8000c94 <FLASH_ProgramOptionByteData+0x8c>
 8000cae:	e7de      	b.n	8000c6e <FLASH_ProgramOptionByteData+0x66>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000cb0:	68d3      	ldr	r3, [r2, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 8000cb2:	f013 0f10 	tst.w	r3, #16
 8000cb6:	bf14      	ite	ne
 8000cb8:	2003      	movne	r0, #3
 8000cba:	2004      	moveq	r0, #4
 8000cbc:	e7f2      	b.n	8000ca4 <FLASH_ProgramOptionByteData+0x9c>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000cbe:	68db      	ldr	r3, [r3, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 8000cc0:	f013 0f10 	tst.w	r3, #16
 8000cc4:	bf14      	ite	ne
 8000cc6:	2003      	movne	r0, #3
 8000cc8:	2004      	moveq	r0, #4
 8000cca:	e7bd      	b.n	8000c48 <FLASH_ProgramOptionByteData+0x40>
 8000ccc:	40022000 	.word	0x40022000
 8000cd0:	cdef89ab 	.word	0xcdef89ab
 8000cd4:	45670123 	.word	0x45670123

08000cd8 <FLASH_EnableWriteProtection>:
  *     @arg FLASH_WRProt_AllPages
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
{
 8000cd8:	b430      	push	{r4, r5}
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000cda:	4c71      	ldr	r4, [pc, #452]	; (8000ea0 <FLASH_EnableWriteProtection+0x1c8>)
 8000cdc:	68e3      	ldr	r3, [r4, #12]
 8000cde:	07dd      	lsls	r5, r3, #31
 8000ce0:	d42b      	bmi.n	8000d3a <FLASH_EnableWriteProtection+0x62>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000ce2:	68e3      	ldr	r3, [r4, #12]
 8000ce4:	0759      	lsls	r1, r3, #29
 8000ce6:	d502      	bpl.n	8000cee <FLASH_EnableWriteProtection+0x16>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000ce8:	2002      	movs	r0, #2
      FLASH->CR &= CR_OPTPG_Reset;
    }
  } 
  /* Return the write protection operation Status */
  return status;       
}
 8000cea:	bc30      	pop	{r4, r5}
 8000cec:	4770      	bx	lr
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000cee:	68e3      	ldr	r3, [r4, #12]
 8000cf0:	06da      	lsls	r2, r3, #27
 8000cf2:	d504      	bpl.n	8000cfe <FLASH_EnableWriteProtection+0x26>
      FLASH->CR &= CR_OPTPG_Reset;
    }
  } 
  /* Return the write protection operation Status */
  return status;       
}
 8000cf4:	bc30      	pop	{r4, r5}
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
      {
        flashstatus = FLASH_ERROR_WRP;
 8000cf6:	2003      	movs	r0, #3
      FLASH->CR &= CR_OPTPG_Reset;
    }
  } 
  /* Return the write protection operation Status */
  return status;       
}
 8000cf8:	4770      	bx	lr
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000cfa:	2a01      	cmp	r2, #1
 8000cfc:	d029      	beq.n	8000d52 <FLASH_EnableWriteProtection+0x7a>
  FLASH_Status status = FLASH_COMPLETE;
  
  /* Check the parameters */
  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
  
  FLASH_Pages = (uint32_t)(~FLASH_Pages);
 8000cfe:	43c5      	mvns	r5, r0
  status = FLASH_WaitForLastOperation(ProgramTimeout);
  
  if(status == FLASH_COMPLETE)
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 8000d00:	4b67      	ldr	r3, [pc, #412]	; (8000ea0 <FLASH_EnableWriteProtection+0x1c8>)
 8000d02:	4968      	ldr	r1, [pc, #416]	; (8000ea4 <FLASH_EnableWriteProtection+0x1cc>)
    FLASH->OPTKEYR = FLASH_KEY2;
 8000d04:	4a68      	ldr	r2, [pc, #416]	; (8000ea8 <FLASH_EnableWriteProtection+0x1d0>)
  status = FLASH_WaitForLastOperation(ProgramTimeout);
  
  if(status == FLASH_COMPLETE)
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 8000d06:	6099      	str	r1, [r3, #8]
    FLASH->OPTKEYR = FLASH_KEY2;
 8000d08:	609a      	str	r2, [r3, #8]
    FLASH->CR |= CR_OPTPG_Set;
 8000d0a:	691a      	ldr	r2, [r3, #16]
  
  /* Check the parameters */
  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
  
  FLASH_Pages = (uint32_t)(~FLASH_Pages);
  WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
 8000d0c:	b2e9      	uxtb	r1, r5
  if(status == FLASH_COMPLETE)
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
    FLASH->OPTKEYR = FLASH_KEY2;
    FLASH->CR |= CR_OPTPG_Set;
 8000d0e:	f042 0210 	orr.w	r2, r2, #16
    if(WRP0_Data != 0xFF)
 8000d12:	29ff      	cmp	r1, #255	; 0xff
  if(status == FLASH_COMPLETE)
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
    FLASH->OPTKEYR = FLASH_KEY2;
    FLASH->CR |= CR_OPTPG_Set;
 8000d14:	611a      	str	r2, [r3, #16]
    if(WRP0_Data != 0xFF)
 8000d16:	d02a      	beq.n	8000d6e <FLASH_EnableWriteProtection+0x96>
    {
      OB->WRP0 = WRP0_Data;
 8000d18:	4a64      	ldr	r2, [pc, #400]	; (8000eac <FLASH_EnableWriteProtection+0x1d4>)
 8000d1a:	8111      	strh	r1, [r2, #8]
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000d1c:	68da      	ldr	r2, [r3, #12]
 8000d1e:	07d1      	lsls	r1, r2, #31
 8000d20:	d453      	bmi.n	8000dca <FLASH_EnableWriteProtection+0xf2>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000d22:	68da      	ldr	r2, [r3, #12]
 8000d24:	0752      	lsls	r2, r2, #29
 8000d26:	d51f      	bpl.n	8000d68 <FLASH_EnableWriteProtection+0x90>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000d28:	2002      	movs	r0, #2
    }
          
    if(status != FLASH_TIMEOUT)
    {
      /* if the program operation is completed, disable the OPTPG Bit */
      FLASH->CR &= CR_OPTPG_Reset;
 8000d2a:	f641 73ef 	movw	r3, #8175	; 0x1fef
    }
  } 
  /* Return the write protection operation Status */
  return status;       
}
 8000d2e:	bc30      	pop	{r4, r5}
    }
          
    if(status != FLASH_TIMEOUT)
    {
      /* if the program operation is completed, disable the OPTPG Bit */
      FLASH->CR &= CR_OPTPG_Reset;
 8000d30:	4a5b      	ldr	r2, [pc, #364]	; (8000ea0 <FLASH_EnableWriteProtection+0x1c8>)
 8000d32:	6911      	ldr	r1, [r2, #16]
 8000d34:	400b      	ands	r3, r1
 8000d36:	6113      	str	r3, [r2, #16]
    }
  } 
  /* Return the write protection operation Status */
  return status;       
}
 8000d38:	4770      	bx	lr
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000d3a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8000d3e:	68e3      	ldr	r3, [r4, #12]
 8000d40:	4957      	ldr	r1, [pc, #348]	; (8000ea0 <FLASH_EnableWriteProtection+0x1c8>)
 8000d42:	07db      	lsls	r3, r3, #31
 8000d44:	d408      	bmi.n	8000d58 <FLASH_EnableWriteProtection+0x80>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000d46:	68cb      	ldr	r3, [r1, #12]
 8000d48:	075d      	lsls	r5, r3, #29
 8000d4a:	d508      	bpl.n	8000d5e <FLASH_EnableWriteProtection+0x86>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000d4c:	2002      	movs	r0, #2
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000d4e:	2a01      	cmp	r2, #1
 8000d50:	d1cb      	bne.n	8000cea <FLASH_EnableWriteProtection+0x12>
      FLASH->CR &= CR_OPTPG_Reset;
    }
  } 
  /* Return the write protection operation Status */
  return status;       
}
 8000d52:	bc30      	pop	{r4, r5}
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000d54:	2005      	movs	r0, #5
      FLASH->CR &= CR_OPTPG_Reset;
    }
  } 
  /* Return the write protection operation Status */
  return status;       
}
 8000d56:	4770      	bx	lr
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 8000d58:	3a01      	subs	r2, #1
 8000d5a:	d1f0      	bne.n	8000d3e <FLASH_EnableWriteProtection+0x66>
 8000d5c:	e7f9      	b.n	8000d52 <FLASH_EnableWriteProtection+0x7a>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000d5e:	68cb      	ldr	r3, [r1, #12]
 8000d60:	06dc      	lsls	r4, r3, #27
 8000d62:	d5ca      	bpl.n	8000cfa <FLASH_EnableWriteProtection+0x22>
      {
        flashstatus = FLASH_ERROR_WRP;
 8000d64:	2003      	movs	r0, #3
 8000d66:	e7f2      	b.n	8000d4e <FLASH_EnableWriteProtection+0x76>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000d68:	68db      	ldr	r3, [r3, #12]
 8000d6a:	06dc      	lsls	r4, r3, #27
 8000d6c:	d421      	bmi.n	8000db2 <FLASH_EnableWriteProtection+0xda>
  /* Check the parameters */
  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
  
  FLASH_Pages = (uint32_t)(~FLASH_Pages);
  WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
  WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
 8000d6e:	f3c5 2307 	ubfx	r3, r5, #8, #8
      OB->WRP0 = WRP0_Data;
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }
    if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
 8000d72:	2bff      	cmp	r3, #255	; 0xff
 8000d74:	d00c      	beq.n	8000d90 <FLASH_EnableWriteProtection+0xb8>
    {
      OB->WRP1 = WRP1_Data;
 8000d76:	4a4d      	ldr	r2, [pc, #308]	; (8000eac <FLASH_EnableWriteProtection+0x1d4>)
  /* Check the parameters */
  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
  
  FLASH_Pages = (uint32_t)(~FLASH_Pages);
  WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
  WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
 8000d78:	b29b      	uxth	r3, r3
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000d7a:	4849      	ldr	r0, [pc, #292]	; (8000ea0 <FLASH_EnableWriteProtection+0x1c8>)
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }
    if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
    {
      OB->WRP1 = WRP1_Data;
 8000d7c:	8153      	strh	r3, [r2, #10]
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000d7e:	68c3      	ldr	r3, [r0, #12]
 8000d80:	07dc      	lsls	r4, r3, #31
 8000d82:	d46a      	bmi.n	8000e5a <FLASH_EnableWriteProtection+0x182>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000d84:	68c3      	ldr	r3, [r0, #12]
 8000d86:	0759      	lsls	r1, r3, #29
 8000d88:	d4ce      	bmi.n	8000d28 <FLASH_EnableWriteProtection+0x50>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000d8a:	68c3      	ldr	r3, [r0, #12]
 8000d8c:	06da      	lsls	r2, r3, #27
 8000d8e:	d410      	bmi.n	8000db2 <FLASH_EnableWriteProtection+0xda>
  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
  
  FLASH_Pages = (uint32_t)(~FLASH_Pages);
  WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
  WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
  WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
 8000d90:	f3c5 4307 	ubfx	r3, r5, #16, #8
      OB->WRP1 = WRP1_Data;
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }
    if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
 8000d94:	2bff      	cmp	r3, #255	; 0xff
 8000d96:	d013      	beq.n	8000dc0 <FLASH_EnableWriteProtection+0xe8>
    {
      OB->WRP2 = WRP2_Data;
 8000d98:	4a44      	ldr	r2, [pc, #272]	; (8000eac <FLASH_EnableWriteProtection+0x1d4>)
  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
  
  FLASH_Pages = (uint32_t)(~FLASH_Pages);
  WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
  WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
  WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
 8000d9a:	b29b      	uxth	r3, r3
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000d9c:	4840      	ldr	r0, [pc, #256]	; (8000ea0 <FLASH_EnableWriteProtection+0x1c8>)
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }
    if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
    {
      OB->WRP2 = WRP2_Data;
 8000d9e:	8193      	strh	r3, [r2, #12]
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000da0:	68c3      	ldr	r3, [r0, #12]
 8000da2:	07d9      	lsls	r1, r3, #31
 8000da4:	d44b      	bmi.n	8000e3e <FLASH_EnableWriteProtection+0x166>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000da6:	68c3      	ldr	r3, [r0, #12]
 8000da8:	075a      	lsls	r2, r3, #29
 8000daa:	d4bd      	bmi.n	8000d28 <FLASH_EnableWriteProtection+0x50>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000dac:	68c3      	ldr	r3, [r0, #12]
 8000dae:	06db      	lsls	r3, r3, #27
 8000db0:	d506      	bpl.n	8000dc0 <FLASH_EnableWriteProtection+0xe8>
      {
        flashstatus = FLASH_ERROR_WRP;
 8000db2:	2003      	movs	r0, #3
 8000db4:	e7b9      	b.n	8000d2a <FLASH_EnableWriteProtection+0x52>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000db6:	68d3      	ldr	r3, [r2, #12]
 8000db8:	06da      	lsls	r2, r3, #27
 8000dba:	d467      	bmi.n	8000e8c <FLASH_EnableWriteProtection+0x1b4>
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000dbc:	2901      	cmp	r1, #1
 8000dbe:	d0c8      	beq.n	8000d52 <FLASH_EnableWriteProtection+0x7a>
  
  FLASH_Pages = (uint32_t)(~FLASH_Pages);
  WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
  WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
  WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
  WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
 8000dc0:	0e28      	lsrs	r0, r5, #24
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }
    
    if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
 8000dc2:	28ff      	cmp	r0, #255	; 0xff
 8000dc4:	d11d      	bne.n	8000e02 <FLASH_EnableWriteProtection+0x12a>
 8000dc6:	2004      	movs	r0, #4
 8000dc8:	e7af      	b.n	8000d2a <FLASH_EnableWriteProtection+0x52>
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000dca:	f44f 5400 	mov.w	r4, #8192	; 0x2000
 8000dce:	68da      	ldr	r2, [r3, #12]
 8000dd0:	4933      	ldr	r1, [pc, #204]	; (8000ea0 <FLASH_EnableWriteProtection+0x1c8>)
 8000dd2:	07d0      	lsls	r0, r2, #31
 8000dd4:	d40a      	bmi.n	8000dec <FLASH_EnableWriteProtection+0x114>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000dd6:	68cb      	ldr	r3, [r1, #12]
 8000dd8:	075a      	lsls	r2, r3, #29
 8000dda:	d50a      	bpl.n	8000df2 <FLASH_EnableWriteProtection+0x11a>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000ddc:	2002      	movs	r0, #2
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000dde:	2c01      	cmp	r4, #1
 8000de0:	d0b7      	beq.n	8000d52 <FLASH_EnableWriteProtection+0x7a>
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }
    
    if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
 8000de2:	2804      	cmp	r0, #4
 8000de4:	d0ec      	beq.n	8000dc0 <FLASH_EnableWriteProtection+0xe8>
     
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }
          
    if(status != FLASH_TIMEOUT)
 8000de6:	2805      	cmp	r0, #5
 8000de8:	d19f      	bne.n	8000d2a <FLASH_EnableWriteProtection+0x52>
 8000dea:	e7b2      	b.n	8000d52 <FLASH_EnableWriteProtection+0x7a>
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 8000dec:	3c01      	subs	r4, #1
 8000dee:	d1ee      	bne.n	8000dce <FLASH_EnableWriteProtection+0xf6>
 8000df0:	e7af      	b.n	8000d52 <FLASH_EnableWriteProtection+0x7a>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000df2:	68cb      	ldr	r3, [r1, #12]
 8000df4:	06db      	lsls	r3, r3, #27
 8000df6:	d501      	bpl.n	8000dfc <FLASH_EnableWriteProtection+0x124>
      {
        flashstatus = FLASH_ERROR_WRP;
 8000df8:	2003      	movs	r0, #3
 8000dfa:	e7f0      	b.n	8000dde <FLASH_EnableWriteProtection+0x106>
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000dfc:	2c01      	cmp	r4, #1
 8000dfe:	d0a8      	beq.n	8000d52 <FLASH_EnableWriteProtection+0x7a>
 8000e00:	e7b5      	b.n	8000d6e <FLASH_EnableWriteProtection+0x96>
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }
    
    if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
    {
      OB->WRP3 = WRP3_Data;
 8000e02:	4b2a      	ldr	r3, [pc, #168]	; (8000eac <FLASH_EnableWriteProtection+0x1d4>)
  
  FLASH_Pages = (uint32_t)(~FLASH_Pages);
  WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
  WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
  WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
  WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
 8000e04:	b285      	uxth	r5, r0
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000e06:	4826      	ldr	r0, [pc, #152]	; (8000ea0 <FLASH_EnableWriteProtection+0x1c8>)
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }
    
    if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
    {
      OB->WRP3 = WRP3_Data;
 8000e08:	81dd      	strh	r5, [r3, #14]
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000e0a:	68c3      	ldr	r3, [r0, #12]
 8000e0c:	07db      	lsls	r3, r3, #31
 8000e0e:	d409      	bmi.n	8000e24 <FLASH_EnableWriteProtection+0x14c>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000e10:	68c3      	ldr	r3, [r0, #12]
 8000e12:	075d      	lsls	r5, r3, #29
 8000e14:	d488      	bmi.n	8000d28 <FLASH_EnableWriteProtection+0x50>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000e16:	68c3      	ldr	r3, [r0, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 8000e18:	f013 0f10 	tst.w	r3, #16
 8000e1c:	bf14      	ite	ne
 8000e1e:	2003      	movne	r0, #3
 8000e20:	2004      	moveq	r0, #4
 8000e22:	e782      	b.n	8000d2a <FLASH_EnableWriteProtection+0x52>
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000e24:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8000e28:	68c3      	ldr	r3, [r0, #12]
 8000e2a:	4a1d      	ldr	r2, [pc, #116]	; (8000ea0 <FLASH_EnableWriteProtection+0x1c8>)
 8000e2c:	07dc      	lsls	r4, r3, #31
 8000e2e:	d424      	bmi.n	8000e7a <FLASH_EnableWriteProtection+0x1a2>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000e30:	68d3      	ldr	r3, [r2, #12]
 8000e32:	075b      	lsls	r3, r3, #29
 8000e34:	d52c      	bpl.n	8000e90 <FLASH_EnableWriteProtection+0x1b8>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000e36:	2002      	movs	r0, #2
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000e38:	2901      	cmp	r1, #1
 8000e3a:	d08a      	beq.n	8000d52 <FLASH_EnableWriteProtection+0x7a>
 8000e3c:	e775      	b.n	8000d2a <FLASH_EnableWriteProtection+0x52>
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000e3e:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8000e42:	68c3      	ldr	r3, [r0, #12]
 8000e44:	4a16      	ldr	r2, [pc, #88]	; (8000ea0 <FLASH_EnableWriteProtection+0x1c8>)
 8000e46:	07dc      	lsls	r4, r3, #31
 8000e48:	d41a      	bmi.n	8000e80 <FLASH_EnableWriteProtection+0x1a8>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000e4a:	68d3      	ldr	r3, [r2, #12]
 8000e4c:	0758      	lsls	r0, r3, #29
 8000e4e:	d5b2      	bpl.n	8000db6 <FLASH_EnableWriteProtection+0xde>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000e50:	2002      	movs	r0, #2
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000e52:	2901      	cmp	r1, #1
 8000e54:	f43f af7d 	beq.w	8000d52 <FLASH_EnableWriteProtection+0x7a>
 8000e58:	e7c5      	b.n	8000de6 <FLASH_EnableWriteProtection+0x10e>
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000e5a:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8000e5e:	68c3      	ldr	r3, [r0, #12]
 8000e60:	4a0f      	ldr	r2, [pc, #60]	; (8000ea0 <FLASH_EnableWriteProtection+0x1c8>)
 8000e62:	07db      	lsls	r3, r3, #31
 8000e64:	d40f      	bmi.n	8000e86 <FLASH_EnableWriteProtection+0x1ae>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000e66:	68d3      	ldr	r3, [r2, #12]
 8000e68:	075c      	lsls	r4, r3, #29
 8000e6a:	d4f1      	bmi.n	8000e50 <FLASH_EnableWriteProtection+0x178>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000e6c:	68d3      	ldr	r3, [r2, #12]
 8000e6e:	06d8      	lsls	r0, r3, #27
 8000e70:	d40c      	bmi.n	8000e8c <FLASH_EnableWriteProtection+0x1b4>
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000e72:	2901      	cmp	r1, #1
 8000e74:	f43f af6d 	beq.w	8000d52 <FLASH_EnableWriteProtection+0x7a>
 8000e78:	e78a      	b.n	8000d90 <FLASH_EnableWriteProtection+0xb8>
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 8000e7a:	3901      	subs	r1, #1
 8000e7c:	d1d4      	bne.n	8000e28 <FLASH_EnableWriteProtection+0x150>
 8000e7e:	e768      	b.n	8000d52 <FLASH_EnableWriteProtection+0x7a>
 8000e80:	3901      	subs	r1, #1
 8000e82:	d1de      	bne.n	8000e42 <FLASH_EnableWriteProtection+0x16a>
 8000e84:	e765      	b.n	8000d52 <FLASH_EnableWriteProtection+0x7a>
 8000e86:	3901      	subs	r1, #1
 8000e88:	d1e9      	bne.n	8000e5e <FLASH_EnableWriteProtection+0x186>
 8000e8a:	e762      	b.n	8000d52 <FLASH_EnableWriteProtection+0x7a>
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
      {
        flashstatus = FLASH_ERROR_WRP;
 8000e8c:	2003      	movs	r0, #3
 8000e8e:	e7e0      	b.n	8000e52 <FLASH_EnableWriteProtection+0x17a>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000e90:	68d3      	ldr	r3, [r2, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 8000e92:	f013 0f10 	tst.w	r3, #16
 8000e96:	bf14      	ite	ne
 8000e98:	2003      	movne	r0, #3
 8000e9a:	2004      	moveq	r0, #4
 8000e9c:	e7cc      	b.n	8000e38 <FLASH_EnableWriteProtection+0x160>
 8000e9e:	bf00      	nop
 8000ea0:	40022000 	.word	0x40022000
 8000ea4:	45670123 	.word	0x45670123
 8000ea8:	cdef89ab 	.word	0xcdef89ab
 8000eac:	1ffff800 	.word	0x1ffff800

08000eb0 <FLASH_ReadOutProtection>:
  *   This parameter can be: ENABLE or DISABLE.
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
{
 8000eb0:	b410      	push	{r4}
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000eb2:	4c51      	ldr	r4, [pc, #324]	; (8000ff8 <FLASH_ReadOutProtection+0x148>)
 8000eb4:	68e3      	ldr	r3, [r4, #12]
 8000eb6:	07db      	lsls	r3, r3, #31
 8000eb8:	d426      	bmi.n	8000f08 <FLASH_ReadOutProtection+0x58>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000eba:	68e3      	ldr	r3, [r4, #12]
 8000ebc:	0759      	lsls	r1, r3, #29
 8000ebe:	d503      	bpl.n	8000ec8 <FLASH_ReadOutProtection+0x18>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000ec0:	2002      	movs	r0, #2
      }
    }
  }
  /* Return the protection operation Status */
  return status;       
}
 8000ec2:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000ec6:	4770      	bx	lr
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000ec8:	68e3      	ldr	r3, [r4, #12]
 8000eca:	06da      	lsls	r2, r3, #27
 8000ecc:	d437      	bmi.n	8000f3e <FLASH_ReadOutProtection+0x8e>
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  status = FLASH_WaitForLastOperation(EraseTimeout);
  if(status == FLASH_COMPLETE)
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 8000ece:	4a4a      	ldr	r2, [pc, #296]	; (8000ff8 <FLASH_ReadOutProtection+0x148>)
    FLASH->OPTKEYR = FLASH_KEY2;
 8000ed0:	4b4a      	ldr	r3, [pc, #296]	; (8000ffc <FLASH_ReadOutProtection+0x14c>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  status = FLASH_WaitForLastOperation(EraseTimeout);
  if(status == FLASH_COMPLETE)
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 8000ed2:	494b      	ldr	r1, [pc, #300]	; (8001000 <FLASH_ReadOutProtection+0x150>)
 8000ed4:	6091      	str	r1, [r2, #8]
    FLASH->OPTKEYR = FLASH_KEY2;
 8000ed6:	6093      	str	r3, [r2, #8]
    FLASH->CR |= CR_OPTER_Set;
 8000ed8:	6913      	ldr	r3, [r2, #16]
 8000eda:	f043 0320 	orr.w	r3, r3, #32
 8000ede:	6113      	str	r3, [r2, #16]
    FLASH->CR |= CR_STRT_Set;
 8000ee0:	6913      	ldr	r3, [r2, #16]
 8000ee2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000ee6:	6113      	str	r3, [r2, #16]
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000ee8:	68d3      	ldr	r3, [r2, #12]
 8000eea:	07dc      	lsls	r4, r3, #31
 8000eec:	d429      	bmi.n	8000f42 <FLASH_ReadOutProtection+0x92>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000eee:	68d3      	ldr	r3, [r2, #12]
 8000ef0:	0759      	lsls	r1, r3, #29
 8000ef2:	d55d      	bpl.n	8000fb0 <FLASH_ReadOutProtection+0x100>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000ef4:	2002      	movs	r0, #2
    else 
    {
      if(status != FLASH_TIMEOUT)
      {
        /* Disable the OPTER Bit */
        FLASH->CR &= CR_OPTER_Reset;
 8000ef6:	f641 73df 	movw	r3, #8159	; 0x1fdf
 8000efa:	4a3f      	ldr	r2, [pc, #252]	; (8000ff8 <FLASH_ReadOutProtection+0x148>)
      }
    }
  }
  /* Return the protection operation Status */
  return status;       
}
 8000efc:	f85d 4b04 	ldr.w	r4, [sp], #4
    else 
    {
      if(status != FLASH_TIMEOUT)
      {
        /* Disable the OPTER Bit */
        FLASH->CR &= CR_OPTER_Reset;
 8000f00:	6911      	ldr	r1, [r2, #16]
 8000f02:	400b      	ands	r3, r1
 8000f04:	6113      	str	r3, [r2, #16]
      }
    }
  }
  /* Return the protection operation Status */
  return status;       
}
 8000f06:	4770      	bx	lr
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000f08:	f44f 2230 	mov.w	r2, #720896	; 0xb0000
 8000f0c:	68e3      	ldr	r3, [r4, #12]
 8000f0e:	493a      	ldr	r1, [pc, #232]	; (8000ff8 <FLASH_ReadOutProtection+0x148>)
 8000f10:	07db      	lsls	r3, r3, #31
 8000f12:	d409      	bmi.n	8000f28 <FLASH_ReadOutProtection+0x78>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000f14:	68cb      	ldr	r3, [r1, #12]
 8000f16:	075c      	lsls	r4, r3, #29
 8000f18:	d509      	bpl.n	8000f2e <FLASH_ReadOutProtection+0x7e>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000f1a:	2002      	movs	r0, #2
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000f1c:	2a01      	cmp	r2, #1
 8000f1e:	d1d0      	bne.n	8000ec2 <FLASH_ReadOutProtection+0x12>
  {
    status = FLASH_TIMEOUT;
 8000f20:	2005      	movs	r0, #5
      }
    }
  }
  /* Return the protection operation Status */
  return status;       
}
 8000f22:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000f26:	4770      	bx	lr
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 8000f28:	3a01      	subs	r2, #1
 8000f2a:	d1ef      	bne.n	8000f0c <FLASH_ReadOutProtection+0x5c>
 8000f2c:	e7f8      	b.n	8000f20 <FLASH_ReadOutProtection+0x70>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000f2e:	68cb      	ldr	r3, [r1, #12]
 8000f30:	06db      	lsls	r3, r3, #27
 8000f32:	d501      	bpl.n	8000f38 <FLASH_ReadOutProtection+0x88>
      {
        flashstatus = FLASH_ERROR_WRP;
 8000f34:	2003      	movs	r0, #3
 8000f36:	e7f1      	b.n	8000f1c <FLASH_ReadOutProtection+0x6c>
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000f38:	2a01      	cmp	r2, #1
 8000f3a:	d0f1      	beq.n	8000f20 <FLASH_ReadOutProtection+0x70>
 8000f3c:	e7c7      	b.n	8000ece <FLASH_ReadOutProtection+0x1e>
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
      {
        flashstatus = FLASH_ERROR_WRP;
 8000f3e:	2003      	movs	r0, #3
 8000f40:	e7bf      	b.n	8000ec2 <FLASH_ReadOutProtection+0x12>
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000f42:	f44f 2430 	mov.w	r4, #720896	; 0xb0000
 8000f46:	68d3      	ldr	r3, [r2, #12]
 8000f48:	492b      	ldr	r1, [pc, #172]	; (8000ff8 <FLASH_ReadOutProtection+0x148>)
 8000f4a:	07db      	lsls	r3, r3, #31
 8000f4c:	d406      	bmi.n	8000f5c <FLASH_ReadOutProtection+0xac>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000f4e:	68cb      	ldr	r3, [r1, #12]
 8000f50:	075b      	lsls	r3, r3, #29
 8000f52:	d506      	bpl.n	8000f62 <FLASH_ReadOutProtection+0xb2>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000f54:	2002      	movs	r0, #2
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000f56:	2c01      	cmp	r4, #1
 8000f58:	d0e2      	beq.n	8000f20 <FLASH_ReadOutProtection+0x70>
 8000f5a:	e7cc      	b.n	8000ef6 <FLASH_ReadOutProtection+0x46>
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 8000f5c:	3c01      	subs	r4, #1
 8000f5e:	d1f2      	bne.n	8000f46 <FLASH_ReadOutProtection+0x96>
 8000f60:	e7de      	b.n	8000f20 <FLASH_ReadOutProtection+0x70>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000f62:	68cb      	ldr	r3, [r1, #12]
 8000f64:	06d9      	lsls	r1, r3, #27
 8000f66:	d501      	bpl.n	8000f6c <FLASH_ReadOutProtection+0xbc>
      {
        flashstatus = FLASH_ERROR_WRP;
 8000f68:	2003      	movs	r0, #3
 8000f6a:	e7f4      	b.n	8000f56 <FLASH_ReadOutProtection+0xa6>
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000f6c:	2c01      	cmp	r4, #1
 8000f6e:	d0d7      	beq.n	8000f20 <FLASH_ReadOutProtection+0x70>
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
    if(status == FLASH_COMPLETE)
    {
      /* if the erase operation is completed, disable the OPTER Bit */
      FLASH->CR &= CR_OPTER_Reset;
 8000f70:	f641 72df 	movw	r2, #8159	; 0x1fdf
 8000f74:	4b20      	ldr	r3, [pc, #128]	; (8000ff8 <FLASH_ReadOutProtection+0x148>)
 8000f76:	6919      	ldr	r1, [r3, #16]
 8000f78:	400a      	ands	r2, r1
 8000f7a:	611a      	str	r2, [r3, #16]
      /* Enable the Option Bytes Programming operation */
      FLASH->CR |= CR_OPTPG_Set; 
 8000f7c:	691a      	ldr	r2, [r3, #16]
 8000f7e:	f042 0210 	orr.w	r2, r2, #16
 8000f82:	611a      	str	r2, [r3, #16]
      if(NewState != DISABLE)
      {
        OB->RDP = 0x00;
 8000f84:	4b1f      	ldr	r3, [pc, #124]	; (8001004 <FLASH_ReadOutProtection+0x154>)
    {
      /* if the erase operation is completed, disable the OPTER Bit */
      FLASH->CR &= CR_OPTER_Reset;
      /* Enable the Option Bytes Programming operation */
      FLASH->CR |= CR_OPTPG_Set; 
      if(NewState != DISABLE)
 8000f86:	b980      	cbnz	r0, 8000faa <FLASH_ReadOutProtection+0xfa>
      {
        OB->RDP = 0x00;
      }
      else
      {
        OB->RDP = RDP_Key;  
 8000f88:	22a5      	movs	r2, #165	; 0xa5
 8000f8a:	801a      	strh	r2, [r3, #0]
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000f8c:	481a      	ldr	r0, [pc, #104]	; (8000ff8 <FLASH_ReadOutProtection+0x148>)
 8000f8e:	68c3      	ldr	r3, [r0, #12]
 8000f90:	07da      	lsls	r2, r3, #31
 8000f92:	d412      	bmi.n	8000fba <FLASH_ReadOutProtection+0x10a>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000f94:	68c3      	ldr	r3, [r0, #12]
 8000f96:	075b      	lsls	r3, r3, #29
 8000f98:	d526      	bpl.n	8000fe8 <FLASH_ReadOutProtection+0x138>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000f9a:	2002      	movs	r0, #2
      status = FLASH_WaitForLastOperation(EraseTimeout); 
    
      if(status != FLASH_TIMEOUT)
      {
        /* if the program operation is completed, disable the OPTPG Bit */
        FLASH->CR &= CR_OPTPG_Reset;
 8000f9c:	f641 73ef 	movw	r3, #8175	; 0x1fef
 8000fa0:	4a15      	ldr	r2, [pc, #84]	; (8000ff8 <FLASH_ReadOutProtection+0x148>)
 8000fa2:	6911      	ldr	r1, [r2, #16]
 8000fa4:	400b      	ands	r3, r1
 8000fa6:	6113      	str	r3, [r2, #16]
 8000fa8:	e78b      	b.n	8000ec2 <FLASH_ReadOutProtection+0x12>
      FLASH->CR &= CR_OPTER_Reset;
      /* Enable the Option Bytes Programming operation */
      FLASH->CR |= CR_OPTPG_Set; 
      if(NewState != DISABLE)
      {
        OB->RDP = 0x00;
 8000faa:	2200      	movs	r2, #0
 8000fac:	801a      	strh	r2, [r3, #0]
 8000fae:	e7ed      	b.n	8000f8c <FLASH_ReadOutProtection+0xdc>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000fb0:	68d3      	ldr	r3, [r2, #12]
 8000fb2:	06da      	lsls	r2, r3, #27
 8000fb4:	d5dc      	bpl.n	8000f70 <FLASH_ReadOutProtection+0xc0>
      {
        flashstatus = FLASH_ERROR_WRP;
 8000fb6:	2003      	movs	r0, #3
 8000fb8:	e79d      	b.n	8000ef6 <FLASH_ReadOutProtection+0x46>
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8000fba:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
 8000fbe:	68c3      	ldr	r3, [r0, #12]
 8000fc0:	4a0d      	ldr	r2, [pc, #52]	; (8000ff8 <FLASH_ReadOutProtection+0x148>)
 8000fc2:	07dc      	lsls	r4, r3, #31
 8000fc4:	d406      	bmi.n	8000fd4 <FLASH_ReadOutProtection+0x124>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8000fc6:	68d3      	ldr	r3, [r2, #12]
 8000fc8:	075b      	lsls	r3, r3, #29
 8000fca:	d506      	bpl.n	8000fda <FLASH_ReadOutProtection+0x12a>
    { 
      flashstatus = FLASH_ERROR_PG;
 8000fcc:	2002      	movs	r0, #2
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8000fce:	2901      	cmp	r1, #1
 8000fd0:	d0a6      	beq.n	8000f20 <FLASH_ReadOutProtection+0x70>
 8000fd2:	e7e3      	b.n	8000f9c <FLASH_ReadOutProtection+0xec>
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 8000fd4:	3901      	subs	r1, #1
 8000fd6:	d1f2      	bne.n	8000fbe <FLASH_ReadOutProtection+0x10e>
 8000fd8:	e7a2      	b.n	8000f20 <FLASH_ReadOutProtection+0x70>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000fda:	68d3      	ldr	r3, [r2, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 8000fdc:	f013 0f10 	tst.w	r3, #16
 8000fe0:	bf14      	ite	ne
 8000fe2:	2003      	movne	r0, #3
 8000fe4:	2004      	moveq	r0, #4
 8000fe6:	e7f2      	b.n	8000fce <FLASH_ReadOutProtection+0x11e>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8000fe8:	68c3      	ldr	r3, [r0, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 8000fea:	f013 0f10 	tst.w	r3, #16
 8000fee:	bf14      	ite	ne
 8000ff0:	2003      	movne	r0, #3
 8000ff2:	2004      	moveq	r0, #4
 8000ff4:	e7d2      	b.n	8000f9c <FLASH_ReadOutProtection+0xec>
 8000ff6:	bf00      	nop
 8000ff8:	40022000 	.word	0x40022000
 8000ffc:	cdef89ab 	.word	0xcdef89ab
 8001000:	45670123 	.word	0x45670123
 8001004:	1ffff800 	.word	0x1ffff800

08001008 <FLASH_UserOptionByteConfig>:
  *     @arg OB_STDBY_RST: Reset generated when entering in STANDBY
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG, 
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
{
 8001008:	b470      	push	{r4, r5, r6}
  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));

  /* Authorize the small information block programming */
  FLASH->OPTKEYR = FLASH_KEY1;
  FLASH->OPTKEYR = FLASH_KEY2;
 800100a:	4b32      	ldr	r3, [pc, #200]	; (80010d4 <FLASH_UserOptionByteConfig+0xcc>)
  assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));

  /* Authorize the small information block programming */
  FLASH->OPTKEYR = FLASH_KEY1;
 800100c:	4e32      	ldr	r6, [pc, #200]	; (80010d8 <FLASH_UserOptionByteConfig+0xd0>)
 800100e:	4c33      	ldr	r4, [pc, #204]	; (80010dc <FLASH_UserOptionByteConfig+0xd4>)
 8001010:	60b4      	str	r4, [r6, #8]
  FLASH->OPTKEYR = FLASH_KEY2;
 8001012:	60b3      	str	r3, [r6, #8]
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8001014:	68f3      	ldr	r3, [r6, #12]
 8001016:	07db      	lsls	r3, r3, #31
 8001018:	d421      	bmi.n	800105e <FLASH_UserOptionByteConfig+0x56>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 800101a:	68f3      	ldr	r3, [r6, #12]
 800101c:	075d      	lsls	r5, r3, #29
 800101e:	d502      	bpl.n	8001026 <FLASH_UserOptionByteConfig+0x1e>
    { 
      flashstatus = FLASH_ERROR_PG;
 8001020:	2002      	movs	r0, #2
      FLASH->CR &= CR_OPTPG_Reset;
    }
  }    
  /* Return the Option Byte program Status */
  return status;
}
 8001022:	bc70      	pop	{r4, r5, r6}
 8001024:	4770      	bx	lr
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8001026:	68f3      	ldr	r3, [r6, #12]
 8001028:	06dc      	lsls	r4, r3, #27
 800102a:	d432      	bmi.n	8001092 <FLASH_UserOptionByteConfig+0x8a>
  status = FLASH_WaitForLastOperation(ProgramTimeout);
  
  if(status == FLASH_COMPLETE)
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= CR_OPTPG_Set; 
 800102c:	4b2a      	ldr	r3, [pc, #168]	; (80010d8 <FLASH_UserOptionByteConfig+0xd0>)
 800102e:	f040 00f8 	orr.w	r0, r0, #248	; 0xf8
 8001032:	691c      	ldr	r4, [r3, #16]
 8001034:	4301      	orrs	r1, r0
           
    OB->USER = OB_IWDG | (uint16_t)(OB_STOP | (uint16_t)(OB_STDBY | ((uint16_t)0xF8))); 
 8001036:	482a      	ldr	r0, [pc, #168]	; (80010e0 <FLASH_UserOptionByteConfig+0xd8>)
 8001038:	430a      	orrs	r2, r1
  status = FLASH_WaitForLastOperation(ProgramTimeout);
  
  if(status == FLASH_COMPLETE)
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= CR_OPTPG_Set; 
 800103a:	f044 0110 	orr.w	r1, r4, #16
 800103e:	6119      	str	r1, [r3, #16]
           
    OB->USER = OB_IWDG | (uint16_t)(OB_STOP | (uint16_t)(OB_STDBY | ((uint16_t)0xF8))); 
 8001040:	8042      	strh	r2, [r0, #2]
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8001042:	68da      	ldr	r2, [r3, #12]
 8001044:	07d6      	lsls	r6, r2, #31
 8001046:	d426      	bmi.n	8001096 <FLASH_UserOptionByteConfig+0x8e>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8001048:	68da      	ldr	r2, [r3, #12]
 800104a:	0755      	lsls	r5, r2, #29
 800104c:	d53b      	bpl.n	80010c6 <FLASH_UserOptionByteConfig+0xbe>
    { 
      flashstatus = FLASH_ERROR_PG;
 800104e:	2002      	movs	r0, #2
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
    if(status != FLASH_TIMEOUT)
    {
      /* if the program operation is completed, disable the OPTPG Bit */
      FLASH->CR &= CR_OPTPG_Reset;
 8001050:	f641 73ef 	movw	r3, #8175	; 0x1fef
 8001054:	4a20      	ldr	r2, [pc, #128]	; (80010d8 <FLASH_UserOptionByteConfig+0xd0>)
 8001056:	6911      	ldr	r1, [r2, #16]
 8001058:	400b      	ands	r3, r1
 800105a:	6113      	str	r3, [r2, #16]
 800105c:	e7e1      	b.n	8001022 <FLASH_UserOptionByteConfig+0x1a>
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 800105e:	f44f 5400 	mov.w	r4, #8192	; 0x2000
 8001062:	68f3      	ldr	r3, [r6, #12]
 8001064:	4d1c      	ldr	r5, [pc, #112]	; (80010d8 <FLASH_UserOptionByteConfig+0xd0>)
 8001066:	07db      	lsls	r3, r3, #31
 8001068:	d408      	bmi.n	800107c <FLASH_UserOptionByteConfig+0x74>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 800106a:	68eb      	ldr	r3, [r5, #12]
 800106c:	075e      	lsls	r6, r3, #29
 800106e:	d508      	bpl.n	8001082 <FLASH_UserOptionByteConfig+0x7a>
    { 
      flashstatus = FLASH_ERROR_PG;
 8001070:	2002      	movs	r0, #2
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 8001072:	2c01      	cmp	r4, #1
 8001074:	d1d5      	bne.n	8001022 <FLASH_UserOptionByteConfig+0x1a>
      FLASH->CR &= CR_OPTPG_Reset;
    }
  }    
  /* Return the Option Byte program Status */
  return status;
}
 8001076:	bc70      	pop	{r4, r5, r6}
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 8001078:	2005      	movs	r0, #5
      FLASH->CR &= CR_OPTPG_Reset;
    }
  }    
  /* Return the Option Byte program Status */
  return status;
}
 800107a:	4770      	bx	lr
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 800107c:	3c01      	subs	r4, #1
 800107e:	d1f0      	bne.n	8001062 <FLASH_UserOptionByteConfig+0x5a>
 8001080:	e7f9      	b.n	8001076 <FLASH_UserOptionByteConfig+0x6e>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8001082:	68eb      	ldr	r3, [r5, #12]
 8001084:	06db      	lsls	r3, r3, #27
 8001086:	d501      	bpl.n	800108c <FLASH_UserOptionByteConfig+0x84>
      {
        flashstatus = FLASH_ERROR_WRP;
 8001088:	2003      	movs	r0, #3
 800108a:	e7f2      	b.n	8001072 <FLASH_UserOptionByteConfig+0x6a>
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 800108c:	2c01      	cmp	r4, #1
 800108e:	d0f2      	beq.n	8001076 <FLASH_UserOptionByteConfig+0x6e>
 8001090:	e7cc      	b.n	800102c <FLASH_UserOptionByteConfig+0x24>
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
      {
        flashstatus = FLASH_ERROR_WRP;
 8001092:	2003      	movs	r0, #3
 8001094:	e7c5      	b.n	8001022 <FLASH_UserOptionByteConfig+0x1a>
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8001096:	4618      	mov	r0, r3
 8001098:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 800109c:	68c3      	ldr	r3, [r0, #12]
 800109e:	4a0e      	ldr	r2, [pc, #56]	; (80010d8 <FLASH_UserOptionByteConfig+0xd0>)
 80010a0:	07dc      	lsls	r4, r3, #31
 80010a2:	d406      	bmi.n	80010b2 <FLASH_UserOptionByteConfig+0xaa>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 80010a4:	68d3      	ldr	r3, [r2, #12]
 80010a6:	075b      	lsls	r3, r3, #29
 80010a8:	d506      	bpl.n	80010b8 <FLASH_UserOptionByteConfig+0xb0>
    { 
      flashstatus = FLASH_ERROR_PG;
 80010aa:	2002      	movs	r0, #2
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
 80010ac:	2901      	cmp	r1, #1
 80010ae:	d0e2      	beq.n	8001076 <FLASH_UserOptionByteConfig+0x6e>
 80010b0:	e7ce      	b.n	8001050 <FLASH_UserOptionByteConfig+0x48>
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 80010b2:	3901      	subs	r1, #1
 80010b4:	d1f2      	bne.n	800109c <FLASH_UserOptionByteConfig+0x94>
 80010b6:	e7de      	b.n	8001076 <FLASH_UserOptionByteConfig+0x6e>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 80010b8:	68d3      	ldr	r3, [r2, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 80010ba:	f013 0f10 	tst.w	r3, #16
 80010be:	bf14      	ite	ne
 80010c0:	2003      	movne	r0, #3
 80010c2:	2004      	moveq	r0, #4
 80010c4:	e7f2      	b.n	80010ac <FLASH_UserOptionByteConfig+0xa4>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 80010c6:	68db      	ldr	r3, [r3, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 80010c8:	f013 0f10 	tst.w	r3, #16
 80010cc:	bf14      	ite	ne
 80010ce:	2003      	movne	r0, #3
 80010d0:	2004      	moveq	r0, #4
 80010d2:	e7bd      	b.n	8001050 <FLASH_UserOptionByteConfig+0x48>
 80010d4:	cdef89ab 	.word	0xcdef89ab
 80010d8:	40022000 	.word	0x40022000
 80010dc:	45670123 	.word	0x45670123
 80010e0:	1ffff800 	.word	0x1ffff800

080010e4 <FLASH_GetUserOptionByte>:
  *         and RST_STDBY(Bit2).
  */
uint32_t FLASH_GetUserOptionByte(void)
{
  /* Return the User Option Byte */
  return (uint32_t)(FLASH->OBR >> 2);
 80010e4:	4b01      	ldr	r3, [pc, #4]	; (80010ec <FLASH_GetUserOptionByte+0x8>)
 80010e6:	69d8      	ldr	r0, [r3, #28]
}
 80010e8:	0880      	lsrs	r0, r0, #2
 80010ea:	4770      	bx	lr
 80010ec:	40022000 	.word	0x40022000

080010f0 <FLASH_GetWriteProtectionOptionByte>:
  * @retval The FLASH Write Protection  Option Bytes Register value
  */
uint32_t FLASH_GetWriteProtectionOptionByte(void)
{
  /* Return the Flash write protection Register value */
  return (uint32_t)(FLASH->WRPR);
 80010f0:	4b01      	ldr	r3, [pc, #4]	; (80010f8 <FLASH_GetWriteProtectionOptionByte+0x8>)
 80010f2:	6a18      	ldr	r0, [r3, #32]
}
 80010f4:	4770      	bx	lr
 80010f6:	bf00      	nop
 80010f8:	40022000 	.word	0x40022000

080010fc <FLASH_GetReadOutProtectionStatus>:
  * @retval FLASH ReadOut Protection Status(SET or RESET)
  */
FlagStatus FLASH_GetReadOutProtectionStatus(void)
{
  FlagStatus readoutstatus = RESET;
  if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
 80010fc:	4b02      	ldr	r3, [pc, #8]	; (8001108 <FLASH_GetReadOutProtectionStatus+0xc>)
 80010fe:	69d8      	ldr	r0, [r3, #28]
  else
  {
    readoutstatus = RESET;
  }
  return readoutstatus;
}
 8001100:	f3c0 0040 	ubfx	r0, r0, #1, #1
 8001104:	4770      	bx	lr
 8001106:	bf00      	nop
 8001108:	40022000 	.word	0x40022000

0800110c <FLASH_GetPrefetchBufferStatus>:
  */
FlagStatus FLASH_GetPrefetchBufferStatus(void)
{
  FlagStatus bitstatus = RESET;
  
  if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)
 800110c:	4b02      	ldr	r3, [pc, #8]	; (8001118 <FLASH_GetPrefetchBufferStatus+0xc>)
 800110e:	6818      	ldr	r0, [r3, #0]
  {
    bitstatus = RESET;
  }
  /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
  return bitstatus; 
}
 8001110:	f3c0 1040 	ubfx	r0, r0, #5, #1
 8001114:	4770      	bx	lr
 8001116:	bf00      	nop
 8001118:	40022000 	.word	0x40022000

0800111c <FLASH_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if(NewState != DISABLE)
  {
    /* Enable the interrupt sources */
    FLASH->CR |= FLASH_IT;
 800111c:	4a04      	ldr	r2, [pc, #16]	; (8001130 <FLASH_ITConfig+0x14>)
 800111e:	6913      	ldr	r3, [r2, #16]
#else
  /* Check the parameters */
  assert_param(IS_FLASH_IT(FLASH_IT)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if(NewState != DISABLE)
 8001120:	b919      	cbnz	r1, 800112a <FLASH_ITConfig+0xe>
    FLASH->CR |= FLASH_IT;
  }
  else
  {
    /* Disable the interrupt sources */
    FLASH->CR &= ~(uint32_t)FLASH_IT;
 8001122:	ea23 0000 	bic.w	r0, r3, r0
 8001126:	6110      	str	r0, [r2, #16]
 8001128:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if(NewState != DISABLE)
  {
    /* Enable the interrupt sources */
    FLASH->CR |= FLASH_IT;
 800112a:	4318      	orrs	r0, r3
 800112c:	6110      	str	r0, [r2, #16]
 800112e:	4770      	bx	lr
 8001130:	40022000 	.word	0x40022000

08001134 <FLASH_GetFlagStatus>:
    }
  }
#else
  /* Check the parameters */
  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
  if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
 8001134:	2801      	cmp	r0, #1
  {
    if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
 8001136:	4b06      	ldr	r3, [pc, #24]	; (8001150 <FLASH_GetFlagStatus+0x1c>)
    }
  }
#else
  /* Check the parameters */
  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
  if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
 8001138:	d005      	beq.n	8001146 <FLASH_GetFlagStatus+0x12>
      bitstatus = RESET;
    }
  }
  else
  {
   if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
 800113a:	68db      	ldr	r3, [r3, #12]
 800113c:	4218      	tst	r0, r3
    {
      bitstatus = SET;
    }
    else
    {
      bitstatus = RESET;
 800113e:	bf14      	ite	ne
 8001140:	2001      	movne	r0, #1
 8001142:	2000      	moveq	r0, #0
  }
#endif /* STM32F10X_XL */

  /* Return the new state of FLASH_FLAG (SET or RESET) */
  return bitstatus;
}
 8001144:	4770      	bx	lr
#else
  /* Check the parameters */
  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
  if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
  {
    if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
 8001146:	69d8      	ldr	r0, [r3, #28]
    {
      bitstatus = SET;
    }
    else
    {
      bitstatus = RESET;
 8001148:	f000 0001 	and.w	r0, r0, #1
 800114c:	4770      	bx	lr
 800114e:	bf00      	nop
 8001150:	40022000 	.word	0x40022000

08001154 <FLASH_ClearFlag>:
#else
  /* Check the parameters */
  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
  
  /* Clear the flags */
  FLASH->SR = FLASH_FLAG;
 8001154:	4b01      	ldr	r3, [pc, #4]	; (800115c <FLASH_ClearFlag+0x8>)
 8001156:	60d8      	str	r0, [r3, #12]
 8001158:	4770      	bx	lr
 800115a:	bf00      	nop
 800115c:	40022000 	.word	0x40022000

08001160 <FLASH_GetStatus>:
  */
FLASH_Status FLASH_GetStatus(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
 8001160:	4b08      	ldr	r3, [pc, #32]	; (8001184 <FLASH_GetStatus+0x24>)
 8001162:	68da      	ldr	r2, [r3, #12]
 8001164:	07d1      	lsls	r1, r2, #31
 8001166:	d40b      	bmi.n	8001180 <FLASH_GetStatus+0x20>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_PGERR) != 0)
 8001168:	68da      	ldr	r2, [r3, #12]
 800116a:	0752      	lsls	r2, r2, #29
 800116c:	d501      	bpl.n	8001172 <FLASH_GetStatus+0x12>
    { 
      flashstatus = FLASH_ERROR_PG;
 800116e:	2002      	movs	r0, #2
      }
    }
  }
  /* Return the Flash Status */
  return flashstatus;
}
 8001170:	4770      	bx	lr
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_WRPRTERR) != 0 )
 8001172:	68db      	ldr	r3, [r3, #12]
 8001174:	f013 0f10 	tst.w	r3, #16
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 8001178:	bf14      	ite	ne
 800117a:	2003      	movne	r0, #3
 800117c:	2004      	moveq	r0, #4
 800117e:	4770      	bx	lr
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
  {
    flashstatus = FLASH_BUSY;
 8001180:	2001      	movs	r0, #1
 8001182:	4770      	bx	lr
 8001184:	40022000 	.word	0x40022000

08001188 <FLASH_GetBank1Status>:
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8001188:	4b08      	ldr	r3, [pc, #32]	; (80011ac <FLASH_GetBank1Status+0x24>)
 800118a:	68da      	ldr	r2, [r3, #12]
 800118c:	07d1      	lsls	r1, r2, #31
 800118e:	d40b      	bmi.n	80011a8 <FLASH_GetBank1Status+0x20>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8001190:	68da      	ldr	r2, [r3, #12]
 8001192:	0752      	lsls	r2, r2, #29
 8001194:	d501      	bpl.n	800119a <FLASH_GetBank1Status+0x12>
    { 
      flashstatus = FLASH_ERROR_PG;
 8001196:	2002      	movs	r0, #2
      }
    }
  }
  /* Return the Flash Status */
  return flashstatus;
}
 8001198:	4770      	bx	lr
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 800119a:	68db      	ldr	r3, [r3, #12]
 800119c:	f013 0f10 	tst.w	r3, #16
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 80011a0:	bf14      	ite	ne
 80011a2:	2003      	movne	r0, #3
 80011a4:	2004      	moveq	r0, #4
 80011a6:	4770      	bx	lr
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
  {
    flashstatus = FLASH_BUSY;
 80011a8:	2001      	movs	r0, #1
 80011aa:	4770      	bx	lr
 80011ac:	40022000 	.word	0x40022000

080011b0 <FLASH_WaitForLastOperation>:
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 80011b0:	4a18      	ldr	r2, [pc, #96]	; (8001214 <FLASH_WaitForLastOperation+0x64>)
  * @param  Timeout: FLASH programming Timeout
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
{ 
 80011b2:	4603      	mov	r3, r0
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 80011b4:	68d1      	ldr	r1, [r2, #12]
 80011b6:	07c9      	lsls	r1, r1, #31
 80011b8:	d412      	bmi.n	80011e0 <FLASH_WaitForLastOperation+0x30>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 80011ba:	68d1      	ldr	r1, [r2, #12]
 80011bc:	0749      	lsls	r1, r1, #29
 80011be:	d505      	bpl.n	80011cc <FLASH_WaitForLastOperation+0x1c>
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 80011c0:	2b00      	cmp	r3, #0
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
    { 
      flashstatus = FLASH_ERROR_PG;
 80011c2:	f04f 0002 	mov.w	r0, #2
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 80011c6:	bf08      	it	eq
 80011c8:	2005      	moveq	r0, #5
 80011ca:	4770      	bx	lr
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 80011cc:	68d2      	ldr	r2, [r2, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 80011ce:	f012 0f10 	tst.w	r2, #16
 80011d2:	bf14      	ite	ne
 80011d4:	2003      	movne	r0, #3
 80011d6:	2004      	moveq	r0, #4
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 80011d8:	2b00      	cmp	r3, #0
 80011da:	bf08      	it	eq
 80011dc:	2005      	moveq	r0, #5
 80011de:	4770      	bx	lr
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 80011e0:	b170      	cbz	r0, 8001200 <FLASH_WaitForLastOperation+0x50>
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 80011e2:	68d1      	ldr	r1, [r2, #12]
 80011e4:	480b      	ldr	r0, [pc, #44]	; (8001214 <FLASH_WaitForLastOperation+0x64>)
 80011e6:	07c9      	lsls	r1, r1, #31
 80011e8:	d408      	bmi.n	80011fc <FLASH_WaitForLastOperation+0x4c>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 80011ea:	68c2      	ldr	r2, [r0, #12]
 80011ec:	0752      	lsls	r2, r2, #29
 80011ee:	d509      	bpl.n	8001204 <FLASH_WaitForLastOperation+0x54>
    { 
      flashstatus = FLASH_ERROR_PG;
 80011f0:	2002      	movs	r0, #2
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
 80011f2:	3b01      	subs	r3, #1
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 80011f4:	2b00      	cmp	r3, #0
 80011f6:	bf08      	it	eq
 80011f8:	2005      	moveq	r0, #5
 80011fa:	4770      	bx	lr
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 80011fc:	3b01      	subs	r3, #1
 80011fe:	d1f0      	bne.n	80011e2 <FLASH_WaitForLastOperation+0x32>
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 8001200:	2005      	movs	r0, #5
  }
  /* Return the operation status */
  return status;
}
 8001202:	4770      	bx	lr
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8001204:	68c2      	ldr	r2, [r0, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 8001206:	f012 0f10 	tst.w	r2, #16
 800120a:	bf14      	ite	ne
 800120c:	2003      	movne	r0, #3
 800120e:	2004      	moveq	r0, #4
 8001210:	e7ef      	b.n	80011f2 <FLASH_WaitForLastOperation+0x42>
 8001212:	bf00      	nop
 8001214:	40022000 	.word	0x40022000

08001218 <FLASH_WaitForLastBank1Operation>:
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 8001218:	4a18      	ldr	r2, [pc, #96]	; (800127c <FLASH_WaitForLastBank1Operation+0x64>)
  * @param  Timeout: FLASH programming Timeout
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_WaitForLastBank1Operation(uint32_t Timeout)
{ 
 800121a:	4603      	mov	r3, r0
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 800121c:	68d1      	ldr	r1, [r2, #12]
 800121e:	07c9      	lsls	r1, r1, #31
 8001220:	d412      	bmi.n	8001248 <FLASH_WaitForLastBank1Operation+0x30>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8001222:	68d1      	ldr	r1, [r2, #12]
 8001224:	0749      	lsls	r1, r1, #29
 8001226:	d505      	bpl.n	8001234 <FLASH_WaitForLastBank1Operation+0x1c>
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 8001228:	2b00      	cmp	r3, #0
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
    { 
      flashstatus = FLASH_ERROR_PG;
 800122a:	f04f 0002 	mov.w	r0, #2
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 800122e:	bf08      	it	eq
 8001230:	2005      	moveq	r0, #5
 8001232:	4770      	bx	lr
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 8001234:	68d2      	ldr	r2, [r2, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 8001236:	f012 0f10 	tst.w	r2, #16
 800123a:	bf14      	ite	ne
 800123c:	2003      	movne	r0, #3
 800123e:	2004      	moveq	r0, #4
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 8001240:	2b00      	cmp	r3, #0
 8001242:	bf08      	it	eq
 8001244:	2005      	moveq	r0, #5
 8001246:	4770      	bx	lr
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_FLAG_BANK1_BSY) && (Timeout != 0x00))
 8001248:	b170      	cbz	r0, 8001268 <FLASH_WaitForLastBank1Operation+0x50>
  */
FLASH_Status FLASH_GetBank1Status(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
 800124a:	68d1      	ldr	r1, [r2, #12]
 800124c:	480b      	ldr	r0, [pc, #44]	; (800127c <FLASH_WaitForLastBank1Operation+0x64>)
 800124e:	07c9      	lsls	r1, r1, #31
 8001250:	d408      	bmi.n	8001264 <FLASH_WaitForLastBank1Operation+0x4c>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
 8001252:	68c2      	ldr	r2, [r0, #12]
 8001254:	0752      	lsls	r2, r2, #29
 8001256:	d509      	bpl.n	800126c <FLASH_WaitForLastBank1Operation+0x54>
    { 
      flashstatus = FLASH_ERROR_PG;
 8001258:	2002      	movs	r0, #2
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_FLAG_BANK1_BSY) && (Timeout != 0x00))
  {
    status = FLASH_GetBank1Status();
    Timeout--;
 800125a:	3b01      	subs	r3, #1
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 800125c:	2b00      	cmp	r3, #0
 800125e:	bf08      	it	eq
 8001260:	2005      	moveq	r0, #5
 8001262:	4770      	bx	lr
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetBank1Status();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_FLAG_BANK1_BSY) && (Timeout != 0x00))
 8001264:	3b01      	subs	r3, #1
 8001266:	d1f0      	bne.n	800124a <FLASH_WaitForLastBank1Operation+0x32>
    status = FLASH_GetBank1Status();
    Timeout--;
  }
  if(Timeout == 0x00 )
  {
    status = FLASH_TIMEOUT;
 8001268:	2005      	movs	r0, #5
  }
  /* Return the operation status */
  return status;
}
 800126a:	4770      	bx	lr
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
 800126c:	68c2      	ldr	r2, [r0, #12]
      {
        flashstatus = FLASH_ERROR_WRP;
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 800126e:	f012 0f10 	tst.w	r2, #16
 8001272:	bf14      	ite	ne
 8001274:	2003      	movne	r0, #3
 8001276:	2004      	moveq	r0, #4
 8001278:	e7ef      	b.n	800125a <FLASH_WaitForLastBank1Operation+0x42>
 800127a:	bf00      	nop
 800127c:	40022000 	.word	0x40022000

08001280 <GPIO_DeInit>:
  * @brief  Deinitializes the GPIOx peripheral registers to their default reset values.
  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
  * @retval None
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 8001280:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  if (GPIOx == GPIOA)
 8001282:	4b2f      	ldr	r3, [pc, #188]	; (8001340 <GPIO_DeInit+0xc0>)
 8001284:	4298      	cmp	r0, r3
 8001286:	d01e      	beq.n	80012c6 <GPIO_DeInit+0x46>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
  }
  else if (GPIOx == GPIOB)
 8001288:	4b2e      	ldr	r3, [pc, #184]	; (8001344 <GPIO_DeInit+0xc4>)
 800128a:	4298      	cmp	r0, r3
 800128c:	d025      	beq.n	80012da <GPIO_DeInit+0x5a>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
  }
  else if (GPIOx == GPIOC)
 800128e:	4b2e      	ldr	r3, [pc, #184]	; (8001348 <GPIO_DeInit+0xc8>)
 8001290:	4298      	cmp	r0, r3
 8001292:	d02c      	beq.n	80012ee <GPIO_DeInit+0x6e>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
  }
  else if (GPIOx == GPIOD)
 8001294:	4b2d      	ldr	r3, [pc, #180]	; (800134c <GPIO_DeInit+0xcc>)
 8001296:	4298      	cmp	r0, r3
 8001298:	d033      	beq.n	8001302 <GPIO_DeInit+0x82>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
  }    
  else if (GPIOx == GPIOE)
 800129a:	4b2d      	ldr	r3, [pc, #180]	; (8001350 <GPIO_DeInit+0xd0>)
 800129c:	4298      	cmp	r0, r3
 800129e:	d03a      	beq.n	8001316 <GPIO_DeInit+0x96>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
  } 
  else if (GPIOx == GPIOF)
 80012a0:	4b2c      	ldr	r3, [pc, #176]	; (8001354 <GPIO_DeInit+0xd4>)
 80012a2:	4298      	cmp	r0, r3
 80012a4:	d041      	beq.n	800132a <GPIO_DeInit+0xaa>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
  }
  else
  {
    if (GPIOx == GPIOG)
 80012a6:	4b2c      	ldr	r3, [pc, #176]	; (8001358 <GPIO_DeInit+0xd8>)
 80012a8:	4298      	cmp	r0, r3
 80012aa:	d000      	beq.n	80012ae <GPIO_DeInit+0x2e>
 80012ac:	bd08      	pop	{r3, pc}
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
 80012ae:	f44f 7080 	mov.w	r0, #256	; 0x100
 80012b2:	2101      	movs	r1, #1
 80012b4:	f000 fc36 	bl	8001b24 <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    }
  }
}
 80012b8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {
    if (GPIOx == GPIOG)
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
 80012bc:	f44f 7080 	mov.w	r0, #256	; 0x100
 80012c0:	2100      	movs	r1, #0
 80012c2:	f000 bc2f 	b.w	8001b24 <RCC_APB2PeriphResetCmd>
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  if (GPIOx == GPIOA)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
 80012c6:	2004      	movs	r0, #4
 80012c8:	2101      	movs	r1, #1
 80012ca:	f000 fc2b 	bl	8001b24 <RCC_APB2PeriphResetCmd>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    }
  }
}
 80012ce:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  if (GPIOx == GPIOA)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
 80012d2:	2004      	movs	r0, #4
 80012d4:	2100      	movs	r1, #0
 80012d6:	f000 bc25 	b.w	8001b24 <RCC_APB2PeriphResetCmd>
  }
  else if (GPIOx == GPIOB)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
 80012da:	2008      	movs	r0, #8
 80012dc:	2101      	movs	r1, #1
 80012de:	f000 fc21 	bl	8001b24 <RCC_APB2PeriphResetCmd>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    }
  }
}
 80012e2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
  }
  else if (GPIOx == GPIOB)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
 80012e6:	2008      	movs	r0, #8
 80012e8:	2100      	movs	r1, #0
 80012ea:	f000 bc1b 	b.w	8001b24 <RCC_APB2PeriphResetCmd>
  }
  else if (GPIOx == GPIOC)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
 80012ee:	2010      	movs	r0, #16
 80012f0:	2101      	movs	r1, #1
 80012f2:	f000 fc17 	bl	8001b24 <RCC_APB2PeriphResetCmd>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    }
  }
}
 80012f6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
  }
  else if (GPIOx == GPIOC)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
 80012fa:	2010      	movs	r0, #16
 80012fc:	2100      	movs	r1, #0
 80012fe:	f000 bc11 	b.w	8001b24 <RCC_APB2PeriphResetCmd>
  }
  else if (GPIOx == GPIOD)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
 8001302:	2020      	movs	r0, #32
 8001304:	2101      	movs	r1, #1
 8001306:	f000 fc0d 	bl	8001b24 <RCC_APB2PeriphResetCmd>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    }
  }
}
 800130a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
  }
  else if (GPIOx == GPIOD)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
 800130e:	2020      	movs	r0, #32
 8001310:	2100      	movs	r1, #0
 8001312:	f000 bc07 	b.w	8001b24 <RCC_APB2PeriphResetCmd>
  }    
  else if (GPIOx == GPIOE)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
 8001316:	2040      	movs	r0, #64	; 0x40
 8001318:	2101      	movs	r1, #1
 800131a:	f000 fc03 	bl	8001b24 <RCC_APB2PeriphResetCmd>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    }
  }
}
 800131e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
  }    
  else if (GPIOx == GPIOE)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
 8001322:	2040      	movs	r0, #64	; 0x40
 8001324:	2100      	movs	r1, #0
 8001326:	f000 bbfd 	b.w	8001b24 <RCC_APB2PeriphResetCmd>
  } 
  else if (GPIOx == GPIOF)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
 800132a:	2080      	movs	r0, #128	; 0x80
 800132c:	2101      	movs	r1, #1
 800132e:	f000 fbf9 	bl	8001b24 <RCC_APB2PeriphResetCmd>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    }
  }
}
 8001332:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
  } 
  else if (GPIOx == GPIOF)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
 8001336:	2080      	movs	r0, #128	; 0x80
 8001338:	2100      	movs	r1, #0
 800133a:	f000 bbf3 	b.w	8001b24 <RCC_APB2PeriphResetCmd>
 800133e:	bf00      	nop
 8001340:	40010800 	.word	0x40010800
 8001344:	40010c00 	.word	0x40010c00
 8001348:	40011000 	.word	0x40011000
 800134c:	40011400 	.word	0x40011400
 8001350:	40011800 	.word	0x40011800
 8001354:	40011c00 	.word	0x40011c00
 8001358:	40012000 	.word	0x40012000

0800135c <GPIO_AFIODeInit>:
  *   and EXTI configuration) registers to their default reset values.
  * @param  None
  * @retval None
  */
void GPIO_AFIODeInit(void)
{
 800135c:	b508      	push	{r3, lr}
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
 800135e:	2001      	movs	r0, #1
 8001360:	4601      	mov	r1, r0
 8001362:	f000 fbdf 	bl	8001b24 <RCC_APB2PeriphResetCmd>
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
}
 8001366:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  * @retval None
  */
void GPIO_AFIODeInit(void)
{
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
 800136a:	2001      	movs	r0, #1
 800136c:	2100      	movs	r1, #0
 800136e:	f000 bbd9 	b.w	8001b24 <RCC_APB2PeriphResetCmd>
 8001372:	bf00      	nop

08001374 <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
  *         contains the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8001374:	b430      	push	{r4, r5}
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 8001376:	78cd      	ldrb	r5, [r1, #3]
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
 8001378:	06eb      	lsls	r3, r5, #27
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
 800137a:	bf48      	it	mi
 800137c:	788b      	ldrbmi	r3, [r1, #2]
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 800137e:	f005 040f 	and.w	r4, r5, #15
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
 8001382:	bf48      	it	mi
 8001384:	431c      	orrmi	r4, r3
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 8001386:	880b      	ldrh	r3, [r1, #0]
 8001388:	f013 0fff 	tst.w	r3, #255	; 0xff
 800138c:	d033      	beq.n	80013f6 <GPIO_Init+0x82>
 800138e:	2d48      	cmp	r5, #72	; 0x48
  {
    tmpreg = GPIOx->CRL;
 8001390:	6802      	ldr	r2, [r0, #0]
 8001392:	f000 8099 	beq.w	80014c8 <GPIO_Init+0x154>
 8001396:	2d28      	cmp	r5, #40	; 0x28
 8001398:	f000 80ff 	beq.w	800159a <GPIO_Init+0x226>
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
      if (currentpin == pos)
 800139c:	07d9      	lsls	r1, r3, #31
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 800139e:	bf44      	itt	mi
 80013a0:	f022 020f 	bicmi.w	r2, r2, #15
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80013a4:	4322      	orrmi	r2, r4
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
      if (currentpin == pos)
 80013a6:	0799      	lsls	r1, r3, #30
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 80013a8:	bf44      	itt	mi
 80013aa:	f022 02f0 	bicmi.w	r2, r2, #240	; 0xf0
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80013ae:	ea42 1204 	orrmi.w	r2, r2, r4, lsl #4
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
      if (currentpin == pos)
 80013b2:	0759      	lsls	r1, r3, #29
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 80013b4:	bf44      	itt	mi
 80013b6:	f422 6270 	bicmi.w	r2, r2, #3840	; 0xf00
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80013ba:	ea42 2204 	orrmi.w	r2, r2, r4, lsl #8
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
      if (currentpin == pos)
 80013be:	0719      	lsls	r1, r3, #28
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 80013c0:	bf44      	itt	mi
 80013c2:	f422 4270 	bicmi.w	r2, r2, #61440	; 0xf000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80013c6:	ea42 3204 	orrmi.w	r2, r2, r4, lsl #12
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
      if (currentpin == pos)
 80013ca:	06d9      	lsls	r1, r3, #27
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 80013cc:	bf44      	itt	mi
 80013ce:	f422 2270 	bicmi.w	r2, r2, #983040	; 0xf0000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80013d2:	ea42 4204 	orrmi.w	r2, r2, r4, lsl #16
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
      if (currentpin == pos)
 80013d6:	0699      	lsls	r1, r3, #26
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 80013d8:	bf44      	itt	mi
 80013da:	f422 0270 	bicmi.w	r2, r2, #15728640	; 0xf00000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80013de:	ea42 5204 	orrmi.w	r2, r2, r4, lsl #20
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
      if (currentpin == pos)
 80013e2:	0659      	lsls	r1, r3, #25
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 80013e4:	bf44      	itt	mi
 80013e6:	f022 6270 	bicmi.w	r2, r2, #251658240	; 0xf000000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80013ea:	ea42 6204 	orrmi.w	r2, r2, r4, lsl #24
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
      if (currentpin == pos)
 80013ee:	0619      	lsls	r1, r3, #24
 80013f0:	f100 809f 	bmi.w	8001532 <GPIO_Init+0x1be>
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
          }
        }
      }
    }
    GPIOx->CRL = tmpreg;
 80013f4:	6002      	str	r2, [r0, #0]
  }
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
 80013f6:	2bff      	cmp	r3, #255	; 0xff
 80013f8:	d931      	bls.n	800145e <GPIO_Init+0xea>
 80013fa:	2d48      	cmp	r5, #72	; 0x48
  {
    tmpreg = GPIOx->CRH;
 80013fc:	6842      	ldr	r2, [r0, #4]
 80013fe:	d030      	beq.n	8001462 <GPIO_Init+0xee>
 8001400:	2d28      	cmp	r5, #40	; 0x28
 8001402:	f000 8099 	beq.w	8001538 <GPIO_Init+0x1c4>
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
      if (currentpin == pos)
 8001406:	05d9      	lsls	r1, r3, #23
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8001408:	bf44      	itt	mi
 800140a:	f022 020f 	bicmi.w	r2, r2, #15
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 800140e:	4322      	orrmi	r2, r4
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
      if (currentpin == pos)
 8001410:	059d      	lsls	r5, r3, #22
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8001412:	bf44      	itt	mi
 8001414:	f022 02f0 	bicmi.w	r2, r2, #240	; 0xf0
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001418:	ea42 1204 	orrmi.w	r2, r2, r4, lsl #4
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
      if (currentpin == pos)
 800141c:	0559      	lsls	r1, r3, #21
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 800141e:	bf44      	itt	mi
 8001420:	f422 6270 	bicmi.w	r2, r2, #3840	; 0xf00
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001424:	ea42 2204 	orrmi.w	r2, r2, r4, lsl #8
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
      if (currentpin == pos)
 8001428:	051d      	lsls	r5, r3, #20
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 800142a:	bf44      	itt	mi
 800142c:	f422 4270 	bicmi.w	r2, r2, #61440	; 0xf000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001430:	ea42 3204 	orrmi.w	r2, r2, r4, lsl #12
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
      if (currentpin == pos)
 8001434:	04d9      	lsls	r1, r3, #19
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8001436:	bf44      	itt	mi
 8001438:	f422 2270 	bicmi.w	r2, r2, #983040	; 0xf0000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 800143c:	ea42 4204 	orrmi.w	r2, r2, r4, lsl #16
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
      if (currentpin == pos)
 8001440:	049d      	lsls	r5, r3, #18
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8001442:	bf44      	itt	mi
 8001444:	f422 0270 	bicmi.w	r2, r2, #15728640	; 0xf00000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001448:	ea42 5204 	orrmi.w	r2, r2, r4, lsl #20
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
      if (currentpin == pos)
 800144c:	0459      	lsls	r1, r3, #17
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 800144e:	bf44      	itt	mi
 8001450:	f022 6270 	bicmi.w	r2, r2, #251658240	; 0xf000000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001454:	ea42 6204 	orrmi.w	r2, r2, r4, lsl #24
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
      if (currentpin == pos)
 8001458:	041b      	lsls	r3, r3, #16
 800145a:	d467      	bmi.n	800152c <GPIO_Init+0x1b8>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
      }
    }
    GPIOx->CRH = tmpreg;
 800145c:	6042      	str	r2, [r0, #4]
  }
}
 800145e:	bc30      	pop	{r4, r5}
 8001460:	4770      	bx	lr
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 8001462:	f403 7180 	and.w	r1, r3, #256	; 0x100
      if (currentpin == pos)
 8001466:	b289      	uxth	r1, r1
 8001468:	2900      	cmp	r1, #0
 800146a:	f040 80d6 	bne.w	800161a <GPIO_Init+0x2a6>
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 800146e:	f403 7100 	and.w	r1, r3, #512	; 0x200
      if (currentpin == pos)
 8001472:	b289      	uxth	r1, r1
 8001474:	2900      	cmp	r1, #0
 8001476:	f040 80ca 	bne.w	800160e <GPIO_Init+0x29a>
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 800147a:	f403 6180 	and.w	r1, r3, #1024	; 0x400
      if (currentpin == pos)
 800147e:	b289      	uxth	r1, r1
 8001480:	2900      	cmp	r1, #0
 8001482:	f040 80be 	bne.w	8001602 <GPIO_Init+0x28e>
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 8001486:	f403 6100 	and.w	r1, r3, #2048	; 0x800
      if (currentpin == pos)
 800148a:	b289      	uxth	r1, r1
 800148c:	2900      	cmp	r1, #0
 800148e:	f040 80b2 	bne.w	80015f6 <GPIO_Init+0x282>
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 8001492:	f403 5180 	and.w	r1, r3, #4096	; 0x1000
      if (currentpin == pos)
 8001496:	b289      	uxth	r1, r1
 8001498:	2900      	cmp	r1, #0
 800149a:	f040 80c9 	bne.w	8001630 <GPIO_Init+0x2bc>
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 800149e:	f403 5100 	and.w	r1, r3, #8192	; 0x2000
      if (currentpin == pos)
 80014a2:	b289      	uxth	r1, r1
 80014a4:	2900      	cmp	r1, #0
 80014a6:	f040 80bd 	bne.w	8001624 <GPIO_Init+0x2b0>
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 80014aa:	f403 4180 	and.w	r1, r3, #16384	; 0x4000
      if (currentpin == pos)
 80014ae:	b289      	uxth	r1, r1
 80014b0:	2900      	cmp	r1, #0
 80014b2:	f040 80c3 	bne.w	800163c <GPIO_Init+0x2c8>
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 80014b6:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
      if (currentpin == pos)
 80014ba:	b29b      	uxth	r3, r3
 80014bc:	2b00      	cmp	r3, #0
 80014be:	d0cd      	beq.n	800145c <GPIO_Init+0xe8>
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80014c0:	f364 721f 	bfi	r2, r4, #28, #4
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 80014c4:	6103      	str	r3, [r0, #16]
 80014c6:	e7c9      	b.n	800145c <GPIO_Init+0xe8>
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
      if (currentpin == pos)
 80014c8:	f013 0101 	ands.w	r1, r3, #1
 80014cc:	f040 8132 	bne.w	8001734 <GPIO_Init+0x3c0>
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80014d0:	f003 0102 	and.w	r1, r3, #2
      if (currentpin == pos)
 80014d4:	b289      	uxth	r1, r1
 80014d6:	2900      	cmp	r1, #0
 80014d8:	f040 8126 	bne.w	8001728 <GPIO_Init+0x3b4>
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80014dc:	f003 0104 	and.w	r1, r3, #4
      if (currentpin == pos)
 80014e0:	b289      	uxth	r1, r1
 80014e2:	2900      	cmp	r1, #0
 80014e4:	f040 811a 	bne.w	800171c <GPIO_Init+0x3a8>
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80014e8:	f003 0108 	and.w	r1, r3, #8
      if (currentpin == pos)
 80014ec:	b289      	uxth	r1, r1
 80014ee:	2900      	cmp	r1, #0
 80014f0:	f040 810e 	bne.w	8001710 <GPIO_Init+0x39c>
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80014f4:	f003 0110 	and.w	r1, r3, #16
      if (currentpin == pos)
 80014f8:	b289      	uxth	r1, r1
 80014fa:	2900      	cmp	r1, #0
 80014fc:	f040 8102 	bne.w	8001704 <GPIO_Init+0x390>
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8001500:	f003 0120 	and.w	r1, r3, #32
      if (currentpin == pos)
 8001504:	b289      	uxth	r1, r1
 8001506:	2900      	cmp	r1, #0
 8001508:	f040 80f6 	bne.w	80016f8 <GPIO_Init+0x384>
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 800150c:	f003 0140 	and.w	r1, r3, #64	; 0x40
      if (currentpin == pos)
 8001510:	b289      	uxth	r1, r1
 8001512:	2900      	cmp	r1, #0
 8001514:	f040 80ea 	bne.w	80016ec <GPIO_Init+0x378>
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8001518:	f003 0180 	and.w	r1, r3, #128	; 0x80
      if (currentpin == pos)
 800151c:	b289      	uxth	r1, r1
 800151e:	2900      	cmp	r1, #0
 8001520:	f43f af68 	beq.w	80013f4 <GPIO_Init+0x80>
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001524:	f364 721f 	bfi	r2, r4, #28, #4
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 8001528:	6101      	str	r1, [r0, #16]
 800152a:	e763      	b.n	80013f4 <GPIO_Init+0x80>
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 800152c:	f364 721f 	bfi	r2, r4, #28, #4
 8001530:	e794      	b.n	800145c <GPIO_Init+0xe8>
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001532:	f364 721f 	bfi	r2, r4, #28, #4
 8001536:	e75d      	b.n	80013f4 <GPIO_Init+0x80>
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 8001538:	f403 7180 	and.w	r1, r3, #256	; 0x100
      if (currentpin == pos)
 800153c:	b289      	uxth	r1, r1
 800153e:	2900      	cmp	r1, #0
 8001540:	f040 80a6 	bne.w	8001690 <GPIO_Init+0x31c>
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 8001544:	f403 7100 	and.w	r1, r3, #512	; 0x200
      if (currentpin == pos)
 8001548:	b289      	uxth	r1, r1
 800154a:	2900      	cmp	r1, #0
 800154c:	f040 809a 	bne.w	8001684 <GPIO_Init+0x310>
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 8001550:	f403 6180 	and.w	r1, r3, #1024	; 0x400
      if (currentpin == pos)
 8001554:	b289      	uxth	r1, r1
 8001556:	2900      	cmp	r1, #0
 8001558:	f040 808e 	bne.w	8001678 <GPIO_Init+0x304>
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 800155c:	f403 6100 	and.w	r1, r3, #2048	; 0x800
      if (currentpin == pos)
 8001560:	b289      	uxth	r1, r1
 8001562:	2900      	cmp	r1, #0
 8001564:	f040 8082 	bne.w	800166c <GPIO_Init+0x2f8>
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 8001568:	f403 5180 	and.w	r1, r3, #4096	; 0x1000
      if (currentpin == pos)
 800156c:	b289      	uxth	r1, r1
 800156e:	2900      	cmp	r1, #0
 8001570:	d176      	bne.n	8001660 <GPIO_Init+0x2ec>
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 8001572:	f403 5100 	and.w	r1, r3, #8192	; 0x2000
      if (currentpin == pos)
 8001576:	b289      	uxth	r1, r1
 8001578:	2900      	cmp	r1, #0
 800157a:	d16b      	bne.n	8001654 <GPIO_Init+0x2e0>
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 800157c:	f403 4180 	and.w	r1, r3, #16384	; 0x4000
      if (currentpin == pos)
 8001580:	b289      	uxth	r1, r1
 8001582:	2900      	cmp	r1, #0
 8001584:	d160      	bne.n	8001648 <GPIO_Init+0x2d4>
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 8001586:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
      if (currentpin == pos)
 800158a:	b29b      	uxth	r3, r3
 800158c:	2b00      	cmp	r3, #0
 800158e:	f43f af65 	beq.w	800145c <GPIO_Init+0xe8>
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001592:	f364 721f 	bfi	r2, r4, #28, #4
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8001596:	6143      	str	r3, [r0, #20]
 8001598:	e760      	b.n	800145c <GPIO_Init+0xe8>
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
      if (currentpin == pos)
 800159a:	f013 0101 	ands.w	r1, r3, #1
 800159e:	f040 809a 	bne.w	80016d6 <GPIO_Init+0x362>
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80015a2:	f003 0102 	and.w	r1, r3, #2
      if (currentpin == pos)
 80015a6:	b289      	uxth	r1, r1
 80015a8:	2900      	cmp	r1, #0
 80015aa:	f040 808e 	bne.w	80016ca <GPIO_Init+0x356>
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80015ae:	f003 0104 	and.w	r1, r3, #4
      if (currentpin == pos)
 80015b2:	b289      	uxth	r1, r1
 80015b4:	2900      	cmp	r1, #0
 80015b6:	f040 8082 	bne.w	80016be <GPIO_Init+0x34a>
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80015ba:	f003 0108 	and.w	r1, r3, #8
      if (currentpin == pos)
 80015be:	b289      	uxth	r1, r1
 80015c0:	2900      	cmp	r1, #0
 80015c2:	d176      	bne.n	80016b2 <GPIO_Init+0x33e>
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80015c4:	f003 0110 	and.w	r1, r3, #16
      if (currentpin == pos)
 80015c8:	b289      	uxth	r1, r1
 80015ca:	2900      	cmp	r1, #0
 80015cc:	d16b      	bne.n	80016a6 <GPIO_Init+0x332>
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80015ce:	f003 0120 	and.w	r1, r3, #32
      if (currentpin == pos)
 80015d2:	b289      	uxth	r1, r1
 80015d4:	2900      	cmp	r1, #0
 80015d6:	d160      	bne.n	800169a <GPIO_Init+0x326>
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80015d8:	f003 0140 	and.w	r1, r3, #64	; 0x40
      if (currentpin == pos)
 80015dc:	b289      	uxth	r1, r1
 80015de:	2900      	cmp	r1, #0
 80015e0:	d17e      	bne.n	80016e0 <GPIO_Init+0x36c>
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((uint32_t)0x01) << pinpos;
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80015e2:	f003 0180 	and.w	r1, r3, #128	; 0x80
      if (currentpin == pos)
 80015e6:	b289      	uxth	r1, r1
 80015e8:	2900      	cmp	r1, #0
 80015ea:	f43f af03 	beq.w	80013f4 <GPIO_Init+0x80>
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80015ee:	f364 721f 	bfi	r2, r4, #28, #4
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 80015f2:	6141      	str	r1, [r0, #20]
 80015f4:	e6fe      	b.n	80013f4 <GPIO_Init+0x80>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 80015f6:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80015fa:	ea42 3204 	orr.w	r2, r2, r4, lsl #12
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 80015fe:	6101      	str	r1, [r0, #16]
 8001600:	e747      	b.n	8001492 <GPIO_Init+0x11e>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8001602:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001606:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 800160a:	6101      	str	r1, [r0, #16]
 800160c:	e73b      	b.n	8001486 <GPIO_Init+0x112>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 800160e:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001612:	ea42 1204 	orr.w	r2, r2, r4, lsl #4
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8001616:	6101      	str	r1, [r0, #16]
 8001618:	e72f      	b.n	800147a <GPIO_Init+0x106>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 800161a:	f022 020f 	bic.w	r2, r2, #15
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 800161e:	4322      	orrs	r2, r4
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8001620:	6101      	str	r1, [r0, #16]
 8001622:	e724      	b.n	800146e <GPIO_Init+0xfa>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8001624:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001628:	ea42 5204 	orr.w	r2, r2, r4, lsl #20
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 800162c:	6101      	str	r1, [r0, #16]
 800162e:	e73c      	b.n	80014aa <GPIO_Init+0x136>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8001630:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001634:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8001638:	6101      	str	r1, [r0, #16]
 800163a:	e730      	b.n	800149e <GPIO_Init+0x12a>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 800163c:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001640:	ea42 6204 	orr.w	r2, r2, r4, lsl #24
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8001644:	6101      	str	r1, [r0, #16]
 8001646:	e736      	b.n	80014b6 <GPIO_Init+0x142>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8001648:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 800164c:	ea42 6204 	orr.w	r2, r2, r4, lsl #24
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8001650:	6141      	str	r1, [r0, #20]
 8001652:	e798      	b.n	8001586 <GPIO_Init+0x212>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8001654:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001658:	ea42 5204 	orr.w	r2, r2, r4, lsl #20
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 800165c:	6141      	str	r1, [r0, #20]
 800165e:	e78d      	b.n	800157c <GPIO_Init+0x208>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8001660:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001664:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8001668:	6141      	str	r1, [r0, #20]
 800166a:	e782      	b.n	8001572 <GPIO_Init+0x1fe>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 800166c:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001670:	ea42 3204 	orr.w	r2, r2, r4, lsl #12
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8001674:	6141      	str	r1, [r0, #20]
 8001676:	e777      	b.n	8001568 <GPIO_Init+0x1f4>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8001678:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 800167c:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8001680:	6141      	str	r1, [r0, #20]
 8001682:	e76b      	b.n	800155c <GPIO_Init+0x1e8>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8001684:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001688:	ea42 1204 	orr.w	r2, r2, r4, lsl #4
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 800168c:	6141      	str	r1, [r0, #20]
 800168e:	e75f      	b.n	8001550 <GPIO_Init+0x1dc>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8001690:	f022 020f 	bic.w	r2, r2, #15
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001694:	4322      	orrs	r2, r4
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8001696:	6141      	str	r1, [r0, #20]
 8001698:	e754      	b.n	8001544 <GPIO_Init+0x1d0>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 800169a:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 800169e:	ea42 5204 	orr.w	r2, r2, r4, lsl #20
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 80016a2:	6141      	str	r1, [r0, #20]
 80016a4:	e798      	b.n	80015d8 <GPIO_Init+0x264>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 80016a6:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80016aa:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 80016ae:	6141      	str	r1, [r0, #20]
 80016b0:	e78d      	b.n	80015ce <GPIO_Init+0x25a>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 80016b2:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80016b6:	ea42 3204 	orr.w	r2, r2, r4, lsl #12
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 80016ba:	6141      	str	r1, [r0, #20]
 80016bc:	e782      	b.n	80015c4 <GPIO_Init+0x250>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 80016be:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80016c2:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 80016c6:	6141      	str	r1, [r0, #20]
 80016c8:	e777      	b.n	80015ba <GPIO_Init+0x246>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 80016ca:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80016ce:	ea42 1204 	orr.w	r2, r2, r4, lsl #4
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 80016d2:	6141      	str	r1, [r0, #20]
 80016d4:	e76b      	b.n	80015ae <GPIO_Init+0x23a>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 80016d6:	f022 020f 	bic.w	r2, r2, #15
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80016da:	4322      	orrs	r2, r4
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 80016dc:	6141      	str	r1, [r0, #20]
 80016de:	e760      	b.n	80015a2 <GPIO_Init+0x22e>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 80016e0:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80016e4:	ea42 6204 	orr.w	r2, r2, r4, lsl #24
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 80016e8:	6141      	str	r1, [r0, #20]
 80016ea:	e77a      	b.n	80015e2 <GPIO_Init+0x26e>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 80016ec:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80016f0:	ea42 6204 	orr.w	r2, r2, r4, lsl #24
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 80016f4:	6101      	str	r1, [r0, #16]
 80016f6:	e70f      	b.n	8001518 <GPIO_Init+0x1a4>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 80016f8:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80016fc:	ea42 5204 	orr.w	r2, r2, r4, lsl #20
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 8001700:	6101      	str	r1, [r0, #16]
 8001702:	e703      	b.n	800150c <GPIO_Init+0x198>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8001704:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001708:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 800170c:	6101      	str	r1, [r0, #16]
 800170e:	e6f7      	b.n	8001500 <GPIO_Init+0x18c>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8001710:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001714:	ea42 3204 	orr.w	r2, r2, r4, lsl #12
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 8001718:	6101      	str	r1, [r0, #16]
 800171a:	e6eb      	b.n	80014f4 <GPIO_Init+0x180>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 800171c:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001720:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 8001724:	6101      	str	r1, [r0, #16]
 8001726:	e6df      	b.n	80014e8 <GPIO_Init+0x174>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8001728:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 800172c:	ea42 1204 	orr.w	r2, r2, r4, lsl #4
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 8001730:	6101      	str	r1, [r0, #16]
 8001732:	e6d3      	b.n	80014dc <GPIO_Init+0x168>
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
        tmpreg &= ~pinmask;
 8001734:	f022 020f 	bic.w	r2, r2, #15
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001738:	4322      	orrs	r2, r4
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 800173a:	6101      	str	r1, [r0, #16]
 800173c:	e6c8      	b.n	80014d0 <GPIO_Init+0x15c>
 800173e:	bf00      	nop

08001740 <GPIO_StructInit>:
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 8001740:	f64f 71ff 	movw	r1, #65535	; 0xffff
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 8001744:	2202      	movs	r2, #2
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
 8001746:	2304      	movs	r3, #4
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 8001748:	8001      	strh	r1, [r0, #0]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 800174a:	7082      	strb	r2, [r0, #2]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
 800174c:	70c3      	strb	r3, [r0, #3]
 800174e:	4770      	bx	lr

08001750 <GPIO_ReadInputDataBit>:
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8001750:	6883      	ldr	r3, [r0, #8]
 8001752:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 8001754:	bf14      	ite	ne
 8001756:	2001      	movne	r0, #1
 8001758:	2000      	moveq	r0, #0
 800175a:	4770      	bx	lr

0800175c <GPIO_ReadInputData>:
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  return ((uint16_t)GPIOx->IDR);
 800175c:	6880      	ldr	r0, [r0, #8]
}
 800175e:	b280      	uxth	r0, r0
 8001760:	4770      	bx	lr
 8001762:	bf00      	nop

08001764 <GPIO_ReadOutputDataBit>:
  uint8_t bitstatus = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8001764:	68c3      	ldr	r3, [r0, #12]
 8001766:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 8001768:	bf14      	ite	ne
 800176a:	2001      	movne	r0, #1
 800176c:	2000      	moveq	r0, #0
 800176e:	4770      	bx	lr

08001770 <GPIO_ReadOutputData>:
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    
  return ((uint16_t)GPIOx->ODR);
 8001770:	68c0      	ldr	r0, [r0, #12]
}
 8001772:	b280      	uxth	r0, r0
 8001774:	4770      	bx	lr
 8001776:	bf00      	nop

08001778 <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BSRR = GPIO_Pin;
 8001778:	6101      	str	r1, [r0, #16]
 800177a:	4770      	bx	lr

0800177c <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BRR = GPIO_Pin;
 800177c:	6141      	str	r1, [r0, #20]
 800177e:	4770      	bx	lr

08001780 <GPIO_WriteBit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
  
  if (BitVal != Bit_RESET)
 8001780:	b90a      	cbnz	r2, 8001786 <GPIO_WriteBit+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BRR = GPIO_Pin;
 8001782:	6141      	str	r1, [r0, #20]
 8001784:	4770      	bx	lr
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
  
  if (BitVal != Bit_RESET)
  {
    GPIOx->BSRR = GPIO_Pin;
 8001786:	6101      	str	r1, [r0, #16]
 8001788:	4770      	bx	lr
 800178a:	bf00      	nop

0800178c <GPIO_Write>:
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  GPIOx->ODR = PortVal;
 800178c:	60c1      	str	r1, [r0, #12]
 800178e:	4770      	bx	lr

08001790 <GPIO_PinLockConfig>:
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  tmp |= GPIO_Pin;
 8001790:	f441 3380 	orr.w	r3, r1, #65536	; 0x10000
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8001794:	6183      	str	r3, [r0, #24]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
 8001796:	6181      	str	r1, [r0, #24]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8001798:	6183      	str	r3, [r0, #24]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 800179a:	6983      	ldr	r3, [r0, #24]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 800179c:	6983      	ldr	r3, [r0, #24]
 800179e:	4770      	bx	lr

080017a0 <GPIO_EventOutputConfig>:
  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    
  tmpreg = AFIO->EVCR;
  /* Clear the PORT[6:4] and PIN[3:0] bits */
  tmpreg &= EVCR_PORTPINCONFIG_MASK;
 80017a0:	f64f 7380 	movw	r3, #65408	; 0xff80
  uint32_t tmpreg = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    
  tmpreg = AFIO->EVCR;
 80017a4:	4a05      	ldr	r2, [pc, #20]	; (80017bc <GPIO_EventOutputConfig+0x1c>)
  * @param  GPIO_PinSource: specifies the pin for the Event output.
  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
  * @retval None
  */
void GPIO_EventOutputConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
{
 80017a6:	b410      	push	{r4}
  uint32_t tmpreg = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    
  tmpreg = AFIO->EVCR;
 80017a8:	6814      	ldr	r4, [r2, #0]
  /* Clear the PORT[6:4] and PIN[3:0] bits */
  tmpreg &= EVCR_PORTPINCONFIG_MASK;
 80017aa:	4023      	ands	r3, r4
 80017ac:	4319      	orrs	r1, r3
  tmpreg |= (uint32_t)GPIO_PortSource << 0x04;
  tmpreg |= GPIO_PinSource;
 80017ae:	ea41 1000 	orr.w	r0, r1, r0, lsl #4
  AFIO->EVCR = tmpreg;
 80017b2:	6010      	str	r0, [r2, #0]
}
 80017b4:	f85d 4b04 	ldr.w	r4, [sp], #4
 80017b8:	4770      	bx	lr
 80017ba:	bf00      	nop
 80017bc:	40010000 	.word	0x40010000

080017c0 <GPIO_EventOutputCmd>:
void GPIO_EventOutputCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) EVCR_EVOE_BB = (uint32_t)NewState;
 80017c0:	4b01      	ldr	r3, [pc, #4]	; (80017c8 <GPIO_EventOutputCmd+0x8>)
 80017c2:	6018      	str	r0, [r3, #0]
 80017c4:	4770      	bx	lr
 80017c6:	bf00      	nop
 80017c8:	4220001c 	.word	0x4220001c

080017cc <GPIO_PinRemapConfig>:

  /* Check the parameters */
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if((GPIO_Remap & 0x80000000) == 0x80000000)
 80017cc:	2800      	cmp	r0, #0
  {
    tmpreg = AFIO->MAPR2;
 80017ce:	4b19      	ldr	r3, [pc, #100]	; (8001834 <GPIO_PinRemapConfig+0x68>)
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 80017d0:	f400 1240 	and.w	r2, r0, #3145728	; 0x300000
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if((GPIO_Remap & 0x80000000) == 0x80000000)
  {
    tmpreg = AFIO->MAPR2;
 80017d4:	bfb4      	ite	lt
 80017d6:	69db      	ldrlt	r3, [r3, #28]
  }
  else
  {
    tmpreg = AFIO->MAPR;
 80017d8:	685b      	ldrge	r3, [r3, #4]
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 80017da:	f5b2 1f40 	cmp.w	r2, #3145728	; 0x300000
  * @param  NewState: new state of the port pin remapping.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState)
{
 80017de:	b430      	push	{r4, r5}
  {
    tmpreg = AFIO->MAPR;
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;
 80017e0:	b284      	uxth	r4, r0

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 80017e2:	d01e      	beq.n	8001822 <GPIO_PinRemapConfig+0x56>
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
 80017e4:	02c2      	lsls	r2, r0, #11
 80017e6:	d513      	bpl.n	8001810 <GPIO_PinRemapConfig+0x44>
  else
  {
    tmpreg = AFIO->MAPR;
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
 80017e8:	f3c0 4503 	ubfx	r5, r0, #16, #4
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
  {
    tmp1 = ((uint32_t)0x03) << tmpmask;
 80017ec:	2203      	movs	r2, #3
 80017ee:	40aa      	lsls	r2, r5
    tmpreg &= ~tmp1;
 80017f0:	ea23 0302 	bic.w	r3, r3, r2
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
 80017f4:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
  {
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
  }

  if (NewState != DISABLE)
 80017f8:	b119      	cbz	r1, 8001802 <GPIO_PinRemapConfig+0x36>
  {
    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
 80017fa:	0d42      	lsrs	r2, r0, #21
 80017fc:	0112      	lsls	r2, r2, #4
 80017fe:	4094      	lsls	r4, r2
 8001800:	4323      	orrs	r3, r4
  }

  if((GPIO_Remap & 0x80000000) == 0x80000000)
  {
    AFIO->MAPR2 = tmpreg;
 8001802:	4a0c      	ldr	r2, [pc, #48]	; (8001834 <GPIO_PinRemapConfig+0x68>)
  if (NewState != DISABLE)
  {
    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
  }

  if((GPIO_Remap & 0x80000000) == 0x80000000)
 8001804:	2800      	cmp	r0, #0
  {
    AFIO->MAPR2 = tmpreg;
 8001806:	bfb4      	ite	lt
 8001808:	61d3      	strlt	r3, [r2, #28]
  }
  else
  {
    AFIO->MAPR = tmpreg;
 800180a:	6053      	strge	r3, [r2, #4]
  }  
}
 800180c:	bc30      	pop	{r4, r5}
 800180e:	4770      	bx	lr
    tmpreg &= ~tmp1;
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
  }
  else
  {
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
 8001810:	0d42      	lsrs	r2, r0, #21
 8001812:	0112      	lsls	r2, r2, #4
 8001814:	fa04 f202 	lsl.w	r2, r4, r2
 8001818:	ea23 0302 	bic.w	r3, r3, r2
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
 800181c:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
 8001820:	e7ea      	b.n	80017f8 <GPIO_PinRemapConfig+0x2c>
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
 8001822:	4d04      	ldr	r5, [pc, #16]	; (8001834 <GPIO_PinRemapConfig+0x68>)
  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
 8001824:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
 8001828:	686a      	ldr	r2, [r5, #4]
 800182a:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 800182e:	606a      	str	r2, [r5, #4]
 8001830:	e7e2      	b.n	80017f8 <GPIO_PinRemapConfig+0x2c>
 8001832:	bf00      	nop
 8001834:	40010000 	.word	0x40010000

08001838 <GPIO_EXTILineConfig>:
  * @param  GPIO_PinSource: specifies the EXTI line to be configured.
  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
  * @retval None
  */
void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
{
 8001838:	f001 03fc 	and.w	r3, r1, #252	; 0xfc
 800183c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8001840:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
  uint32_t tmp = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));
 8001844:	f001 0103 	and.w	r1, r1, #3
  * @param  GPIO_PinSource: specifies the EXTI line to be configured.
  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
  * @retval None
  */
void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
{
 8001848:	b410      	push	{r4}
  uint32_t tmp = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));
 800184a:	0089      	lsls	r1, r1, #2
  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
 800184c:	689c      	ldr	r4, [r3, #8]
  uint32_t tmp = 0x00;
  /* Check the parameters */
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));
 800184e:	220f      	movs	r2, #15
 8001850:	408a      	lsls	r2, r1
  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
 8001852:	ea24 0202 	bic.w	r2, r4, r2
 8001856:	609a      	str	r2, [r3, #8]
  AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((uint32_t)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (uint8_t)0x03)));
 8001858:	689a      	ldr	r2, [r3, #8]
 800185a:	4088      	lsls	r0, r1
 800185c:	4302      	orrs	r2, r0
 800185e:	609a      	str	r2, [r3, #8]
}
 8001860:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001864:	4770      	bx	lr
 8001866:	bf00      	nop

08001868 <GPIO_ETH_MediaInterfaceConfig>:
void GPIO_ETH_MediaInterfaceConfig(uint32_t GPIO_ETH_MediaInterface) 
{ 
  assert_param(IS_GPIO_ETH_MEDIA_INTERFACE(GPIO_ETH_MediaInterface)); 

  /* Configure MII_RMII selection bit */ 
  *(__IO uint32_t *) MAPR_MII_RMII_SEL_BB = GPIO_ETH_MediaInterface; 
 8001868:	4b01      	ldr	r3, [pc, #4]	; (8001870 <GPIO_ETH_MediaInterfaceConfig+0x8>)
 800186a:	6018      	str	r0, [r3, #0]
 800186c:	4770      	bx	lr
 800186e:	bf00      	nop
 8001870:	422000dc 	.word	0x422000dc

08001874 <RCC_DeInit>:
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8001874:	4b0d      	ldr	r3, [pc, #52]	; (80018ac <RCC_DeInit+0x38>)

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 8001876:	4a0e      	ldr	r2, [pc, #56]	; (80018b0 <RCC_DeInit+0x3c>)
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8001878:	6819      	ldr	r1, [r3, #0]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 800187a:	f44f 001f 	mov.w	r0, #10420224	; 0x9f0000
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800187e:	f041 0101 	orr.w	r1, r1, #1
 8001882:	6019      	str	r1, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 8001884:	6859      	ldr	r1, [r3, #4]
 8001886:	400a      	ands	r2, r1
 8001888:	605a      	str	r2, [r3, #4]
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 800188a:	681a      	ldr	r2, [r3, #0]
 800188c:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8001890:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8001894:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8001896:	681a      	ldr	r2, [r3, #0]
 8001898:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800189c:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 800189e:	685a      	ldr	r2, [r3, #4]
 80018a0:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 80018a4:	605a      	str	r2, [r3, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 80018a6:	6098      	str	r0, [r3, #8]
 80018a8:	4770      	bx	lr
 80018aa:	bf00      	nop
 80018ac:	40021000 	.word	0x40021000
 80018b0:	f8ff0000 	.word	0xf8ff0000

080018b4 <RCC_HSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));
  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 80018b4:	4b0c      	ldr	r3, [pc, #48]	; (80018e8 <RCC_HSEConfig+0x34>)
  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 80018b6:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));
  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 80018ba:	681a      	ldr	r2, [r3, #0]
 80018bc:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80018c0:	601a      	str	r2, [r3, #0]
  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
 80018c2:	681a      	ldr	r2, [r3, #0]
 80018c4:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80018c8:	601a      	str	r2, [r3, #0]
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 80018ca:	d008      	beq.n	80018de <RCC_HSEConfig+0x2a>
 80018cc:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
 80018d0:	d104      	bne.n	80018dc <RCC_HSEConfig+0x28>
      RCC->CR |= CR_HSEON_Set;
      break;
      
    case RCC_HSE_Bypass:
      /* Set HSEBYP and HSEON bits */
      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
 80018d2:	681a      	ldr	r2, [r3, #0]
 80018d4:	f442 22a0 	orr.w	r2, r2, #327680	; 0x50000
 80018d8:	601a      	str	r2, [r3, #0]
 80018da:	4770      	bx	lr
 80018dc:	4770      	bx	lr
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
  {
    case RCC_HSE_ON:
      /* Set HSEON bit */
      RCC->CR |= CR_HSEON_Set;
 80018de:	681a      	ldr	r2, [r3, #0]
 80018e0:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80018e4:	601a      	str	r2, [r3, #0]
      break;
 80018e6:	4770      	bx	lr
 80018e8:	40021000 	.word	0x40021000

080018ec <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumuration value:
  * - SUCCESS: HSE oscillator is stable and ready to use
  * - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 80018ec:	b082      	sub	sp, #8
  __IO uint32_t StartUpCounter = 0;
 80018ee:	2300      	movs	r3, #0

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 80018f0:	4a0a      	ldr	r2, [pc, #40]	; (800191c <RCC_WaitForHSEStartUp+0x30>)
  * - SUCCESS: HSE oscillator is stable and ready to use
  * - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
  __IO uint32_t StartUpCounter = 0;
 80018f2:	9301      	str	r3, [sp, #4]
 80018f4:	e002      	b.n	80018fc <RCC_WaitForHSEStartUp+0x10>
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
    StartUpCounter++;  
  } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
 80018f6:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80018fa:	d008      	beq.n	800190e <RCC_WaitForHSEStartUp+0x22>

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 80018fc:	6813      	ldr	r3, [r2, #0]
    statusreg = RCC->CSR;
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_Mask;
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 80018fe:	f413 3f00 	tst.w	r3, #131072	; 0x20000
  
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
    StartUpCounter++;  
 8001902:	9b01      	ldr	r3, [sp, #4]
 8001904:	f103 0301 	add.w	r3, r3, #1
 8001908:	9301      	str	r3, [sp, #4]
  } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
 800190a:	9b01      	ldr	r3, [sp, #4]
    statusreg = RCC->CSR;
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_Mask;
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 800190c:	d0f3      	beq.n	80018f6 <RCC_WaitForHSEStartUp+0xa>

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 800190e:	4b03      	ldr	r3, [pc, #12]	; (800191c <RCC_WaitForHSEStartUp+0x30>)
 8001910:	6818      	ldr	r0, [r3, #0]
  }
  else
  {
    status = ERROR;
  }  
  return (status);
 8001912:	f3c0 4040 	ubfx	r0, r0, #17, #1
}
 8001916:	b002      	add	sp, #8
 8001918:	4770      	bx	lr
 800191a:	bf00      	nop
 800191c:	40021000 	.word	0x40021000

08001920 <RCC_AdjustHSICalibrationValue>:
void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
  tmpreg = RCC->CR;
 8001920:	4a03      	ldr	r2, [pc, #12]	; (8001930 <RCC_AdjustHSICalibrationValue+0x10>)
 8001922:	6813      	ldr	r3, [r2, #0]
  /* Clear HSITRIM[4:0] bits */
  tmpreg &= CR_HSITRIM_Mask;
 8001924:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 8001928:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
  /* Store the new value */
  RCC->CR = tmpreg;
 800192c:	6010      	str	r0, [r2, #0]
 800192e:	4770      	bx	lr
 8001930:	40021000 	.word	0x40021000

08001934 <RCC_HSICmd>:
  */
void RCC_HSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 8001934:	4b01      	ldr	r3, [pc, #4]	; (800193c <RCC_HSICmd+0x8>)
 8001936:	6018      	str	r0, [r3, #0]
 8001938:	4770      	bx	lr
 800193a:	bf00      	nop
 800193c:	42420000 	.word	0x42420000

08001940 <RCC_PLLConfig>:

  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));

  tmpreg = RCC->CFGR;
 8001940:	4a03      	ldr	r2, [pc, #12]	; (8001950 <RCC_PLLConfig+0x10>)
 8001942:	6853      	ldr	r3, [r2, #4]
  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  tmpreg &= CFGR_PLL_Mask;
 8001944:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 8001948:	4319      	orrs	r1, r3
  /* Set the PLL configuration bits */
  tmpreg |= RCC_PLLSource | RCC_PLLMul;
 800194a:	4308      	orrs	r0, r1
  /* Store the new value */
  RCC->CFGR = tmpreg;
 800194c:	6050      	str	r0, [r2, #4]
 800194e:	4770      	bx	lr
 8001950:	40021000 	.word	0x40021000

08001954 <RCC_PLLCmd>:
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 8001954:	4b01      	ldr	r3, [pc, #4]	; (800195c <RCC_PLLCmd+0x8>)
 8001956:	6018      	str	r0, [r3, #0]
 8001958:	4770      	bx	lr
 800195a:	bf00      	nop
 800195c:	42420060 	.word	0x42420060

08001960 <RCC_SYSCLKConfig>:
void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
  tmpreg = RCC->CFGR;
 8001960:	4a03      	ldr	r2, [pc, #12]	; (8001970 <RCC_SYSCLKConfig+0x10>)
 8001962:	6853      	ldr	r3, [r2, #4]
  /* Clear SW[1:0] bits */
  tmpreg &= CFGR_SW_Mask;
 8001964:	f023 0303 	bic.w	r3, r3, #3
  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 8001968:	4318      	orrs	r0, r3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 800196a:	6050      	str	r0, [r2, #4]
 800196c:	4770      	bx	lr
 800196e:	bf00      	nop
 8001970:	40021000 	.word	0x40021000

08001974 <RCC_GetSYSCLKSource>:
  *     - 0x04: HSE used as system clock
  *     - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
 8001974:	4b02      	ldr	r3, [pc, #8]	; (8001980 <RCC_GetSYSCLKSource+0xc>)
 8001976:	6858      	ldr	r0, [r3, #4]
}
 8001978:	f000 000c 	and.w	r0, r0, #12
 800197c:	4770      	bx	lr
 800197e:	bf00      	nop
 8001980:	40021000 	.word	0x40021000

08001984 <RCC_HCLKConfig>:
void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  tmpreg = RCC->CFGR;
 8001984:	4a03      	ldr	r2, [pc, #12]	; (8001994 <RCC_HCLKConfig+0x10>)
 8001986:	6853      	ldr	r3, [r2, #4]
  /* Clear HPRE[3:0] bits */
  tmpreg &= CFGR_HPRE_Reset_Mask;
 8001988:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 800198c:	4318      	orrs	r0, r3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 800198e:	6050      	str	r0, [r2, #4]
 8001990:	4770      	bx	lr
 8001992:	bf00      	nop
 8001994:	40021000 	.word	0x40021000

08001998 <RCC_PCLK1Config>:
void RCC_PCLK1Config(uint32_t RCC_HCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 8001998:	4a03      	ldr	r2, [pc, #12]	; (80019a8 <RCC_PCLK1Config+0x10>)
 800199a:	6853      	ldr	r3, [r2, #4]
  /* Clear PPRE1[2:0] bits */
  tmpreg &= CFGR_PPRE1_Reset_Mask;
 800199c:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 80019a0:	4318      	orrs	r0, r3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80019a2:	6050      	str	r0, [r2, #4]
 80019a4:	4770      	bx	lr
 80019a6:	bf00      	nop
 80019a8:	40021000 	.word	0x40021000

080019ac <RCC_PCLK2Config>:
void RCC_PCLK2Config(uint32_t RCC_HCLK)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 80019ac:	4a03      	ldr	r2, [pc, #12]	; (80019bc <RCC_PCLK2Config+0x10>)
 80019ae:	6853      	ldr	r3, [r2, #4]
  /* Clear PPRE2[2:0] bits */
  tmpreg &= CFGR_PPRE2_Reset_Mask;
 80019b0:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 80019b4:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80019b8:	6050      	str	r0, [r2, #4]
 80019ba:	4770      	bx	lr
 80019bc:	40021000 	.word	0x40021000

080019c0 <RCC_ITConfig>:
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 80019c0:	4a04      	ldr	r2, [pc, #16]	; (80019d4 <RCC_ITConfig+0x14>)
 80019c2:	7813      	ldrb	r3, [r2, #0]
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80019c4:	b919      	cbnz	r1, 80019ce <RCC_ITConfig+0xe>
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
  }
  else
  {
    /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 80019c6:	ea23 0000 	bic.w	r0, r3, r0
 80019ca:	7010      	strb	r0, [r2, #0]
 80019cc:	4770      	bx	lr
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 80019ce:	4318      	orrs	r0, r3
 80019d0:	7010      	strb	r0, [r2, #0]
 80019d2:	4770      	bx	lr
 80019d4:	40021009 	.word	0x40021009

080019d8 <RCC_USBCLKConfig>:
void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));

  *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
 80019d8:	4b01      	ldr	r3, [pc, #4]	; (80019e0 <RCC_USBCLKConfig+0x8>)
 80019da:	6018      	str	r0, [r3, #0]
 80019dc:	4770      	bx	lr
 80019de:	bf00      	nop
 80019e0:	424200d8 	.word	0x424200d8

080019e4 <RCC_ADCCLKConfig>:
void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
  tmpreg = RCC->CFGR;
 80019e4:	4a03      	ldr	r2, [pc, #12]	; (80019f4 <RCC_ADCCLKConfig+0x10>)
 80019e6:	6853      	ldr	r3, [r2, #4]
  /* Clear ADCPRE[1:0] bits */
  tmpreg &= CFGR_ADCPRE_Reset_Mask;
 80019e8:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
  tmpreg |= RCC_PCLK2;
 80019ec:	4318      	orrs	r0, r3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80019ee:	6050      	str	r0, [r2, #4]
 80019f0:	4770      	bx	lr
 80019f2:	bf00      	nop
 80019f4:	40021000 	.word	0x40021000

080019f8 <RCC_LSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));
  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 80019f8:	4b06      	ldr	r3, [pc, #24]	; (8001a14 <RCC_LSEConfig+0x1c>)
 80019fa:	2200      	movs	r2, #0
  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
 80019fc:	2801      	cmp	r0, #1
{
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));
  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 80019fe:	701a      	strb	r2, [r3, #0]
  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8001a00:	701a      	strb	r2, [r3, #0]
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
 8001a02:	d005      	beq.n	8001a10 <RCC_LSEConfig+0x18>
 8001a04:	2804      	cmp	r0, #4
 8001a06:	d102      	bne.n	8001a0e <RCC_LSEConfig+0x16>
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
      break;
      
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
 8001a08:	2205      	movs	r2, #5
 8001a0a:	701a      	strb	r2, [r3, #0]
 8001a0c:	4770      	bx	lr
 8001a0e:	4770      	bx	lr
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
 8001a10:	7018      	strb	r0, [r3, #0]
      break;
 8001a12:	4770      	bx	lr
 8001a14:	40021020 	.word	0x40021020

08001a18 <RCC_LSICmd>:
  */
void RCC_LSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 8001a18:	4b01      	ldr	r3, [pc, #4]	; (8001a20 <RCC_LSICmd+0x8>)
 8001a1a:	6018      	str	r0, [r3, #0]
 8001a1c:	4770      	bx	lr
 8001a1e:	bf00      	nop
 8001a20:	42420480 	.word	0x42420480

08001a24 <RCC_RTCCLKConfig>:
void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
  /* Select the RTC clock source */
  RCC->BDCR |= RCC_RTCCLKSource;
 8001a24:	4a02      	ldr	r2, [pc, #8]	; (8001a30 <RCC_RTCCLKConfig+0xc>)
 8001a26:	6a13      	ldr	r3, [r2, #32]
 8001a28:	4318      	orrs	r0, r3
 8001a2a:	6210      	str	r0, [r2, #32]
 8001a2c:	4770      	bx	lr
 8001a2e:	bf00      	nop
 8001a30:	40021000 	.word	0x40021000

08001a34 <RCC_RTCCLKCmd>:
  */
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 8001a34:	4b01      	ldr	r3, [pc, #4]	; (8001a3c <RCC_RTCCLKCmd+0x8>)
 8001a36:	6018      	str	r0, [r3, #0]
 8001a38:	4770      	bx	lr
 8001a3a:	bf00      	nop
 8001a3c:	4242043c 	.word	0x4242043c

08001a40 <RCC_GetClocksFreq>:
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
  uint32_t prediv1factor = 0;
#endif
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 8001a40:	4a22      	ldr	r2, [pc, #136]	; (8001acc <RCC_GetClocksFreq+0x8c>)
  * @note   The result of this function could be not correct when using 
  *         fractional value for HSE crystal.  
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8001a42:	b410      	push	{r4}
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
  uint32_t prediv1factor = 0;
#endif
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 8001a44:	6853      	ldr	r3, [r2, #4]
 8001a46:	f003 030c 	and.w	r3, r3, #12
  
  switch (tmp)
 8001a4a:	2b04      	cmp	r3, #4
 8001a4c:	d006      	beq.n	8001a5c <RCC_GetClocksFreq+0x1c>
 8001a4e:	2b08      	cmp	r3, #8
 8001a50:	d026      	beq.n	8001aa0 <RCC_GetClocksFreq+0x60>
 8001a52:	b11b      	cbz	r3, 8001a5c <RCC_GetClocksFreq+0x1c>
      }
#endif /* STM32F10X_CL */ 
      break;

    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8001a54:	4a1e      	ldr	r2, [pc, #120]	; (8001ad0 <RCC_GetClocksFreq+0x90>)
      break;
 8001a56:	4613      	mov	r3, r2
      }
#endif /* STM32F10X_CL */ 
      break;

    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8001a58:	6002      	str	r2, [r0, #0]
      break;
 8001a5a:	e001      	b.n	8001a60 <RCC_GetClocksFreq+0x20>
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 8001a5c:	4b1c      	ldr	r3, [pc, #112]	; (8001ad0 <RCC_GetClocksFreq+0x90>)
 8001a5e:	6003      	str	r3, [r0, #0]
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 8001a60:	4a1a      	ldr	r2, [pc, #104]	; (8001acc <RCC_GetClocksFreq+0x8c>)
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
 8001a62:	491c      	ldr	r1, [pc, #112]	; (8001ad4 <RCC_GetClocksFreq+0x94>)
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 8001a64:	6854      	ldr	r4, [r2, #4]
  tmp = tmp >> 4;
 8001a66:	f3c4 1403 	ubfx	r4, r4, #4, #4
  presc = APBAHBPrescTable[tmp];
 8001a6a:	5d0c      	ldrb	r4, [r1, r4]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8001a6c:	40e3      	lsrs	r3, r4
 8001a6e:	6043      	str	r3, [r0, #4]
  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
 8001a70:	6854      	ldr	r4, [r2, #4]
  tmp = tmp >> 8;
 8001a72:	f3c4 2402 	ubfx	r4, r4, #8, #3
  presc = APBAHBPrescTable[tmp];
 8001a76:	5d0c      	ldrb	r4, [r1, r4]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8001a78:	fa23 f404 	lsr.w	r4, r3, r4
 8001a7c:	6084      	str	r4, [r0, #8]
  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
 8001a7e:	6854      	ldr	r4, [r2, #4]
  tmp = tmp >> 11;
 8001a80:	f3c4 24c2 	ubfx	r4, r4, #11, #3
  presc = APBAHBPrescTable[tmp];
 8001a84:	5d0c      	ldrb	r4, [r1, r4]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8001a86:	40e3      	lsrs	r3, r4
 8001a88:	60c3      	str	r3, [r0, #12]
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
 8001a8a:	6852      	ldr	r2, [r2, #4]
  tmp = tmp >> 14;
  presc = ADCPrescTable[tmp];
  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
}
 8001a8c:	f85d 4b04 	ldr.w	r4, [sp], #4
  presc = APBAHBPrescTable[tmp];
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
  tmp = tmp >> 14;
 8001a90:	f3c2 3281 	ubfx	r2, r2, #14, #2
  presc = ADCPrescTable[tmp];
 8001a94:	440a      	add	r2, r1
 8001a96:	7c12      	ldrb	r2, [r2, #16]
  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
 8001a98:	fbb3 f3f2 	udiv	r3, r3, r2
 8001a9c:	6103      	str	r3, [r0, #16]
}
 8001a9e:	4770      	bx	lr
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
      break;
    case 0x08:  /* PLL used as system clock */

      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
 8001aa0:	6853      	ldr	r3, [r2, #4]
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
 8001aa2:	6851      	ldr	r1, [r2, #4]
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
 8001aa4:	f3c3 4383 	ubfx	r3, r3, #18, #4
      
      if (pllsource == 0x00)
 8001aa8:	03c9      	lsls	r1, r1, #15
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
 8001aaa:	f103 0302 	add.w	r3, r3, #2
      
      if (pllsource == 0x00)
 8001aae:	d507      	bpl.n	8001ac0 <RCC_GetClocksFreq+0x80>
       prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
       /* HSE oscillator clock selected as PREDIV1 clock entry */
       RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
 #else
        /* HSE selected as PLL clock entry */
        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
 8001ab0:	6852      	ldr	r2, [r2, #4]
 8001ab2:	0392      	lsls	r2, r2, #14
 8001ab4:	d404      	bmi.n	8001ac0 <RCC_GetClocksFreq+0x80>
        {/* HSE oscillator clock divided by 2 */
          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
        }
        else
        {
          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
 8001ab6:	4a06      	ldr	r2, [pc, #24]	; (8001ad0 <RCC_GetClocksFreq+0x90>)
 8001ab8:	fb02 f303 	mul.w	r3, r2, r3
 8001abc:	6003      	str	r3, [r0, #0]
 8001abe:	e7cf      	b.n	8001a60 <RCC_GetClocksFreq+0x20>
       RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
 #else
        /* HSE selected as PLL clock entry */
        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
        {/* HSE oscillator clock divided by 2 */
          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
 8001ac0:	4a05      	ldr	r2, [pc, #20]	; (8001ad8 <RCC_GetClocksFreq+0x98>)
 8001ac2:	fb02 f303 	mul.w	r3, r2, r3
 8001ac6:	6003      	str	r3, [r0, #0]
 8001ac8:	e7ca      	b.n	8001a60 <RCC_GetClocksFreq+0x20>
 8001aca:	bf00      	nop
 8001acc:	40021000 	.word	0x40021000
 8001ad0:	007a1200 	.word	0x007a1200
 8001ad4:	20000014 	.word	0x20000014
 8001ad8:	003d0900 	.word	0x003d0900

08001adc <RCC_AHBPeriphClockCmd>:
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 8001adc:	4a04      	ldr	r2, [pc, #16]	; (8001af0 <RCC_AHBPeriphClockCmd+0x14>)
 8001ade:	6953      	ldr	r3, [r2, #20]
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001ae0:	b919      	cbnz	r1, 8001aea <RCC_AHBPeriphClockCmd+0xe>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 8001ae2:	ea23 0000 	bic.w	r0, r3, r0
 8001ae6:	6150      	str	r0, [r2, #20]
 8001ae8:	4770      	bx	lr
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 8001aea:	4318      	orrs	r0, r3
 8001aec:	6150      	str	r0, [r2, #20]
 8001aee:	4770      	bx	lr
 8001af0:	40021000 	.word	0x40021000

08001af4 <RCC_APB2PeriphClockCmd>:
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8001af4:	4a04      	ldr	r2, [pc, #16]	; (8001b08 <RCC_APB2PeriphClockCmd+0x14>)
 8001af6:	6993      	ldr	r3, [r2, #24]
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001af8:	b919      	cbnz	r1, 8001b02 <RCC_APB2PeriphClockCmd+0xe>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 8001afa:	ea23 0000 	bic.w	r0, r3, r0
 8001afe:	6190      	str	r0, [r2, #24]
 8001b00:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8001b02:	4318      	orrs	r0, r3
 8001b04:	6190      	str	r0, [r2, #24]
 8001b06:	4770      	bx	lr
 8001b08:	40021000 	.word	0x40021000

08001b0c <RCC_APB1PeriphClockCmd>:
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 8001b0c:	4a04      	ldr	r2, [pc, #16]	; (8001b20 <RCC_APB1PeriphClockCmd+0x14>)
 8001b0e:	69d3      	ldr	r3, [r2, #28]
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001b10:	b919      	cbnz	r1, 8001b1a <RCC_APB1PeriphClockCmd+0xe>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 8001b12:	ea23 0000 	bic.w	r0, r3, r0
 8001b16:	61d0      	str	r0, [r2, #28]
 8001b18:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 8001b1a:	4318      	orrs	r0, r3
 8001b1c:	61d0      	str	r0, [r2, #28]
 8001b1e:	4770      	bx	lr
 8001b20:	40021000 	.word	0x40021000

08001b24 <RCC_APB2PeriphResetCmd>:
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 8001b24:	4a04      	ldr	r2, [pc, #16]	; (8001b38 <RCC_APB2PeriphResetCmd+0x14>)
 8001b26:	68d3      	ldr	r3, [r2, #12]
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001b28:	b919      	cbnz	r1, 8001b32 <RCC_APB2PeriphResetCmd+0xe>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 8001b2a:	ea23 0000 	bic.w	r0, r3, r0
 8001b2e:	60d0      	str	r0, [r2, #12]
 8001b30:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 8001b32:	4318      	orrs	r0, r3
 8001b34:	60d0      	str	r0, [r2, #12]
 8001b36:	4770      	bx	lr
 8001b38:	40021000 	.word	0x40021000

08001b3c <RCC_APB1PeriphResetCmd>:
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 8001b3c:	4a04      	ldr	r2, [pc, #16]	; (8001b50 <RCC_APB1PeriphResetCmd+0x14>)
 8001b3e:	6913      	ldr	r3, [r2, #16]
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001b40:	b919      	cbnz	r1, 8001b4a <RCC_APB1PeriphResetCmd+0xe>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 8001b42:	ea23 0000 	bic.w	r0, r3, r0
 8001b46:	6110      	str	r0, [r2, #16]
 8001b48:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 8001b4a:	4318      	orrs	r0, r3
 8001b4c:	6110      	str	r0, [r2, #16]
 8001b4e:	4770      	bx	lr
 8001b50:	40021000 	.word	0x40021000

08001b54 <RCC_BackupResetCmd>:
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 8001b54:	4b01      	ldr	r3, [pc, #4]	; (8001b5c <RCC_BackupResetCmd+0x8>)
 8001b56:	6018      	str	r0, [r3, #0]
 8001b58:	4770      	bx	lr
 8001b5a:	bf00      	nop
 8001b5c:	42420440 	.word	0x42420440

08001b60 <RCC_ClockSecuritySystemCmd>:
  */
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 8001b60:	4b01      	ldr	r3, [pc, #4]	; (8001b68 <RCC_ClockSecuritySystemCmd+0x8>)
 8001b62:	6018      	str	r0, [r3, #0]
 8001b64:	4770      	bx	lr
 8001b66:	bf00      	nop
 8001b68:	4242004c 	.word	0x4242004c

08001b6c <RCC_MCOConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCO));

  /* Perform Byte access to MCO bits to select the MCO source */
  *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
 8001b6c:	4b01      	ldr	r3, [pc, #4]	; (8001b74 <RCC_MCOConfig+0x8>)
 8001b6e:	7018      	strb	r0, [r3, #0]
 8001b70:	4770      	bx	lr
 8001b72:	bf00      	nop
 8001b74:	40021007 	.word	0x40021007

08001b78 <RCC_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 8001b78:	0943      	lsrs	r3, r0, #5
  if (tmp == 1)               /* The flag to check is in CR register */
 8001b7a:	2b01      	cmp	r3, #1
 8001b7c:	d00b      	beq.n	8001b96 <RCC_GetFlagStatus+0x1e>
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 8001b7e:	2b02      	cmp	r3, #2
  {
    statusreg = RCC->BDCR;
 8001b80:	4b09      	ldr	r3, [pc, #36]	; (8001ba8 <RCC_GetFlagStatus+0x30>)
 8001b82:	bf0c      	ite	eq
 8001b84:	6a1a      	ldreq	r2, [r3, #32]
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8001b86:	6a5a      	ldrne	r2, [r3, #36]	; 0x24
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_Mask;
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 8001b88:	f000 031f 	and.w	r3, r0, #31
 8001b8c:	fa22 f003 	lsr.w	r0, r2, r3
    bitstatus = RESET;
  }

  /* Return the flag status */
  return bitstatus;
}
 8001b90:	f000 0001 	and.w	r0, r0, #1
 8001b94:	4770      	bx	lr

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 8001b96:	4b04      	ldr	r3, [pc, #16]	; (8001ba8 <RCC_GetFlagStatus+0x30>)
 8001b98:	681a      	ldr	r2, [r3, #0]
    statusreg = RCC->CSR;
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_Mask;
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 8001b9a:	f000 031f 	and.w	r3, r0, #31
 8001b9e:	fa22 f003 	lsr.w	r0, r2, r3
    bitstatus = RESET;
  }

  /* Return the flag status */
  return bitstatus;
}
 8001ba2:	f000 0001 	and.w	r0, r0, #1
 8001ba6:	4770      	bx	lr
 8001ba8:	40021000 	.word	0x40021000

08001bac <RCC_ClearFlag>:
  * @retval None
  */
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= CSR_RMVF_Set;
 8001bac:	4a02      	ldr	r2, [pc, #8]	; (8001bb8 <RCC_ClearFlag+0xc>)
 8001bae:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8001bb0:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001bb4:	6253      	str	r3, [r2, #36]	; 0x24
 8001bb6:	4770      	bx	lr
 8001bb8:	40021000 	.word	0x40021000

08001bbc <RCC_GetITStatus>:
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 8001bbc:	4b03      	ldr	r3, [pc, #12]	; (8001bcc <RCC_GetITStatus+0x10>)
 8001bbe:	689b      	ldr	r3, [r3, #8]
 8001bc0:	4218      	tst	r0, r3
    bitstatus = RESET;
  }

  /* Return the RCC_IT status */
  return  bitstatus;
}
 8001bc2:	bf14      	ite	ne
 8001bc4:	2001      	movne	r0, #1
 8001bc6:	2000      	moveq	r0, #0
 8001bc8:	4770      	bx	lr
 8001bca:	bf00      	nop
 8001bcc:	40021000 	.word	0x40021000

08001bd0 <RCC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 8001bd0:	4b01      	ldr	r3, [pc, #4]	; (8001bd8 <RCC_ClearITPendingBit+0x8>)
 8001bd2:	7018      	strb	r0, [r3, #0]
 8001bd4:	4770      	bx	lr
 8001bd6:	bf00      	nop
 8001bd8:	4002100a 	.word	0x4002100a

08001bdc <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 8001bdc:	489b      	ldr	r0, [pc, #620]	; (8001e4c <vPortValidateInterruptPriority+0x40>)
 8001bde:	6800      	ldr	r0, [r0, #0]
 8001be0:	6800      	ldr	r0, [r0, #0]
 8001be2:	f380 8808 	msr	MSP, r0
 8001be6:	b662      	cpsie	i
 8001be8:	b661      	cpsie	f
 8001bea:	f3bf 8f4f 	dsb	sy
 8001bee:	f3bf 8f6f 	isb	sy
 8001bf2:	df00      	svc	0
 8001bf4:	bf00      	nop
 8001bf6:	bf00      	nop

08001bf8 <pxPortInitialiseStack>:
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8001bf8:	4b07      	ldr	r3, [pc, #28]	; (8001c18 <pxPortInitialiseStack+0x20>)

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
 8001bfa:	b410      	push	{r4}
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8001bfc:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
 8001c00:	f840 4c04 	str.w	r4, [r0, #-4]
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
 8001c04:	f840 1c08 	str.w	r1, [r0, #-8]
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8001c08:	f840 2c20 	str.w	r2, [r0, #-32]
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8001c0c:	f840 3c0c 	str.w	r3, [r0, #-12]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */

	return pxTopOfStack;
}
 8001c10:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001c14:	3840      	subs	r0, #64	; 0x40
 8001c16:	4770      	bx	lr
 8001c18:	08001c69 	.word	0x08001c69

08001c1c <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8001c1c:	4b07      	ldr	r3, [pc, #28]	; (8001c3c <pxCurrentTCBConst2>)
 8001c1e:	6819      	ldr	r1, [r3, #0]
 8001c20:	6808      	ldr	r0, [r1, #0]
 8001c22:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8001c26:	f380 8809 	msr	PSP, r0
 8001c2a:	f3bf 8f6f 	isb	sy
 8001c2e:	f04f 0000 	mov.w	r0, #0
 8001c32:	f380 8811 	msr	BASEPRI, r0
 8001c36:	f04e 0e0d 	orr.w	lr, lr, #13
 8001c3a:	4770      	bx	lr

08001c3c <pxCurrentTCBConst2>:
 8001c3c:	20000114 	.word	0x20000114

08001c40 <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void )
{
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8001c40:	4b04      	ldr	r3, [pc, #16]	; (8001c54 <vPortYield+0x14>)
 8001c42:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001c46:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
 8001c48:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 8001c4c:	f3bf 8f6f 	isb	sy
 8001c50:	4770      	bx	lr
 8001c52:	bf00      	nop
 8001c54:	e000ed04 	.word	0xe000ed04

08001c58 <ulPortSetInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) uint32_t ulPortSetInterruptMask( void )
{
	__asm volatile														\
 8001c58:	f3ef 8011 	mrs	r0, BASEPRI
 8001c5c:	f04f 0150 	mov.w	r1, #80	; 0x50
 8001c60:	f381 8811 	msr	BASEPRI, r1
 8001c64:	4770      	bx	lr
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return 0;
}
 8001c66:	2000      	movs	r0, #0

08001c68 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 8001c68:	b508      	push	{r3, lr}
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 8001c6a:	4b05      	ldr	r3, [pc, #20]	; (8001c80 <prvTaskExitError+0x18>)
 8001c6c:	681b      	ldr	r3, [r3, #0]
 8001c6e:	3301      	adds	r3, #1
 8001c70:	d002      	beq.n	8001c78 <prvTaskExitError+0x10>
 8001c72:	f7ff fff1 	bl	8001c58 <ulPortSetInterruptMask>
 8001c76:	e7fe      	b.n	8001c76 <prvTaskExitError+0xe>
	portDISABLE_INTERRUPTS();
 8001c78:	f7ff ffee 	bl	8001c58 <ulPortSetInterruptMask>
	for( ;; );
 8001c7c:	e7fe      	b.n	8001c7c <prvTaskExitError+0x14>
 8001c7e:	bf00      	nop
 8001c80:	20000028 	.word	0x20000028

08001c84 <vPortEndScheduler>:
	return 0;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 8001c84:	b508      	push	{r3, lr}
	/* Not implemented in ports where there is nothing to return to.
	Artificially force an assert. */
	configASSERT( uxCriticalNesting == 1000UL );
 8001c86:	4b04      	ldr	r3, [pc, #16]	; (8001c98 <vPortEndScheduler+0x14>)
 8001c88:	681b      	ldr	r3, [r3, #0]
 8001c8a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8001c8e:	d002      	beq.n	8001c96 <vPortEndScheduler+0x12>
 8001c90:	f7ff ffe2 	bl	8001c58 <ulPortSetInterruptMask>
 8001c94:	e7fe      	b.n	8001c94 <vPortEndScheduler+0x10>
 8001c96:	bd08      	pop	{r3, pc}
 8001c98:	20000028 	.word	0x20000028

08001c9c <vPortEnterCritical>:
	__asm volatile( "isb" );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 8001c9c:	b508      	push	{r3, lr}
	portDISABLE_INTERRUPTS();
 8001c9e:	f7ff ffdb 	bl	8001c58 <ulPortSetInterruptMask>
	uxCriticalNesting++;
 8001ca2:	4a09      	ldr	r2, [pc, #36]	; (8001cc8 <vPortEnterCritical+0x2c>)
 8001ca4:	6813      	ldr	r3, [r2, #0]
 8001ca6:	3301      	adds	r3, #1
 8001ca8:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" );
 8001caa:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 8001cae:	f3bf 8f6f 	isb	sy
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API 
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
 8001cb2:	2b01      	cmp	r3, #1
 8001cb4:	d000      	beq.n	8001cb8 <vPortEnterCritical+0x1c>
 8001cb6:	bd08      	pop	{r3, pc}
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8001cb8:	4b04      	ldr	r3, [pc, #16]	; (8001ccc <vPortEnterCritical+0x30>)
 8001cba:	681b      	ldr	r3, [r3, #0]
 8001cbc:	f013 0fff 	tst.w	r3, #255	; 0xff
 8001cc0:	d0f9      	beq.n	8001cb6 <vPortEnterCritical+0x1a>
 8001cc2:	f7ff ffc9 	bl	8001c58 <ulPortSetInterruptMask>
 8001cc6:	e7fe      	b.n	8001cc6 <vPortEnterCritical+0x2a>
 8001cc8:	20000028 	.word	0x20000028
 8001ccc:	e000ed04 	.word	0xe000ed04

08001cd0 <vPortClearInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) void vPortClearInterruptMask( uint32_t ulNewMaskValue )
{
	__asm volatile													\
 8001cd0:	f380 8811 	msr	BASEPRI, r0
 8001cd4:	4770      	bx	lr
 8001cd6:	bf00      	nop

08001cd8 <vPortExitCritical>:
	}
}
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 8001cd8:	b508      	push	{r3, lr}
	configASSERT( uxCriticalNesting );
 8001cda:	4b07      	ldr	r3, [pc, #28]	; (8001cf8 <vPortExitCritical+0x20>)
 8001cdc:	6818      	ldr	r0, [r3, #0]
 8001cde:	b118      	cbz	r0, 8001ce8 <vPortExitCritical+0x10>
	uxCriticalNesting--;
 8001ce0:	3801      	subs	r0, #1
 8001ce2:	6018      	str	r0, [r3, #0]
	if( uxCriticalNesting == 0 )
 8001ce4:	b118      	cbz	r0, 8001cee <vPortExitCritical+0x16>
 8001ce6:	bd08      	pop	{r3, pc}
}
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
 8001ce8:	f7ff ffb6 	bl	8001c58 <ulPortSetInterruptMask>
 8001cec:	e7fe      	b.n	8001cec <vPortExitCritical+0x14>
	uxCriticalNesting--;
	if( uxCriticalNesting == 0 )
	{
		portENABLE_INTERRUPTS();
	}
}
 8001cee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
	configASSERT( uxCriticalNesting );
	uxCriticalNesting--;
	if( uxCriticalNesting == 0 )
	{
		portENABLE_INTERRUPTS();
 8001cf2:	f7ff bfed 	b.w	8001cd0 <vPortClearInterruptMask>
 8001cf6:	bf00      	nop
 8001cf8:	20000028 	.word	0x20000028

08001cfc <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8001cfc:	f3ef 8009 	mrs	r0, PSP
 8001d00:	f3bf 8f6f 	isb	sy
 8001d04:	4b0d      	ldr	r3, [pc, #52]	; (8001d3c <pxCurrentTCBConst>)
 8001d06:	681a      	ldr	r2, [r3, #0]
 8001d08:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8001d0c:	6010      	str	r0, [r2, #0]
 8001d0e:	e92d 4008 	stmdb	sp!, {r3, lr}
 8001d12:	f04f 0050 	mov.w	r0, #80	; 0x50
 8001d16:	f380 8811 	msr	BASEPRI, r0
 8001d1a:	f001 fb21 	bl	8003360 <vTaskSwitchContext>
 8001d1e:	f04f 0000 	mov.w	r0, #0
 8001d22:	f380 8811 	msr	BASEPRI, r0
 8001d26:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8001d2a:	6819      	ldr	r1, [r3, #0]
 8001d2c:	6808      	ldr	r0, [r1, #0]
 8001d2e:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8001d32:	f380 8809 	msr	PSP, r0
 8001d36:	f3bf 8f6f 	isb	sy
 8001d3a:	4770      	bx	lr

08001d3c <pxCurrentTCBConst>:
 8001d3c:	20000114 	.word	0x20000114

08001d40 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8001d40:	b508      	push	{r3, lr}
	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. */
	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
 8001d42:	f7ff ff89 	bl	8001c58 <ulPortSetInterruptMask>
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 8001d46:	f001 f925 	bl	8002f94 <xTaskIncrementTick>
 8001d4a:	b118      	cbz	r0, 8001d54 <SysTick_Handler+0x14>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8001d4c:	4b04      	ldr	r3, [pc, #16]	; (8001d60 <SysTick_Handler+0x20>)
 8001d4e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001d52:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
 8001d54:	2000      	movs	r0, #0
}
 8001d56:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
 8001d5a:	f7ff bfb9 	b.w	8001cd0 <vPortClearInterruptMask>
 8001d5e:	bf00      	nop
 8001d60:	e000ed04 	.word	0xe000ed04

08001d64 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8001d64:	f645 50bf 	movw	r0, #23999	; 0x5dbf
 8001d68:	4902      	ldr	r1, [pc, #8]	; (8001d74 <vPortSetupTimerInterrupt+0x10>)
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8001d6a:	4b03      	ldr	r3, [pc, #12]	; (8001d78 <vPortSetupTimerInterrupt+0x14>)
 8001d6c:	2207      	movs	r2, #7
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8001d6e:	6008      	str	r0, [r1, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8001d70:	601a      	str	r2, [r3, #0]
 8001d72:	4770      	bx	lr
 8001d74:	e000e014 	.word	0xe000e014
 8001d78:	e000e010 	.word	0xe000e010

08001d7c <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
 8001d7c:	b510      	push	{r4, lr}
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8001d7e:	4b1f      	ldr	r3, [pc, #124]	; (8001dfc <xPortStartScheduler+0x80>)

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
 8001d80:	b082      	sub	sp, #8
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8001d82:	781a      	ldrb	r2, [r3, #0]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8001d84:	21ff      	movs	r1, #255	; 0xff
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8001d86:	b2d2      	uxtb	r2, r2
 8001d88:	9201      	str	r2, [sp, #4]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8001d8a:	7019      	strb	r1, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8001d8c:	781b      	ldrb	r3, [r3, #0]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8001d8e:	481c      	ldr	r0, [pc, #112]	; (8001e00 <xPortStartScheduler+0x84>)
		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8001d90:	b2db      	uxtb	r3, r3
 8001d92:	f88d 3003 	strb.w	r3, [sp, #3]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8001d96:	f89d 3003 	ldrb.w	r3, [sp, #3]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8001d9a:	f89d 1003 	ldrb.w	r1, [sp, #3]
		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8001d9e:	2207      	movs	r2, #7

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8001da0:	f003 0350 	and.w	r3, r3, #80	; 0x50

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8001da4:	0609      	lsls	r1, r1, #24

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8001da6:	7003      	strb	r3, [r0, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8001da8:	6042      	str	r2, [r0, #4]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8001daa:	d50d      	bpl.n	8001dc8 <xPortStartScheduler+0x4c>
 8001dac:	2206      	movs	r2, #6
 8001dae:	e000      	b.n	8001db2 <xPortStartScheduler+0x36>
 8001db0:	460a      	mov	r2, r1
		{
			ulMaxPRIGROUPValue--;
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 8001db2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001db6:	1e51      	subs	r1, r2, #1
 8001db8:	005b      	lsls	r3, r3, #1
 8001dba:	b2db      	uxtb	r3, r3
 8001dbc:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8001dc0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001dc4:	061b      	lsls	r3, r3, #24
 8001dc6:	d4f3      	bmi.n	8001db0 <xPortStartScheduler+0x34>
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8001dc8:	9901      	ldr	r1, [sp, #4]
 8001dca:	4c0c      	ldr	r4, [pc, #48]	; (8001dfc <xPortStartScheduler+0x80>)
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8001dcc:	4b0d      	ldr	r3, [pc, #52]	; (8001e04 <xPortStartScheduler+0x88>)
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8001dce:	b2c9      	uxtb	r1, r1
 8001dd0:	7021      	strb	r1, [r4, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8001dd2:	6819      	ldr	r1, [r3, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
		}

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 8001dd4:	0212      	lsls	r2, r2, #8
		*pucFirstUserPriorityRegister = ulOriginalPriority;
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8001dd6:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8001dda:	6019      	str	r1, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8001ddc:	6819      	ldr	r1, [r3, #0]
		}

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8001dde:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8001de2:	f041 4170 	orr.w	r1, r1, #4026531840	; 0xf0000000
 8001de6:	6019      	str	r1, [r3, #0]
		}

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8001de8:	6042      	str	r2, [r0, #4]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
 8001dea:	f7ff ffbb 	bl	8001d64 <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8001dee:	4b06      	ldr	r3, [pc, #24]	; (8001e08 <xPortStartScheduler+0x8c>)
 8001df0:	2200      	movs	r2, #0
 8001df2:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
 8001df4:	f7ff fef2 	bl	8001bdc <prvPortStartFirstTask>

	/* Should never get here as the tasks will now be executing!  Call the task
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS. */
	prvTaskExitError();
 8001df8:	f7ff ff36 	bl	8001c68 <prvTaskExitError>
 8001dfc:	e000e400 	.word	0xe000e400
 8001e00:	20000038 	.word	0x20000038
 8001e04:	e000ed20 	.word	0xe000ed20
 8001e08:	20000028 	.word	0x20000028

08001e0c <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
 8001e0c:	b508      	push	{r3, lr}
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 8001e0e:	f3ef 8205 	mrs	r2, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8001e12:	2a0f      	cmp	r2, #15
 8001e14:	d808      	bhi.n	8001e28 <vPortValidateInterruptPriority+0x1c>
 8001e16:	4b0a      	ldr	r3, [pc, #40]	; (8001e40 <vPortValidateInterruptPriority+0x34>)
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8001e18:	490a      	ldr	r1, [pc, #40]	; (8001e44 <vPortValidateInterruptPriority+0x38>)
 8001e1a:	685a      	ldr	r2, [r3, #4]
 8001e1c:	680b      	ldr	r3, [r1, #0]
 8001e1e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8001e22:	4293      	cmp	r3, r2
 8001e24:	d809      	bhi.n	8001e3a <vPortValidateInterruptPriority+0x2e>
 8001e26:	bd08      	pop	{r3, pc}

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8001e28:	4907      	ldr	r1, [pc, #28]	; (8001e48 <vPortValidateInterruptPriority+0x3c>)
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8001e2a:	4b05      	ldr	r3, [pc, #20]	; (8001e40 <vPortValidateInterruptPriority+0x34>)

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8001e2c:	5c52      	ldrb	r2, [r2, r1]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8001e2e:	7819      	ldrb	r1, [r3, #0]
 8001e30:	4291      	cmp	r1, r2
 8001e32:	d9f1      	bls.n	8001e18 <vPortValidateInterruptPriority+0xc>
 8001e34:	f7ff ff10 	bl	8001c58 <ulPortSetInterruptMask>
 8001e38:	e7fe      	b.n	8001e38 <vPortValidateInterruptPriority+0x2c>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8001e3a:	f7ff ff0d 	bl	8001c58 <ulPortSetInterruptMask>
 8001e3e:	e7fe      	b.n	8001e3e <vPortValidateInterruptPriority+0x32>
 8001e40:	20000038 	.word	0x20000038
 8001e44:	e000ed0c 	.word	0xe000ed0c
 8001e48:	e000e3f0 	.word	0xe000e3f0
 8001e4c:	e000ed08 	.word	0xe000ed08

08001e50 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 8001e50:	b538      	push	{r3, r4, r5, lr}
 8001e52:	4604      	mov	r4, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 8001e54:	f7ff ff22 	bl	8001c9c <vPortEnterCritical>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 8001e58:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8001e5a:	2b00      	cmp	r3, #0
 8001e5c:	dd14      	ble.n	8001e88 <prvUnlockQueue+0x38>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001e5e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001e60:	b193      	cbz	r3, 8001e88 <prvUnlockQueue+0x38>
 8001e62:	f104 0524 	add.w	r5, r4, #36	; 0x24
 8001e66:	e007      	b.n	8001e78 <prvUnlockQueue+0x28>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
 8001e68:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8001e6a:	3b01      	subs	r3, #1
 8001e6c:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 8001e6e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8001e70:	2b00      	cmp	r3, #0
 8001e72:	dd09      	ble.n	8001e88 <prvUnlockQueue+0x38>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001e74:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001e76:	b13b      	cbz	r3, 8001e88 <prvUnlockQueue+0x38>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001e78:	4628      	mov	r0, r5
 8001e7a:	f001 fc19 	bl	80036b0 <xTaskRemoveFromEventList>
 8001e7e:	2800      	cmp	r0, #0
 8001e80:	d0f2      	beq.n	8001e68 <prvUnlockQueue+0x18>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
 8001e82:	f001 fcc9 	bl	8003818 <vTaskMissedYield>
 8001e86:	e7ef      	b.n	8001e68 <prvUnlockQueue+0x18>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
 8001e88:	f04f 33ff 	mov.w	r3, #4294967295
 8001e8c:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
 8001e8e:	f7ff ff23 	bl	8001cd8 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8001e92:	f7ff ff03 	bl	8001c9c <vPortEnterCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8001e96:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001e98:	2b00      	cmp	r3, #0
 8001e9a:	dd14      	ble.n	8001ec6 <prvUnlockQueue+0x76>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001e9c:	6923      	ldr	r3, [r4, #16]
 8001e9e:	b193      	cbz	r3, 8001ec6 <prvUnlockQueue+0x76>
 8001ea0:	f104 0510 	add.w	r5, r4, #16
 8001ea4:	e007      	b.n	8001eb6 <prvUnlockQueue+0x66>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
 8001ea6:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001ea8:	3b01      	subs	r3, #1
 8001eaa:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8001eac:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001eae:	2b00      	cmp	r3, #0
 8001eb0:	dd09      	ble.n	8001ec6 <prvUnlockQueue+0x76>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001eb2:	6923      	ldr	r3, [r4, #16]
 8001eb4:	b13b      	cbz	r3, 8001ec6 <prvUnlockQueue+0x76>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001eb6:	4628      	mov	r0, r5
 8001eb8:	f001 fbfa 	bl	80036b0 <xTaskRemoveFromEventList>
 8001ebc:	2800      	cmp	r0, #0
 8001ebe:	d0f2      	beq.n	8001ea6 <prvUnlockQueue+0x56>
				{
					vTaskMissedYield();
 8001ec0:	f001 fcaa 	bl	8003818 <vTaskMissedYield>
 8001ec4:	e7ef      	b.n	8001ea6 <prvUnlockQueue+0x56>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
 8001ec6:	f04f 33ff 	mov.w	r3, #4294967295
 8001eca:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
}
 8001ecc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
	}
	taskEXIT_CRITICAL();
 8001ed0:	f7ff bf02 	b.w	8001cd8 <vPortExitCritical>

08001ed4 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
 8001ed4:	b570      	push	{r4, r5, r6, lr}
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
 8001ed6:	4604      	mov	r4, r0
 8001ed8:	b390      	cbz	r0, 8001f40 <xQueueGenericReset+0x6c>
 8001eda:	460e      	mov	r6, r1

	taskENTER_CRITICAL();
 8001edc:	f7ff fede 	bl	8001c9c <vPortEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8001ee0:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8001ee2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001ee4:	6820      	ldr	r0, [r4, #0]
 8001ee6:	fb03 f302 	mul.w	r3, r3, r2
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8001eea:	1a9a      	subs	r2, r3, r2
		pxQueue->xRxLock = queueUNLOCKED;
 8001eec:	f04f 35ff 	mov.w	r5, #4294967295
	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8001ef0:	4402      	add	r2, r0

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8001ef2:	4403      	add	r3, r0
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8001ef4:	2100      	movs	r1, #0
 8001ef6:	63a1      	str	r1, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8001ef8:	60e2      	str	r2, [r4, #12]
		pxQueue->xRxLock = queueUNLOCKED;
 8001efa:	6465      	str	r5, [r4, #68]	; 0x44

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8001efc:	6063      	str	r3, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8001efe:	60a0      	str	r0, [r4, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
		pxQueue->xRxLock = queueUNLOCKED;
		pxQueue->xTxLock = queueUNLOCKED;
 8001f00:	64a5      	str	r5, [r4, #72]	; 0x48

		if( xNewQueue == pdFALSE )
 8001f02:	b98e      	cbnz	r6, 8001f28 <xQueueGenericReset+0x54>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001f04:	6923      	ldr	r3, [r4, #16]
 8001f06:	b91b      	cbnz	r3, 8001f10 <xQueueGenericReset+0x3c>
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
		}
	}
	taskEXIT_CRITICAL();
 8001f08:	f7ff fee6 	bl	8001cd8 <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
 8001f0c:	2001      	movs	r0, #1
 8001f0e:	bd70      	pop	{r4, r5, r6, pc}
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 8001f10:	f104 0010 	add.w	r0, r4, #16
 8001f14:	f001 fbcc 	bl	80036b0 <xTaskRemoveFromEventList>
 8001f18:	2801      	cmp	r0, #1
 8001f1a:	d1f5      	bne.n	8001f08 <xQueueGenericReset+0x34>
				{
					queueYIELD_IF_USING_PREEMPTION();
 8001f1c:	f7ff fe90 	bl	8001c40 <vPortYield>
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
		}
	}
	taskEXIT_CRITICAL();
 8001f20:	f7ff feda 	bl	8001cd8 <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
 8001f24:	2001      	movs	r0, #1
 8001f26:	bd70      	pop	{r4, r5, r6, pc}
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8001f28:	f104 0010 	add.w	r0, r4, #16
 8001f2c:	f002 fa1c 	bl	8004368 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8001f30:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8001f34:	f002 fa18 	bl	8004368 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 8001f38:	f7ff fece 	bl	8001cd8 <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
 8001f3c:	2001      	movs	r0, #1
 8001f3e:	bd70      	pop	{r4, r5, r6, pc}

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
 8001f40:	f7ff fe8a 	bl	8001c58 <ulPortSetInterruptMask>
 8001f44:	e7fe      	b.n	8001f44 <xQueueGenericReset+0x70>
 8001f46:	bf00      	nop

08001f48 <xQueueGenericCreate>:
	return pdPASS;
}
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
 8001f48:	b570      	push	{r4, r5, r6, lr}

	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8001f4a:	4605      	mov	r5, r0
 8001f4c:	b360      	cbz	r0, 8001fa8 <xQueueGenericCreate+0x60>
 8001f4e:	460e      	mov	r6, r1

	if( uxItemSize == ( UBaseType_t ) 0 )
 8001f50:	b369      	cbz	r1, 8001fae <xQueueGenericCreate+0x66>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001f52:	fb01 f000 	mul.w	r0, r1, r0
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 8001f56:	304d      	adds	r0, #77	; 0x4d
 8001f58:	f002 f9be 	bl	80042d8 <pvPortMalloc>

	if( pxNewQueue != NULL )
 8001f5c:	4604      	mov	r4, r0
 8001f5e:	b368      	cbz	r0, 8001fbc <xQueueGenericCreate+0x74>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
 8001f60:	f100 034c 	add.w	r3, r0, #76	; 0x4c
 8001f64:	6023      	str	r3, [r4, #0]
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
 8001f66:	63e5      	str	r5, [r4, #60]	; 0x3c
		pxNewQueue->uxItemSize = uxItemSize;
 8001f68:	6426      	str	r6, [r4, #64]	; 0x40
{
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
 8001f6a:	f7ff fe97 	bl	8001c9c <vPortEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8001f6e:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8001f70:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001f72:	6821      	ldr	r1, [r4, #0]
 8001f74:	fb03 f302 	mul.w	r3, r3, r2
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8001f78:	1a9a      	subs	r2, r3, r2
 8001f7a:	440a      	add	r2, r1

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8001f7c:	440b      	add	r3, r1
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
		pxQueue->xRxLock = queueUNLOCKED;
 8001f7e:	f04f 35ff 	mov.w	r5, #4294967295
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8001f82:	2000      	movs	r0, #0
 8001f84:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8001f86:	60e2      	str	r2, [r4, #12]

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8001f88:	6063      	str	r3, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8001f8a:	60a1      	str	r1, [r4, #8]
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8001f8c:	f104 0010 	add.w	r0, r4, #16
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
		pxQueue->xRxLock = queueUNLOCKED;
 8001f90:	6465      	str	r5, [r4, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
 8001f92:	64a5      	str	r5, [r4, #72]	; 0x48
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8001f94:	f002 f9e8 	bl	8004368 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8001f98:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8001f9c:	f002 f9e4 	bl	8004368 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 8001fa0:	f7ff fe9a 	bl	8001cd8 <vPortExitCritical>
	}

	configASSERT( xReturn );

	return xReturn;
}
 8001fa4:	4620      	mov	r0, r4
 8001fa6:	bd70      	pop	{r4, r5, r6, pc}

	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8001fa8:	f7ff fe56 	bl	8001c58 <ulPortSetInterruptMask>
 8001fac:	e7fe      	b.n	8001fac <xQueueGenericCreate+0x64>
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 8001fae:	204c      	movs	r0, #76	; 0x4c
 8001fb0:	f002 f992 	bl	80042d8 <pvPortMalloc>

	if( pxNewQueue != NULL )
 8001fb4:	4604      	mov	r4, r0
 8001fb6:	4603      	mov	r3, r0
 8001fb8:	2800      	cmp	r0, #0
 8001fba:	d1d3      	bne.n	8001f64 <xQueueGenericCreate+0x1c>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
 8001fbc:	f7ff fe4c 	bl	8001c58 <ulPortSetInterruptMask>
 8001fc0:	e7fe      	b.n	8001fc0 <xQueueGenericCreate+0x78>
 8001fc2:	bf00      	nop

08001fc4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 8001fc4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8001fc8:	b085      	sub	sp, #20
 8001fca:	9201      	str	r2, [sp, #4]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
 8001fcc:	4604      	mov	r4, r0
 8001fce:	2800      	cmp	r0, #0
 8001fd0:	f000 80f7 	beq.w	80021c2 <xQueueGenericSend+0x1fe>
 8001fd4:	460d      	mov	r5, r1
 8001fd6:	461e      	mov	r6, r3
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8001fd8:	2900      	cmp	r1, #0
 8001fda:	f000 814f 	beq.w	800227c <xQueueGenericSend+0x2b8>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8001fde:	2e02      	cmp	r6, #2
 8001fe0:	d056      	beq.n	8002090 <xQueueGenericSend+0xcc>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8001fe2:	f001 fc27 	bl	8003834 <xTaskGetSchedulerState>
 8001fe6:	b918      	cbnz	r0, 8001ff0 <xQueueGenericSend+0x2c>
 8001fe8:	9b01      	ldr	r3, [sp, #4]
 8001fea:	2b00      	cmp	r3, #0
 8001fec:	f040 8143 	bne.w	8002276 <xQueueGenericSend+0x2b2>
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 8001ff0:	f7ff fe54 	bl	8001c9c <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8001ff4:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8001ff6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001ff8:	f04f 0900 	mov.w	r9, #0
 8001ffc:	429a      	cmp	r2, r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
 8001ffe:	f04f 0700 	mov.w	r7, #0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8002002:	d379      	bcc.n	80020f8 <xQueueGenericSend+0x134>
 8002004:	2e02      	cmp	r6, #2
 8002006:	f000 80ee 	beq.w	80021e6 <xQueueGenericSend+0x222>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 800200a:	f8dd 8004 	ldr.w	r8, [sp, #4]
 800200e:	f1b8 0f00 	cmp.w	r8, #0
 8002012:	f000 80e2 	beq.w	80021da <xQueueGenericSend+0x216>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
 8002016:	f1b9 0f00 	cmp.w	r9, #0
 800201a:	f000 80ce 	beq.w	80021ba <xQueueGenericSend+0x1f6>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 800201e:	f7ff fe5b 	bl	8001cd8 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 8002022:	f000 ff97 	bl	8002f54 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8002026:	f7ff fe39 	bl	8001c9c <vPortEnterCritical>
 800202a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800202c:	3301      	adds	r3, #1
 800202e:	bf08      	it	eq
 8002030:	6467      	streq	r7, [r4, #68]	; 0x44
 8002032:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8002034:	3301      	adds	r3, #1
 8002036:	bf08      	it	eq
 8002038:	64a7      	streq	r7, [r4, #72]	; 0x48
 800203a:	f7ff fe4d 	bl	8001cd8 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800203e:	a802      	add	r0, sp, #8
 8002040:	a901      	add	r1, sp, #4
 8002042:	f001 fbb1 	bl	80037a8 <xTaskCheckForTimeOut>
 8002046:	2800      	cmp	r0, #0
 8002048:	f040 80be 	bne.w	80021c8 <xQueueGenericSend+0x204>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 800204c:	f7ff fe26 	bl	8001c9c <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8002050:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8002052:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8002054:	429a      	cmp	r2, r3
 8002056:	d067      	beq.n	8002128 <xQueueGenericSend+0x164>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8002058:	f7ff fe3e 	bl	8001cd8 <vPortExitCritical>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 800205c:	f7ff fe1e 	bl	8001c9c <vPortEnterCritical>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 8002060:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8002062:	2b00      	cmp	r3, #0
 8002064:	dd1a      	ble.n	800209c <xQueueGenericSend+0xd8>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002066:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002068:	b1c3      	cbz	r3, 800209c <xQueueGenericSend+0xd8>
 800206a:	f104 0824 	add.w	r8, r4, #36	; 0x24
 800206e:	e007      	b.n	8002080 <xQueueGenericSend+0xbc>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
 8002070:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8002072:	3b01      	subs	r3, #1
 8002074:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 8002076:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8002078:	2b00      	cmp	r3, #0
 800207a:	dd0f      	ble.n	800209c <xQueueGenericSend+0xd8>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800207c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800207e:	b16b      	cbz	r3, 800209c <xQueueGenericSend+0xd8>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8002080:	4640      	mov	r0, r8
 8002082:	f001 fb15 	bl	80036b0 <xTaskRemoveFromEventList>
 8002086:	2800      	cmp	r0, #0
 8002088:	d0f2      	beq.n	8002070 <xQueueGenericSend+0xac>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
 800208a:	f001 fbc5 	bl	8003818 <vTaskMissedYield>
 800208e:	e7ef      	b.n	8002070 <xQueueGenericSend+0xac>
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8002090:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8002092:	2b01      	cmp	r3, #1
 8002094:	d0a5      	beq.n	8001fe2 <xQueueGenericSend+0x1e>
 8002096:	f7ff fddf 	bl	8001c58 <ulPortSetInterruptMask>
 800209a:	e7fe      	b.n	800209a <xQueueGenericSend+0xd6>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
 800209c:	f04f 33ff 	mov.w	r3, #4294967295
 80020a0:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
 80020a2:	f7ff fe19 	bl	8001cd8 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 80020a6:	f7ff fdf9 	bl	8001c9c <vPortEnterCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 80020aa:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80020ac:	2b00      	cmp	r3, #0
 80020ae:	dd14      	ble.n	80020da <xQueueGenericSend+0x116>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80020b0:	6923      	ldr	r3, [r4, #16]
 80020b2:	b193      	cbz	r3, 80020da <xQueueGenericSend+0x116>
 80020b4:	f104 0810 	add.w	r8, r4, #16
 80020b8:	e007      	b.n	80020ca <xQueueGenericSend+0x106>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
 80020ba:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80020bc:	3b01      	subs	r3, #1
 80020be:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 80020c0:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80020c2:	2b00      	cmp	r3, #0
 80020c4:	dd09      	ble.n	80020da <xQueueGenericSend+0x116>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80020c6:	6923      	ldr	r3, [r4, #16]
 80020c8:	b13b      	cbz	r3, 80020da <xQueueGenericSend+0x116>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80020ca:	4640      	mov	r0, r8
 80020cc:	f001 faf0 	bl	80036b0 <xTaskRemoveFromEventList>
 80020d0:	2800      	cmp	r0, #0
 80020d2:	d0f2      	beq.n	80020ba <xQueueGenericSend+0xf6>
				{
					vTaskMissedYield();
 80020d4:	f001 fba0 	bl	8003818 <vTaskMissedYield>
 80020d8:	e7ef      	b.n	80020ba <xQueueGenericSend+0xf6>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
 80020da:	f04f 33ff 	mov.w	r3, #4294967295
 80020de:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
 80020e0:	f7ff fdfa 	bl	8001cd8 <vPortExitCritical>
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
				( void ) xTaskResumeAll();
 80020e4:	f000 ffe4 	bl	80030b0 <xTaskResumeAll>
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 80020e8:	f7ff fdd8 	bl	8001c9c <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80020ec:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80020ee:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80020f0:	f04f 0901 	mov.w	r9, #1
 80020f4:	429a      	cmp	r2, r3
 80020f6:	d285      	bcs.n	8002004 <xQueueGenericSend+0x40>

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 80020f8:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80020fa:	2a00      	cmp	r2, #0
 80020fc:	f040 8092 	bne.w	8002224 <xQueueGenericSend+0x260>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8002100:	6825      	ldr	r5, [r4, #0]
 8002102:	2d00      	cmp	r5, #0
 8002104:	f040 8083 	bne.w	800220e <xQueueGenericSend+0x24a>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 8002108:	6860      	ldr	r0, [r4, #4]
 800210a:	f001 fbf1 	bl	80038f0 <xTaskPriorityDisinherit>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
 800210e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002110:	6a62      	ldr	r2, [r4, #36]	; 0x24
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
 8002112:	3301      	adds	r3, #1
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
				pxQueue->pxMutexHolder = NULL;
 8002114:	6065      	str	r5, [r4, #4]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
 8002116:	63a3      	str	r3, [r4, #56]	; 0x38
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002118:	2a00      	cmp	r2, #0
 800211a:	f040 80a5 	bne.w	8002268 <xQueueGenericSend+0x2a4>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
 800211e:	2800      	cmp	r0, #0
 8002120:	d07a      	beq.n	8002218 <xQueueGenericSend+0x254>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
 8002122:	f7ff fd8d 	bl	8001c40 <vPortYield>
 8002126:	e077      	b.n	8002218 <xQueueGenericSend+0x254>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8002128:	f104 0810 	add.w	r8, r4, #16
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 800212c:	f7ff fdd4 	bl	8001cd8 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8002130:	4640      	mov	r0, r8
 8002132:	9901      	ldr	r1, [sp, #4]
 8002134:	f001 f9c4 	bl	80034c0 <vTaskPlaceOnEventList>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 8002138:	f7ff fdb0 	bl	8001c9c <vPortEnterCritical>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 800213c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800213e:	2b00      	cmp	r3, #0
 8002140:	dd14      	ble.n	800216c <xQueueGenericSend+0x1a8>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002142:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002144:	b193      	cbz	r3, 800216c <xQueueGenericSend+0x1a8>
 8002146:	f104 0924 	add.w	r9, r4, #36	; 0x24
 800214a:	e007      	b.n	800215c <xQueueGenericSend+0x198>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
 800214c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800214e:	3b01      	subs	r3, #1
 8002150:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 8002152:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8002154:	2b00      	cmp	r3, #0
 8002156:	dd09      	ble.n	800216c <xQueueGenericSend+0x1a8>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002158:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800215a:	b13b      	cbz	r3, 800216c <xQueueGenericSend+0x1a8>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800215c:	4648      	mov	r0, r9
 800215e:	f001 faa7 	bl	80036b0 <xTaskRemoveFromEventList>
 8002162:	2800      	cmp	r0, #0
 8002164:	d0f2      	beq.n	800214c <xQueueGenericSend+0x188>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
 8002166:	f001 fb57 	bl	8003818 <vTaskMissedYield>
 800216a:	e7ef      	b.n	800214c <xQueueGenericSend+0x188>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
 800216c:	f04f 33ff 	mov.w	r3, #4294967295
 8002170:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
 8002172:	f7ff fdb1 	bl	8001cd8 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8002176:	f7ff fd91 	bl	8001c9c <vPortEnterCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 800217a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800217c:	2b00      	cmp	r3, #0
 800217e:	dc06      	bgt.n	800218e <xQueueGenericSend+0x1ca>
 8002180:	e00f      	b.n	80021a2 <xQueueGenericSend+0x1de>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
 8002182:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8002184:	3b01      	subs	r3, #1
 8002186:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8002188:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800218a:	2b00      	cmp	r3, #0
 800218c:	dd09      	ble.n	80021a2 <xQueueGenericSend+0x1de>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800218e:	6923      	ldr	r3, [r4, #16]
 8002190:	b13b      	cbz	r3, 80021a2 <xQueueGenericSend+0x1de>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002192:	4640      	mov	r0, r8
 8002194:	f001 fa8c 	bl	80036b0 <xTaskRemoveFromEventList>
 8002198:	2800      	cmp	r0, #0
 800219a:	d0f2      	beq.n	8002182 <xQueueGenericSend+0x1be>
				{
					vTaskMissedYield();
 800219c:	f001 fb3c 	bl	8003818 <vTaskMissedYield>
 80021a0:	e7ef      	b.n	8002182 <xQueueGenericSend+0x1be>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
 80021a2:	f04f 33ff 	mov.w	r3, #4294967295
 80021a6:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
 80021a8:	f7ff fd96 	bl	8001cd8 <vPortExitCritical>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 80021ac:	f000 ff80 	bl	80030b0 <xTaskResumeAll>
 80021b0:	2800      	cmp	r0, #0
 80021b2:	d199      	bne.n	80020e8 <xQueueGenericSend+0x124>
				{
					portYIELD_WITHIN_API();
 80021b4:	f7ff fd44 	bl	8001c40 <vPortYield>
 80021b8:	e796      	b.n	80020e8 <xQueueGenericSend+0x124>
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 80021ba:	a802      	add	r0, sp, #8
 80021bc:	f001 fae4 	bl	8003788 <vTaskSetTimeOutState>
 80021c0:	e72d      	b.n	800201e <xQueueGenericSend+0x5a>
{
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
 80021c2:	f7ff fd49 	bl	8001c58 <ulPortSetInterruptMask>
 80021c6:	e7fe      	b.n	80021c6 <xQueueGenericSend+0x202>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 80021c8:	4620      	mov	r0, r4
 80021ca:	f7ff fe41 	bl	8001e50 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 80021ce:	f000 ff6f 	bl	80030b0 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 80021d2:	2000      	movs	r0, #0
		}
	}
}
 80021d4:	b005      	add	sp, #20
 80021d6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			{
				if( xTicksToWait == ( TickType_t ) 0 )
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 80021da:	f7ff fd7d 	bl	8001cd8 <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 80021de:	4640      	mov	r0, r8
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
 80021e0:	b005      	add	sp, #20
 80021e2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 80021e6:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80021e8:	2a00      	cmp	r2, #0
 80021ea:	d089      	beq.n	8002100 <xQueueGenericSend+0x13c>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80021ec:	4629      	mov	r1, r5
 80021ee:	68e0      	ldr	r0, [r4, #12]
 80021f0:	f002 face 	bl	8004790 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 80021f4:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80021f6:	68e2      	ldr	r2, [r4, #12]
 80021f8:	425b      	negs	r3, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80021fa:	6821      	ldr	r1, [r4, #0]
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 80021fc:	441a      	add	r2, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80021fe:	428a      	cmp	r2, r1
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8002200:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8002202:	d21e      	bcs.n	8002242 <xQueueGenericSend+0x27e>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8002204:	6862      	ldr	r2, [r4, #4]
 8002206:	4413      	add	r3, r2
 8002208:	60e3      	str	r3, [r4, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
 800220a:	2e02      	cmp	r6, #2
 800220c:	d019      	beq.n	8002242 <xQueueGenericSend+0x27e>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
 800220e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002210:	6a62      	ldr	r2, [r4, #36]	; 0x24
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
 8002212:	3301      	adds	r3, #1
 8002214:	63a3      	str	r3, [r4, #56]	; 0x38
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002216:	bb3a      	cbnz	r2, 8002268 <xQueueGenericSend+0x2a4>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 8002218:	f7ff fd5e 	bl	8001cd8 <vPortExitCritical>
				return pdPASS;
 800221c:	2001      	movs	r0, #1
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
 800221e:	b005      	add	sp, #20
 8002220:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 8002224:	4629      	mov	r1, r5
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 8002226:	b99e      	cbnz	r6, 8002250 <xQueueGenericSend+0x28c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 8002228:	68a0      	ldr	r0, [r4, #8]
 800222a:	f002 fab1 	bl	8004790 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 800222e:	68a1      	ldr	r1, [r4, #8]
 8002230:	6c23      	ldr	r3, [r4, #64]	; 0x40
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8002232:	6862      	ldr	r2, [r4, #4]
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8002234:	440b      	add	r3, r1
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8002236:	4293      	cmp	r3, r2
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8002238:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800223a:	d3e8      	bcc.n	800220e <xQueueGenericSend+0x24a>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 800223c:	6823      	ldr	r3, [r4, #0]
 800223e:	60a3      	str	r3, [r4, #8]
 8002240:	e7e5      	b.n	800220e <xQueueGenericSend+0x24a>
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 8002242:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002244:	2b00      	cmp	r3, #0
 8002246:	d0e2      	beq.n	800220e <xQueueGenericSend+0x24a>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
 8002248:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800224a:	3b01      	subs	r3, #1
 800224c:	63a3      	str	r3, [r4, #56]	; 0x38
 800224e:	e7de      	b.n	800220e <xQueueGenericSend+0x24a>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002250:	68e0      	ldr	r0, [r4, #12]
 8002252:	f002 fa9d 	bl	8004790 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8002256:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8002258:	68e2      	ldr	r2, [r4, #12]
 800225a:	425b      	negs	r3, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800225c:	6821      	ldr	r1, [r4, #0]
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 800225e:	441a      	add	r2, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8002260:	428a      	cmp	r2, r1
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8002262:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8002264:	d2d1      	bcs.n	800220a <xQueueGenericSend+0x246>
 8002266:	e7cd      	b.n	8002204 <xQueueGenericSend+0x240>
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 8002268:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800226c:	f001 fa20 	bl	80036b0 <xTaskRemoveFromEventList>
 8002270:	2801      	cmp	r0, #1
 8002272:	d1d1      	bne.n	8002218 <xQueueGenericSend+0x254>
 8002274:	e755      	b.n	8002122 <xQueueGenericSend+0x15e>
	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8002276:	f7ff fcef 	bl	8001c58 <ulPortSetInterruptMask>
 800227a:	e7fe      	b.n	800227a <xQueueGenericSend+0x2b6>
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800227c:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800227e:	2b00      	cmp	r3, #0
 8002280:	f43f aead 	beq.w	8001fde <xQueueGenericSend+0x1a>
 8002284:	f7ff fce8 	bl	8001c58 <ulPortSetInterruptMask>
 8002288:	e7fe      	b.n	8002288 <xQueueGenericSend+0x2c4>
 800228a:	bf00      	nop

0800228c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
 800228c:	b538      	push	{r3, r4, r5, lr}
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
 800228e:	204c      	movs	r0, #76	; 0x4c
 8002290:	f002 f822 	bl	80042d8 <pvPortMalloc>
		if( pxNewQueue != NULL )
 8002294:	4604      	mov	r4, r0
 8002296:	b1c8      	cbz	r0, 80022cc <xQueueCreateMutex+0x40>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
 8002298:	2500      	movs	r5, #0
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
			pxNewQueue->xRxLock = queueUNLOCKED;
 800229a:	f04f 33ff 	mov.w	r3, #4294967295

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
 800229e:	2201      	movs	r2, #1
			pxNewQueue->u.pcReadFrom = NULL;

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80022a0:	6385      	str	r5, [r0, #56]	; 0x38
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
 80022a2:	63c2      	str	r2, [r0, #60]	; 0x3c
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
			pxNewQueue->xRxLock = queueUNLOCKED;
 80022a4:	6443      	str	r3, [r0, #68]	; 0x44
		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
		if( pxNewQueue != NULL )
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
 80022a6:	6045      	str	r5, [r0, #4]
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
			pxNewQueue->xRxLock = queueUNLOCKED;
			pxNewQueue->xTxLock = queueUNLOCKED;
 80022a8:	6483      	str	r3, [r0, #72]	; 0x48
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
		if( pxNewQueue != NULL )
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 80022aa:	6005      	str	r5, [r0, #0]

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
 80022ac:	6085      	str	r5, [r0, #8]
			pxNewQueue->u.pcReadFrom = NULL;
 80022ae:	60c5      	str	r5, [r0, #12]
			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
 80022b0:	6405      	str	r5, [r0, #64]	; 0x40
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 80022b2:	3010      	adds	r0, #16
 80022b4:	f002 f858 	bl	8004368 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 80022b8:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80022bc:	f002 f854 	bl	8004368 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 80022c0:	4620      	mov	r0, r4
 80022c2:	4629      	mov	r1, r5
 80022c4:	462a      	mov	r2, r5
 80022c6:	462b      	mov	r3, r5
 80022c8:	f7ff fe7c 	bl	8001fc4 <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		return pxNewQueue;
	}
 80022cc:	4620      	mov	r0, r4
 80022ce:	bd38      	pop	{r3, r4, r5, pc}

080022d0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
 80022d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
 80022d4:	4604      	mov	r4, r0
 80022d6:	2800      	cmp	r0, #0
 80022d8:	d032      	beq.n	8002340 <xQueueGenericSendFromISR+0x70>
 80022da:	4688      	mov	r8, r1
 80022dc:	4617      	mov	r7, r2
 80022de:	461d      	mov	r5, r3
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80022e0:	2900      	cmp	r1, #0
 80022e2:	f000 808b 	beq.w	80023fc <xQueueGenericSendFromISR+0x12c>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 80022e6:	2d02      	cmp	r5, #2
 80022e8:	d00f      	beq.n	800230a <xQueueGenericSendFromISR+0x3a>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80022ea:	f7ff fd8f 	bl	8001e0c <vPortValidateInterruptPriority>
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80022ee:	f7ff fcb3 	bl	8001c58 <ulPortSetInterruptMask>
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80022f2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80022f4:	6be2      	ldr	r2, [r4, #60]	; 0x3c
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80022f6:	4606      	mov	r6, r0
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80022f8:	429a      	cmp	r2, r3
 80022fa:	d80c      	bhi.n	8002316 <xQueueGenericSendFromISR+0x46>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 80022fc:	2500      	movs	r5, #0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 80022fe:	4630      	mov	r0, r6
 8002300:	f7ff fce6 	bl	8001cd0 <vPortClearInterruptMask>

	return xReturn;
}
 8002304:	4628      	mov	r0, r5
 8002306:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800230a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800230c:	2b01      	cmp	r3, #1
 800230e:	d03d      	beq.n	800238c <xQueueGenericSendFromISR+0xbc>
 8002310:	f7ff fca2 	bl	8001c58 <ulPortSetInterruptMask>
 8002314:	e7fe      	b.n	8002314 <xQueueGenericSendFromISR+0x44>

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8002316:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8002318:	b9aa      	cbnz	r2, 8002346 <xQueueGenericSendFromISR+0x76>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800231a:	6825      	ldr	r5, [r4, #0]
 800231c:	2d00      	cmp	r5, #0
 800231e:	d068      	beq.n	80023f2 <xQueueGenericSendFromISR+0x122>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
 8002320:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002322:	3301      	adds	r3, #1
 8002324:	63a3      	str	r3, [r4, #56]	; 0x38
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
 8002326:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8002328:	3301      	adds	r3, #1
 800232a:	d01c      	beq.n	8002366 <xQueueGenericSendFromISR+0x96>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
 800232c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
			}

			xReturn = pdPASS;
 800232e:	2501      	movs	r5, #1
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
 8002330:	442b      	add	r3, r5
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8002332:	4630      	mov	r0, r6
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
 8002334:	64a3      	str	r3, [r4, #72]	; 0x48
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8002336:	f7ff fccb 	bl	8001cd0 <vPortClearInterruptMask>

	return xReturn;
}
 800233a:	4628      	mov	r0, r5
 800233c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
 8002340:	f7ff fc8a 	bl	8001c58 <ulPortSetInterruptMask>
 8002344:	e7fe      	b.n	8002344 <xQueueGenericSendFromISR+0x74>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 8002346:	2d00      	cmp	r5, #0
 8002348:	d146      	bne.n	80023d8 <xQueueGenericSendFromISR+0x108>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 800234a:	4641      	mov	r1, r8
 800234c:	68a0      	ldr	r0, [r4, #8]
 800234e:	f002 fa1f 	bl	8004790 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8002352:	68a1      	ldr	r1, [r4, #8]
 8002354:	6c23      	ldr	r3, [r4, #64]	; 0x40
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8002356:	6862      	ldr	r2, [r4, #4]
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8002358:	440b      	add	r3, r1
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800235a:	4293      	cmp	r3, r2
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 800235c:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800235e:	d3df      	bcc.n	8002320 <xQueueGenericSendFromISR+0x50>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8002360:	6823      	ldr	r3, [r4, #0]
 8002362:	60a3      	str	r3, [r4, #8]
 8002364:	e7dc      	b.n	8002320 <xQueueGenericSendFromISR+0x50>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002366:	6a63      	ldr	r3, [r4, #36]	; 0x24
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 8002368:	2501      	movs	r5, #1
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800236a:	2b00      	cmp	r3, #0
 800236c:	d0c7      	beq.n	80022fe <xQueueGenericSendFromISR+0x2e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800236e:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8002372:	f001 f99d 	bl	80036b0 <xTaskRemoveFromEventList>
 8002376:	2800      	cmp	r0, #0
 8002378:	d0c1      	beq.n	80022fe <xQueueGenericSendFromISR+0x2e>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 800237a:	2f00      	cmp	r7, #0
 800237c:	d0bf      	beq.n	80022fe <xQueueGenericSendFromISR+0x2e>
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 800237e:	4630      	mov	r0, r6
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 8002380:	603d      	str	r5, [r7, #0]
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8002382:	f7ff fca5 	bl	8001cd0 <vPortClearInterruptMask>

	return xReturn;
}
 8002386:	4628      	mov	r0, r5
 8002388:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800238c:	f7ff fd3e 	bl	8001e0c <vPortValidateInterruptPriority>
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8002390:	f7ff fc62 	bl	8001c58 <ulPortSetInterruptMask>
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8002394:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8002396:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8002398:	4606      	mov	r6, r0
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800239a:	429a      	cmp	r2, r3

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800239c:	6c22      	ldr	r2, [r4, #64]	; 0x40
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800239e:	d319      	bcc.n	80023d4 <xQueueGenericSendFromISR+0x104>

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 80023a0:	2a00      	cmp	r2, #0
 80023a2:	d0ba      	beq.n	800231a <xQueueGenericSendFromISR+0x4a>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80023a4:	4641      	mov	r1, r8
 80023a6:	68e0      	ldr	r0, [r4, #12]
 80023a8:	f002 f9f2 	bl	8004790 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 80023ac:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80023ae:	68e2      	ldr	r2, [r4, #12]
 80023b0:	425b      	negs	r3, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80023b2:	6821      	ldr	r1, [r4, #0]
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 80023b4:	441a      	add	r2, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80023b6:	428a      	cmp	r2, r1
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 80023b8:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80023ba:	d204      	bcs.n	80023c6 <xQueueGenericSendFromISR+0xf6>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 80023bc:	6862      	ldr	r2, [r4, #4]
 80023be:	4413      	add	r3, r2
 80023c0:	60e3      	str	r3, [r4, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
 80023c2:	2d02      	cmp	r5, #2
 80023c4:	d1ac      	bne.n	8002320 <xQueueGenericSendFromISR+0x50>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 80023c6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80023c8:	2b00      	cmp	r3, #0
 80023ca:	d0a9      	beq.n	8002320 <xQueueGenericSendFromISR+0x50>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
 80023cc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80023ce:	3b01      	subs	r3, #1
 80023d0:	63a3      	str	r3, [r4, #56]	; 0x38
 80023d2:	e7a5      	b.n	8002320 <xQueueGenericSendFromISR+0x50>

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 80023d4:	2a00      	cmp	r2, #0
 80023d6:	d0a0      	beq.n	800231a <xQueueGenericSendFromISR+0x4a>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80023d8:	4641      	mov	r1, r8
 80023da:	68e0      	ldr	r0, [r4, #12]
 80023dc:	f002 f9d8 	bl	8004790 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 80023e0:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80023e2:	68e2      	ldr	r2, [r4, #12]
 80023e4:	425b      	negs	r3, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80023e6:	6821      	ldr	r1, [r4, #0]
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 80023e8:	441a      	add	r2, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80023ea:	428a      	cmp	r2, r1
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 80023ec:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80023ee:	d2e8      	bcs.n	80023c2 <xQueueGenericSendFromISR+0xf2>
 80023f0:	e7e4      	b.n	80023bc <xQueueGenericSendFromISR+0xec>
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 80023f2:	6860      	ldr	r0, [r4, #4]
 80023f4:	f001 fa7c 	bl	80038f0 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 80023f8:	6065      	str	r5, [r4, #4]
 80023fa:	e791      	b.n	8002320 <xQueueGenericSendFromISR+0x50>
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80023fc:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80023fe:	2b00      	cmp	r3, #0
 8002400:	f43f af71 	beq.w	80022e6 <xQueueGenericSendFromISR+0x16>
 8002404:	f7ff fc28 	bl	8001c58 <ulPortSetInterruptMask>
 8002408:	e7fe      	b.n	8002408 <xQueueGenericSendFromISR+0x138>
 800240a:	bf00      	nop

0800240c <xQueueGiveFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
 800240c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	item size is 0.  Don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */

	configASSERT( pxQueue );
 800240e:	4604      	mov	r4, r0
 8002410:	b328      	cbz	r0, 800245e <xQueueGiveFromISR+0x52>

	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
	if the item size is not 0. */
	configASSERT( pxQueue->uxItemSize == 0 );
 8002412:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8002414:	b9d3      	cbnz	r3, 800244c <xQueueGiveFromISR+0x40>

	/* Normally a mutex would not be given from an interrupt, especially if
	there is a mutex holder, as priority inheritance makes no sense for an
	interrupts, only tasks. */
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
 8002416:	6803      	ldr	r3, [r0, #0]
 8002418:	460e      	mov	r6, r1
 800241a:	b33b      	cbz	r3, 800246c <xQueueGiveFromISR+0x60>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800241c:	f7ff fcf6 	bl	8001e0c <vPortValidateInterruptPriority>

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8002420:	f7ff fc1a 	bl	8001c58 <ulPortSetInterruptMask>
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 8002424:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8002426:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8002428:	4607      	mov	r7, r0
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 800242a:	429a      	cmp	r2, r3
 800242c:	d211      	bcs.n	8002452 <xQueueGiveFromISR+0x46>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
 800242e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002430:	3301      	adds	r3, #1
 8002432:	63a3      	str	r3, [r4, #56]	; 0x38

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
 8002434:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8002436:	3301      	adds	r3, #1
 8002438:	d014      	beq.n	8002464 <xQueueGiveFromISR+0x58>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
 800243a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
			}

			xReturn = pdPASS;
 800243c:	2501      	movs	r5, #1
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
 800243e:	442b      	add	r3, r5
 8002440:	64a3      	str	r3, [r4, #72]	; 0x48
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8002442:	4638      	mov	r0, r7
 8002444:	f7ff fc44 	bl	8001cd0 <vPortClearInterruptMask>

	return xReturn;
}
 8002448:	4628      	mov	r0, r5
 800244a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	configASSERT( pxQueue );

	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
	if the item size is not 0. */
	configASSERT( pxQueue->uxItemSize == 0 );
 800244c:	f7ff fc04 	bl	8001c58 <ulPortSetInterruptMask>
 8002450:	e7fe      	b.n	8002450 <xQueueGiveFromISR+0x44>
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8002452:	4638      	mov	r0, r7
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 8002454:	2500      	movs	r5, #0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8002456:	f7ff fc3b 	bl	8001cd0 <vPortClearInterruptMask>

	return xReturn;
}
 800245a:	4628      	mov	r0, r5
 800245c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	item size is 0.  Don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */

	configASSERT( pxQueue );
 800245e:	f7ff fbfb 	bl	8001c58 <ulPortSetInterruptMask>
 8002462:	e7fe      	b.n	8002462 <xQueueGiveFromISR+0x56>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002464:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002466:	b93b      	cbnz	r3, 8002478 <xQueueGiveFromISR+0x6c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
 8002468:	2501      	movs	r5, #1
 800246a:	e7ea      	b.n	8002442 <xQueueGiveFromISR+0x36>
	configASSERT( pxQueue->uxItemSize == 0 );

	/* Normally a mutex would not be given from an interrupt, especially if
	there is a mutex holder, as priority inheritance makes no sense for an
	interrupts, only tasks. */
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
 800246c:	6843      	ldr	r3, [r0, #4]
 800246e:	2b00      	cmp	r3, #0
 8002470:	d0d4      	beq.n	800241c <xQueueGiveFromISR+0x10>
 8002472:	f7ff fbf1 	bl	8001c58 <ulPortSetInterruptMask>
 8002476:	e7fe      	b.n	8002476 <xQueueGiveFromISR+0x6a>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8002478:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800247c:	f001 f918 	bl	80036b0 <xTaskRemoveFromEventList>
 8002480:	2800      	cmp	r0, #0
 8002482:	d0f1      	beq.n	8002468 <xQueueGiveFromISR+0x5c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 8002484:	2e00      	cmp	r6, #0
 8002486:	d0ef      	beq.n	8002468 <xQueueGiveFromISR+0x5c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 8002488:	2501      	movs	r5, #1
 800248a:	6035      	str	r5, [r6, #0]
 800248c:	e7d9      	b.n	8002442 <xQueueGiveFromISR+0x36>
 800248e:	bf00      	nop

08002490 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
 8002490:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002494:	b085      	sub	sp, #20
 8002496:	9201      	str	r2, [sp, #4]
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
 8002498:	4604      	mov	r4, r0
 800249a:	2800      	cmp	r0, #0
 800249c:	f000 80eb 	beq.w	8002676 <xQueueGenericReceive+0x1e6>
 80024a0:	460d      	mov	r5, r1
 80024a2:	461f      	mov	r7, r3
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80024a4:	2900      	cmp	r1, #0
 80024a6:	f000 8117 	beq.w	80026d8 <xQueueGenericReceive+0x248>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80024aa:	f001 f9c3 	bl	8003834 <xTaskGetSchedulerState>
 80024ae:	b918      	cbnz	r0, 80024b8 <xQueueGenericReceive+0x28>
 80024b0:	9b01      	ldr	r3, [sp, #4]
 80024b2:	2b00      	cmp	r3, #0
 80024b4:	f040 810d 	bne.w	80026d2 <xQueueGenericReceive+0x242>
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
 80024b8:	f7ff fbf0 	bl	8001c9c <vPortEnterCritical>
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 80024bc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80024be:	f04f 0900 	mov.w	r9, #0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
 80024c2:	2600      	movs	r6, #0
	{
		taskENTER_CRITICAL();
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 80024c4:	2b00      	cmp	r3, #0
 80024c6:	d177      	bne.n	80025b8 <xQueueGenericReceive+0x128>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 80024c8:	f8dd 8004 	ldr.w	r8, [sp, #4]
 80024cc:	f1b8 0f00 	cmp.w	r8, #0
 80024d0:	f000 80e5 	beq.w	800269e <xQueueGenericReceive+0x20e>
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
 80024d4:	f1b9 0f00 	cmp.w	r9, #0
 80024d8:	f000 80c9 	beq.w	800266e <xQueueGenericReceive+0x1de>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 80024dc:	f7ff fbfc 	bl	8001cd8 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 80024e0:	f000 fd38 	bl	8002f54 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 80024e4:	f7ff fbda 	bl	8001c9c <vPortEnterCritical>
 80024e8:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80024ea:	3301      	adds	r3, #1
 80024ec:	bf08      	it	eq
 80024ee:	6466      	streq	r6, [r4, #68]	; 0x44
 80024f0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80024f2:	3301      	adds	r3, #1
 80024f4:	bf08      	it	eq
 80024f6:	64a6      	streq	r6, [r4, #72]	; 0x48
 80024f8:	f7ff fbee 	bl	8001cd8 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80024fc:	a802      	add	r0, sp, #8
 80024fe:	a901      	add	r1, sp, #4
 8002500:	f001 f952 	bl	80037a8 <xTaskCheckForTimeOut>
 8002504:	2800      	cmp	r0, #0
 8002506:	f040 80c1 	bne.w	800268c <xQueueGenericReceive+0x1fc>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 800250a:	f7ff fbc7 	bl	8001c9c <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 800250e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002510:	2b00      	cmp	r3, #0
 8002512:	d169      	bne.n	80025e8 <xQueueGenericReceive+0x158>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8002514:	f7ff fbe0 	bl	8001cd8 <vPortExitCritical>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8002518:	6823      	ldr	r3, [r4, #0]
 800251a:	2b00      	cmp	r3, #0
 800251c:	f000 80ae 	beq.w	800267c <xQueueGenericReceive+0x1ec>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8002520:	f104 0824 	add.w	r8, r4, #36	; 0x24
 8002524:	4640      	mov	r0, r8
 8002526:	9901      	ldr	r1, [sp, #4]
 8002528:	f000 ffca 	bl	80034c0 <vTaskPlaceOnEventList>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 800252c:	f7ff fbb6 	bl	8001c9c <vPortEnterCritical>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 8002530:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8002532:	2b00      	cmp	r3, #0
 8002534:	dc06      	bgt.n	8002544 <xQueueGenericReceive+0xb4>
 8002536:	e00f      	b.n	8002558 <xQueueGenericReceive+0xc8>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
 8002538:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800253a:	3b01      	subs	r3, #1
 800253c:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 800253e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8002540:	2b00      	cmp	r3, #0
 8002542:	dd09      	ble.n	8002558 <xQueueGenericReceive+0xc8>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002544:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002546:	b13b      	cbz	r3, 8002558 <xQueueGenericReceive+0xc8>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8002548:	4640      	mov	r0, r8
 800254a:	f001 f8b1 	bl	80036b0 <xTaskRemoveFromEventList>
 800254e:	2800      	cmp	r0, #0
 8002550:	d0f2      	beq.n	8002538 <xQueueGenericReceive+0xa8>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
 8002552:	f001 f961 	bl	8003818 <vTaskMissedYield>
 8002556:	e7ef      	b.n	8002538 <xQueueGenericReceive+0xa8>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
 8002558:	f04f 33ff 	mov.w	r3, #4294967295
 800255c:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
 800255e:	f7ff fbbb 	bl	8001cd8 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8002562:	f7ff fb9b 	bl	8001c9c <vPortEnterCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8002566:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8002568:	2b00      	cmp	r3, #0
 800256a:	dd14      	ble.n	8002596 <xQueueGenericReceive+0x106>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800256c:	6923      	ldr	r3, [r4, #16]
 800256e:	b193      	cbz	r3, 8002596 <xQueueGenericReceive+0x106>
 8002570:	f104 0810 	add.w	r8, r4, #16
 8002574:	e007      	b.n	8002586 <xQueueGenericReceive+0xf6>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
 8002576:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8002578:	3b01      	subs	r3, #1
 800257a:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 800257c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800257e:	2b00      	cmp	r3, #0
 8002580:	dd09      	ble.n	8002596 <xQueueGenericReceive+0x106>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8002582:	6923      	ldr	r3, [r4, #16]
 8002584:	b13b      	cbz	r3, 8002596 <xQueueGenericReceive+0x106>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002586:	4640      	mov	r0, r8
 8002588:	f001 f892 	bl	80036b0 <xTaskRemoveFromEventList>
 800258c:	2800      	cmp	r0, #0
 800258e:	d0f2      	beq.n	8002576 <xQueueGenericReceive+0xe6>
				{
					vTaskMissedYield();
 8002590:	f001 f942 	bl	8003818 <vTaskMissedYield>
 8002594:	e7ef      	b.n	8002576 <xQueueGenericReceive+0xe6>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
 8002596:	f04f 33ff 	mov.w	r3, #4294967295
 800259a:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
 800259c:	f7ff fb9c 	bl	8001cd8 <vPortExitCritical>
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
 80025a0:	f000 fd86 	bl	80030b0 <xTaskResumeAll>
 80025a4:	b908      	cbnz	r0, 80025aa <xQueueGenericReceive+0x11a>
				{
					portYIELD_WITHIN_API();
 80025a6:	f7ff fb4b 	bl	8001c40 <vPortYield>
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
 80025aa:	f7ff fb77 	bl	8001c9c <vPortEnterCritical>
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 80025ae:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80025b0:	f04f 0901 	mov.w	r9, #1
 80025b4:	2b00      	cmp	r3, #0
 80025b6:	d087      	beq.n	80024c8 <xQueueGenericReceive+0x38>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 80025b8:	4629      	mov	r1, r5
 80025ba:	4620      	mov	r0, r4
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 80025bc:	68e5      	ldr	r5, [r4, #12]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 80025be:	f000 f9ad 	bl	800291c <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
 80025c2:	2f00      	cmp	r7, #0
 80025c4:	d171      	bne.n	80026aa <xQueueGenericReceive+0x21a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
 80025c6:	6ba3      	ldr	r3, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80025c8:	6822      	ldr	r2, [r4, #0]
				if( xJustPeeking == pdFALSE )
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
 80025ca:	3b01      	subs	r3, #1
 80025cc:	63a3      	str	r3, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80025ce:	b912      	cbnz	r2, 80025d6 <xQueueGenericReceive+0x146>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 80025d0:	f001 f9e6 	bl	80039a0 <pvTaskIncrementMutexHeldCount>
 80025d4:	6060      	str	r0, [r4, #4]
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80025d6:	6923      	ldr	r3, [r4, #16]
 80025d8:	2b00      	cmp	r3, #0
 80025da:	d173      	bne.n	80026c4 <xQueueGenericReceive+0x234>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
 80025dc:	f7ff fb7c 	bl	8001cd8 <vPortExitCritical>
				return pdPASS;
 80025e0:	2001      	movs	r0, #1
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
 80025e2:	b005      	add	sp, #20
 80025e4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 80025e8:	f7ff fb76 	bl	8001cd8 <vPortExitCritical>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 80025ec:	f7ff fb56 	bl	8001c9c <vPortEnterCritical>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 80025f0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80025f2:	2b00      	cmp	r3, #0
 80025f4:	dd14      	ble.n	8002620 <xQueueGenericReceive+0x190>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80025f6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80025f8:	b193      	cbz	r3, 8002620 <xQueueGenericReceive+0x190>
 80025fa:	f104 0824 	add.w	r8, r4, #36	; 0x24
 80025fe:	e007      	b.n	8002610 <xQueueGenericReceive+0x180>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
 8002600:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8002602:	3b01      	subs	r3, #1
 8002604:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 8002606:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8002608:	2b00      	cmp	r3, #0
 800260a:	dd09      	ble.n	8002620 <xQueueGenericReceive+0x190>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800260c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800260e:	b13b      	cbz	r3, 8002620 <xQueueGenericReceive+0x190>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8002610:	4640      	mov	r0, r8
 8002612:	f001 f84d 	bl	80036b0 <xTaskRemoveFromEventList>
 8002616:	2800      	cmp	r0, #0
 8002618:	d0f2      	beq.n	8002600 <xQueueGenericReceive+0x170>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
 800261a:	f001 f8fd 	bl	8003818 <vTaskMissedYield>
 800261e:	e7ef      	b.n	8002600 <xQueueGenericReceive+0x170>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
 8002620:	f04f 33ff 	mov.w	r3, #4294967295
 8002624:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
 8002626:	f7ff fb57 	bl	8001cd8 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 800262a:	f7ff fb37 	bl	8001c9c <vPortEnterCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 800262e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8002630:	2b00      	cmp	r3, #0
 8002632:	dd14      	ble.n	800265e <xQueueGenericReceive+0x1ce>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8002634:	6923      	ldr	r3, [r4, #16]
 8002636:	b193      	cbz	r3, 800265e <xQueueGenericReceive+0x1ce>
 8002638:	f104 0810 	add.w	r8, r4, #16
 800263c:	e007      	b.n	800264e <xQueueGenericReceive+0x1be>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
 800263e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8002640:	3b01      	subs	r3, #1
 8002642:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8002644:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8002646:	2b00      	cmp	r3, #0
 8002648:	dd09      	ble.n	800265e <xQueueGenericReceive+0x1ce>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800264a:	6923      	ldr	r3, [r4, #16]
 800264c:	b13b      	cbz	r3, 800265e <xQueueGenericReceive+0x1ce>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800264e:	4640      	mov	r0, r8
 8002650:	f001 f82e 	bl	80036b0 <xTaskRemoveFromEventList>
 8002654:	2800      	cmp	r0, #0
 8002656:	d0f2      	beq.n	800263e <xQueueGenericReceive+0x1ae>
				{
					vTaskMissedYield();
 8002658:	f001 f8de 	bl	8003818 <vTaskMissedYield>
 800265c:	e7ef      	b.n	800263e <xQueueGenericReceive+0x1ae>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
 800265e:	f04f 33ff 	mov.w	r3, #4294967295
 8002662:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
 8002664:	f7ff fb38 	bl	8001cd8 <vPortExitCritical>
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
				( void ) xTaskResumeAll();
 8002668:	f000 fd22 	bl	80030b0 <xTaskResumeAll>
 800266c:	e79d      	b.n	80025aa <xQueueGenericReceive+0x11a>
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 800266e:	a802      	add	r0, sp, #8
 8002670:	f001 f88a 	bl	8003788 <vTaskSetTimeOutState>
 8002674:	e732      	b.n	80024dc <xQueueGenericReceive+0x4c>
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
 8002676:	f7ff faef 	bl	8001c58 <ulPortSetInterruptMask>
 800267a:	e7fe      	b.n	800267a <xQueueGenericReceive+0x1ea>

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
					{
						taskENTER_CRITICAL();
 800267c:	f7ff fb0e 	bl	8001c9c <vPortEnterCritical>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 8002680:	6860      	ldr	r0, [r4, #4]
 8002682:	f001 f8e7 	bl	8003854 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
 8002686:	f7ff fb27 	bl	8001cd8 <vPortExitCritical>
 800268a:	e749      	b.n	8002520 <xQueueGenericReceive+0x90>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
 800268c:	4620      	mov	r0, r4
 800268e:	f7ff fbdf 	bl	8001e50 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8002692:	f000 fd0d 	bl	80030b0 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
 8002696:	2000      	movs	r0, #0
		}
	}
}
 8002698:	b005      	add	sp, #20
 800269a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			{
				if( xTicksToWait == ( TickType_t ) 0 )
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 800269e:	f7ff fb1b 	bl	8001cd8 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 80026a2:	4640      	mov	r0, r8
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
 80026a4:	b005      	add	sp, #20
 80026a6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80026aa:	6a63      	ldr	r3, [r4, #36]	; 0x24
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 80026ac:	60e5      	str	r5, [r4, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80026ae:	2b00      	cmp	r3, #0
 80026b0:	d094      	beq.n	80025dc <xQueueGenericReceive+0x14c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80026b2:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80026b6:	f000 fffb 	bl	80036b0 <xTaskRemoveFromEventList>
 80026ba:	2800      	cmp	r0, #0
 80026bc:	d08e      	beq.n	80025dc <xQueueGenericReceive+0x14c>

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
						{
							queueYIELD_IF_USING_PREEMPTION();
 80026be:	f7ff fabf 	bl	8001c40 <vPortYield>
 80026c2:	e78b      	b.n	80025dc <xQueueGenericReceive+0x14c>
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 80026c4:	f104 0010 	add.w	r0, r4, #16
 80026c8:	f000 fff2 	bl	80036b0 <xTaskRemoveFromEventList>
 80026cc:	2801      	cmp	r0, #1
 80026ce:	d185      	bne.n	80025dc <xQueueGenericReceive+0x14c>
 80026d0:	e7f5      	b.n	80026be <xQueueGenericReceive+0x22e>

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80026d2:	f7ff fac1 	bl	8001c58 <ulPortSetInterruptMask>
 80026d6:	e7fe      	b.n	80026d6 <xQueueGenericReceive+0x246>
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80026d8:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80026da:	2b00      	cmp	r3, #0
 80026dc:	f43f aee5 	beq.w	80024aa <xQueueGenericReceive+0x1a>
 80026e0:	f7ff faba 	bl	8001c58 <ulPortSetInterruptMask>
 80026e4:	e7fe      	b.n	80026e4 <xQueueGenericReceive+0x254>
 80026e6:	bf00      	nop

080026e8 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
 80026e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
 80026ec:	4604      	mov	r4, r0
 80026ee:	b178      	cbz	r0, 8002710 <xQueueReceiveFromISR+0x28>
 80026f0:	460f      	mov	r7, r1
 80026f2:	4690      	mov	r8, r2
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80026f4:	b319      	cbz	r1, 800273e <xQueueReceiveFromISR+0x56>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80026f6:	f7ff fb89 	bl	8001e0c <vPortValidateInterruptPriority>

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80026fa:	f7ff faad 	bl	8001c58 <ulPortSetInterruptMask>
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 80026fe:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8002700:	4606      	mov	r6, r0
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 8002702:	b945      	cbnz	r5, 8002716 <xQueueReceiveFromISR+0x2e>
		{
			xReturn = pdFAIL;
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8002704:	4630      	mov	r0, r6
 8002706:	f7ff fae3 	bl	8001cd0 <vPortClearInterruptMask>

	return xReturn;
}
 800270a:	4628      	mov	r0, r5
 800270c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
 8002710:	f7ff faa2 	bl	8001c58 <ulPortSetInterruptMask>
 8002714:	e7fe      	b.n	8002714 <xQueueReceiveFromISR+0x2c>
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
 8002716:	4639      	mov	r1, r7
 8002718:	4620      	mov	r0, r4
 800271a:	f000 f8ff 	bl	800291c <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
 800271e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002720:	3b01      	subs	r3, #1
 8002722:	63a3      	str	r3, [r4, #56]	; 0x38

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
 8002724:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8002726:	3301      	adds	r3, #1
 8002728:	d00f      	beq.n	800274a <xQueueReceiveFromISR+0x62>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
 800272a:	6c63      	ldr	r3, [r4, #68]	; 0x44
			}

			xReturn = pdPASS;
 800272c:	2501      	movs	r5, #1
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
 800272e:	442b      	add	r3, r5
		{
			xReturn = pdFAIL;
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8002730:	4630      	mov	r0, r6
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
 8002732:	6463      	str	r3, [r4, #68]	; 0x44
		{
			xReturn = pdFAIL;
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8002734:	f7ff facc 	bl	8001cd0 <vPortClearInterruptMask>

	return xReturn;
}
 8002738:	4628      	mov	r0, r5
 800273a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800273e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8002740:	2b00      	cmp	r3, #0
 8002742:	d0d8      	beq.n	80026f6 <xQueueReceiveFromISR+0xe>
 8002744:	f7ff fa88 	bl	8001c58 <ulPortSetInterruptMask>
 8002748:	e7fe      	b.n	8002748 <xQueueReceiveFromISR+0x60>
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800274a:	6923      	ldr	r3, [r4, #16]
 800274c:	b933      	cbnz	r3, 800275c <xQueueReceiveFromISR+0x74>
		{
			xReturn = pdFAIL;
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 800274e:	4630      	mov	r0, r6
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
 8002750:	2501      	movs	r5, #1
		{
			xReturn = pdFAIL;
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8002752:	f7ff fabd 	bl	8001cd0 <vPortClearInterruptMask>

	return xReturn;
}
 8002756:	4628      	mov	r0, r5
 8002758:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800275c:	f104 0010 	add.w	r0, r4, #16
 8002760:	f000 ffa6 	bl	80036b0 <xTaskRemoveFromEventList>
 8002764:	2800      	cmp	r0, #0
 8002766:	d0f2      	beq.n	800274e <xQueueReceiveFromISR+0x66>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
 8002768:	f1b8 0f00 	cmp.w	r8, #0
 800276c:	d0ef      	beq.n	800274e <xQueueReceiveFromISR+0x66>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
 800276e:	2501      	movs	r5, #1
		{
			xReturn = pdFAIL;
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8002770:	4630      	mov	r0, r6
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
 8002772:	f8c8 5000 	str.w	r5, [r8]
		{
			xReturn = pdFAIL;
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8002776:	f7ff faab 	bl	8001cd0 <vPortClearInterruptMask>

	return xReturn;
}
 800277a:	4628      	mov	r0, r5
 800277c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08002780 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
 8002780:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
 8002784:	4604      	mov	r4, r0
 8002786:	b198      	cbz	r0, 80027b0 <xQueuePeekFromISR+0x30>
 8002788:	460e      	mov	r6, r1
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 800278a:	6c03      	ldr	r3, [r0, #64]	; 0x40
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800278c:	b311      	cbz	r1, 80027d4 <xQueuePeekFromISR+0x54>
	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 800278e:	b913      	cbnz	r3, 8002796 <xQueuePeekFromISR+0x16>
 8002790:	f7ff fa62 	bl	8001c58 <ulPortSetInterruptMask>
 8002794:	e7fe      	b.n	8002794 <xQueuePeekFromISR+0x14>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8002796:	f7ff fb39 	bl	8001e0c <vPortValidateInterruptPriority>

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800279a:	f7ff fa5d 	bl	8001c58 <ulPortSetInterruptMask>
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 800279e:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80027a0:	4607      	mov	r7, r0
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 80027a2:	b945      	cbnz	r5, 80027b6 <xQueuePeekFromISR+0x36>
		{
			xReturn = pdFAIL;
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 80027a4:	4638      	mov	r0, r7
 80027a6:	f7ff fa93 	bl	8001cd0 <vPortClearInterruptMask>

	return xReturn;
}
 80027aa:	4628      	mov	r0, r5
 80027ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
 80027b0:	f7ff fa52 	bl	8001c58 <ulPortSetInterruptMask>
 80027b4:	e7fe      	b.n	80027b4 <xQueuePeekFromISR+0x34>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 80027b6:	f8d4 800c 	ldr.w	r8, [r4, #12]
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 80027ba:	4631      	mov	r1, r6
 80027bc:	4620      	mov	r0, r4
 80027be:	f000 f8ad 	bl	800291c <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;

			xReturn = pdPASS;
 80027c2:	2501      	movs	r5, #1
		{
			xReturn = pdFAIL;
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 80027c4:	4638      	mov	r0, r7

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
			prvCopyDataFromQueue( pxQueue, pvBuffer );
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 80027c6:	f8c4 800c 	str.w	r8, [r4, #12]
		{
			xReturn = pdFAIL;
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 80027ca:	f7ff fa81 	bl	8001cd0 <vPortClearInterruptMask>

	return xReturn;
}
 80027ce:	4628      	mov	r0, r5
 80027d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80027d4:	2b00      	cmp	r3, #0
 80027d6:	d0db      	beq.n	8002790 <xQueuePeekFromISR+0x10>
 80027d8:	f7ff fa3e 	bl	8001c58 <ulPortSetInterruptMask>
 80027dc:	e7fe      	b.n	80027dc <xQueuePeekFromISR+0x5c>
 80027de:	bf00      	nop

080027e0 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
 80027e0:	b510      	push	{r4, lr}
UBaseType_t uxReturn;

	configASSERT( xQueue );
 80027e2:	4604      	mov	r4, r0
 80027e4:	b130      	cbz	r0, 80027f4 <uxQueueMessagesWaiting+0x14>

	taskENTER_CRITICAL();
 80027e6:	f7ff fa59 	bl	8001c9c <vPortEnterCritical>
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 80027ea:	6ba4      	ldr	r4, [r4, #56]	; 0x38
	}
	taskEXIT_CRITICAL();
 80027ec:	f7ff fa74 	bl	8001cd8 <vPortExitCritical>

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 80027f0:	4620      	mov	r0, r4
 80027f2:	bd10      	pop	{r4, pc}

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
UBaseType_t uxReturn;

	configASSERT( xQueue );
 80027f4:	f7ff fa30 	bl	8001c58 <ulPortSetInterruptMask>
 80027f8:	e7fe      	b.n	80027f8 <uxQueueMessagesWaiting+0x18>
 80027fa:	bf00      	nop

080027fc <uxQueueSpacesAvailable>:
	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
 80027fc:	b538      	push	{r3, r4, r5, lr}
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );
 80027fe:	4605      	mov	r5, r0
 8002800:	b140      	cbz	r0, 8002814 <uxQueueSpacesAvailable+0x18>

	taskENTER_CRITICAL();
 8002802:	f7ff fa4b 	bl	8001c9c <vPortEnterCritical>
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 8002806:	6bac      	ldr	r4, [r5, #56]	; 0x38
 8002808:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 800280a:	1b1c      	subs	r4, r3, r4
	}
	taskEXIT_CRITICAL();
 800280c:	f7ff fa64 	bl	8001cd8 <vPortExitCritical>

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 8002810:	4620      	mov	r0, r4
 8002812:	bd38      	pop	{r3, r4, r5, pc}
{
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );
 8002814:	f7ff fa20 	bl	8001c58 <ulPortSetInterruptMask>
 8002818:	e7fe      	b.n	8002818 <uxQueueSpacesAvailable+0x1c>
 800281a:	bf00      	nop

0800281c <uxQueueMessagesWaitingFromISR>:

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
UBaseType_t uxReturn;

	configASSERT( xQueue );
 800281c:	b108      	cbz	r0, 8002822 <uxQueueMessagesWaitingFromISR+0x6>

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 800281e:	6b80      	ldr	r0, [r0, #56]	; 0x38

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 8002820:	4770      	bx	lr
	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
 8002822:	b508      	push	{r3, lr}
UBaseType_t uxReturn;

	configASSERT( xQueue );
 8002824:	f7ff fa18 	bl	8001c58 <ulPortSetInterruptMask>
 8002828:	e7fe      	b.n	8002828 <uxQueueMessagesWaitingFromISR+0xc>
 800282a:	bf00      	nop

0800282c <vQueueDelete>:

void vQueueDelete( QueueHandle_t xQueue )
{
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
 800282c:	b108      	cbz	r0, 8002832 <vQueueDelete+0x6>
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue );
 800282e:	f001 bd83 	b.w	8004338 <vPortFree>
	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
 8002832:	b508      	push	{r3, lr}
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
 8002834:	f7ff fa10 	bl	8001c58 <ulPortSetInterruptMask>
 8002838:	e7fe      	b.n	8002838 <vQueueDelete+0xc>
 800283a:	bf00      	nop

0800283c <xQueueIsQueueEmptyFromISR>:

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
 800283c:	b120      	cbz	r0, 8002848 <xQueueIsQueueEmptyFromISR+0xc>
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
 800283e:	6b80      	ldr	r0, [r0, #56]	; 0x38
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 8002840:	fab0 f080 	clz	r0, r0
 8002844:	0940      	lsrs	r0, r0, #5
 8002846:	4770      	bx	lr
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
 8002848:	b508      	push	{r3, lr}
BaseType_t xReturn;

	configASSERT( xQueue );
 800284a:	f7ff fa05 	bl	8001c58 <ulPortSetInterruptMask>
 800284e:	e7fe      	b.n	800284e <xQueueIsQueueEmptyFromISR+0x12>

08002850 <xQueueIsQueueFullFromISR>:

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
 8002850:	b130      	cbz	r0, 8002860 <xQueueIsQueueFullFromISR+0x10>
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
 8002852:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8002854:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 8002856:	1a10      	subs	r0, r2, r0
 8002858:	fab0 f080 	clz	r0, r0
 800285c:	0940      	lsrs	r0, r0, #5
 800285e:	4770      	bx	lr
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
 8002860:	b508      	push	{r3, lr}
BaseType_t xReturn;

	configASSERT( xQueue );
 8002862:	f7ff f9f9 	bl	8001c58 <ulPortSetInterruptMask>
 8002866:	e7fe      	b.n	8002866 <xQueueIsQueueFullFromISR+0x16>

08002868 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 8002868:	b570      	push	{r4, r5, r6, lr}
 800286a:	4604      	mov	r4, r0
 800286c:	460e      	mov	r6, r1
 800286e:	4615      	mov	r5, r2
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 8002870:	f7ff fa14 	bl	8001c9c <vPortEnterCritical>
 8002874:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8002876:	3301      	adds	r3, #1
 8002878:	bf04      	itt	eq
 800287a:	2300      	moveq	r3, #0
 800287c:	6463      	streq	r3, [r4, #68]	; 0x44
 800287e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8002880:	3301      	adds	r3, #1
 8002882:	bf04      	itt	eq
 8002884:	2300      	moveq	r3, #0
 8002886:	64a3      	streq	r3, [r4, #72]	; 0x48
 8002888:	f7ff fa26 	bl	8001cd8 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 800288c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800288e:	b92b      	cbnz	r3, 800289c <vQueueWaitForMessageRestricted+0x34>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 8002890:	4631      	mov	r1, r6
 8002892:	462a      	mov	r2, r5
 8002894:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8002898:	f000 feba 	bl	8003610 <vTaskPlaceOnEventListRestricted>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 800289c:	f7ff f9fe 	bl	8001c9c <vPortEnterCritical>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 80028a0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80028a2:	2b00      	cmp	r3, #0
 80028a4:	dd14      	ble.n	80028d0 <vQueueWaitForMessageRestricted+0x68>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80028a6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80028a8:	b193      	cbz	r3, 80028d0 <vQueueWaitForMessageRestricted+0x68>
 80028aa:	f104 0524 	add.w	r5, r4, #36	; 0x24
 80028ae:	e007      	b.n	80028c0 <vQueueWaitForMessageRestricted+0x58>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
 80028b0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80028b2:	3b01      	subs	r3, #1
 80028b4:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 80028b6:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80028b8:	2b00      	cmp	r3, #0
 80028ba:	dd09      	ble.n	80028d0 <vQueueWaitForMessageRestricted+0x68>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80028bc:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80028be:	b13b      	cbz	r3, 80028d0 <vQueueWaitForMessageRestricted+0x68>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80028c0:	4628      	mov	r0, r5
 80028c2:	f000 fef5 	bl	80036b0 <xTaskRemoveFromEventList>
 80028c6:	2800      	cmp	r0, #0
 80028c8:	d0f2      	beq.n	80028b0 <vQueueWaitForMessageRestricted+0x48>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
 80028ca:	f000 ffa5 	bl	8003818 <vTaskMissedYield>
 80028ce:	e7ef      	b.n	80028b0 <vQueueWaitForMessageRestricted+0x48>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
 80028d0:	f04f 33ff 	mov.w	r3, #4294967295
 80028d4:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
 80028d6:	f7ff f9ff 	bl	8001cd8 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 80028da:	f7ff f9df 	bl	8001c9c <vPortEnterCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 80028de:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80028e0:	2b00      	cmp	r3, #0
 80028e2:	dd14      	ble.n	800290e <vQueueWaitForMessageRestricted+0xa6>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80028e4:	6923      	ldr	r3, [r4, #16]
 80028e6:	b193      	cbz	r3, 800290e <vQueueWaitForMessageRestricted+0xa6>
 80028e8:	f104 0510 	add.w	r5, r4, #16
 80028ec:	e007      	b.n	80028fe <vQueueWaitForMessageRestricted+0x96>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
 80028ee:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80028f0:	3b01      	subs	r3, #1
 80028f2:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 80028f4:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80028f6:	2b00      	cmp	r3, #0
 80028f8:	dd09      	ble.n	800290e <vQueueWaitForMessageRestricted+0xa6>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80028fa:	6923      	ldr	r3, [r4, #16]
 80028fc:	b13b      	cbz	r3, 800290e <vQueueWaitForMessageRestricted+0xa6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80028fe:	4628      	mov	r0, r5
 8002900:	f000 fed6 	bl	80036b0 <xTaskRemoveFromEventList>
 8002904:	2800      	cmp	r0, #0
 8002906:	d0f2      	beq.n	80028ee <vQueueWaitForMessageRestricted+0x86>
				{
					vTaskMissedYield();
 8002908:	f000 ff86 	bl	8003818 <vTaskMissedYield>
 800290c:	e7ef      	b.n	80028ee <vQueueWaitForMessageRestricted+0x86>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
 800290e:	f04f 33ff 	mov.w	r3, #4294967295
 8002912:	6463      	str	r3, [r4, #68]	; 0x44
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
	}
 8002914:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
	}
	taskEXIT_CRITICAL();
 8002918:	f7ff b9de 	b.w	8001cd8 <vPortExitCritical>

0800291c <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 800291c:	6c02      	ldr	r2, [r0, #64]	; 0x40
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 800291e:	4603      	mov	r3, r0
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8002920:	b17a      	cbz	r2, 8002942 <prvCopyDataFromQueue+0x26>
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 8002922:	b410      	push	{r4}
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8002924:	68c4      	ldr	r4, [r0, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8002926:	6840      	ldr	r0, [r0, #4]

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8002928:	4414      	add	r4, r2
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800292a:	4284      	cmp	r4, r0
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 800292c:	bf28      	it	cs
 800292e:	6818      	ldrcs	r0, [r3, #0]

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8002930:	60dc      	str	r4, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 8002932:	bf28      	it	cs
 8002934:	60d8      	strcs	r0, [r3, #12]
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
	}
}
 8002936:	f85d 4b04 	ldr.w	r4, [sp], #4
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 800293a:	4608      	mov	r0, r1
 800293c:	68d9      	ldr	r1, [r3, #12]
 800293e:	f001 bf27 	b.w	8004790 <memcpy>
 8002942:	4770      	bx	lr

08002944 <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 8002944:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002948:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 800294a:	469a      	mov	sl, r3
 800294c:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
 8002950:	9b0c      	ldr	r3, [sp, #48]	; 0x30
BaseType_t xReturn;
TCB_t * pxNewTCB;
StackType_t *pxTopOfStack;

	configASSERT( pxTaskCode );
 8002952:	4681      	mov	r9, r0
 8002954:	2800      	cmp	r0, #0
 8002956:	f000 80a4 	beq.w	8002aa2 <xTaskGenericCreate+0x15e>
	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMAX_PRIORITIES ) );
 800295a:	2f04      	cmp	r7, #4
 800295c:	d902      	bls.n	8002964 <xTaskGenericCreate+0x20>
 800295e:	f7ff f97b 	bl	8001c58 <ulPortSetInterruptMask>
 8002962:	e7fe      	b.n	8002962 <xTaskGenericCreate+0x1e>
 8002964:	460d      	mov	r5, r1
 8002966:	4616      	mov	r6, r2
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002968:	469b      	mov	fp, r3
 800296a:	2b00      	cmp	r3, #0
 800296c:	f000 80b1 	beq.w	8002ad2 <xTaskGenericCreate+0x18e>

		if( pxStack != NULL )
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 8002970:	2050      	movs	r0, #80	; 0x50
 8002972:	f001 fcb1 	bl	80042d8 <pvPortMalloc>

			if( pxNewTCB != NULL )
 8002976:	4604      	mov	r4, r0
 8002978:	2800      	cmp	r0, #0
 800297a:	f000 80a3 	beq.w	8002ac4 <xTaskGenericCreate+0x180>
	{
		/* Avoid dependency on memset() if it is not required. */
		#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
		{
			/* Just to help debugging. */
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
 800297e:	00b6      	lsls	r6, r6, #2
 8002980:	4632      	mov	r2, r6
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );

			if( pxNewTCB != NULL )
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
 8002982:	f8c0 b030 	str.w	fp, [r0, #48]	; 0x30
	{
		/* Avoid dependency on memset() if it is not required. */
		#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
		{
			/* Just to help debugging. */
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
 8002986:	21a5      	movs	r1, #165	; 0xa5
 8002988:	4658      	mov	r0, fp
 800298a:	f001 ff77 	bl	800487c <memset>
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 800298e:	782b      	ldrb	r3, [r5, #0]
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 8002990:	6b22      	ldr	r2, [r4, #48]	; 0x30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 8002992:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 8002996:	3e04      	subs	r6, #4
		pxTCB->pcTaskName[ x ] = pcName[ x ];

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 8002998:	782b      	ldrb	r3, [r5, #0]
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 800299a:	4416      	add	r6, r2
			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 800299c:	f026 0607 	bic.w	r6, r6, #7
		pxTCB->pcTaskName[ x ] = pcName[ x ];

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 80029a0:	b32b      	cbz	r3, 80029ee <xTaskGenericCreate+0xaa>
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 80029a2:	786b      	ldrb	r3, [r5, #1]
 80029a4:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 80029a8:	786b      	ldrb	r3, [r5, #1]
 80029aa:	b303      	cbz	r3, 80029ee <xTaskGenericCreate+0xaa>
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 80029ac:	78ab      	ldrb	r3, [r5, #2]
 80029ae:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 80029b2:	78ab      	ldrb	r3, [r5, #2]
 80029b4:	b1db      	cbz	r3, 80029ee <xTaskGenericCreate+0xaa>
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 80029b6:	78eb      	ldrb	r3, [r5, #3]
 80029b8:	f884 3037 	strb.w	r3, [r4, #55]	; 0x37

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 80029bc:	78eb      	ldrb	r3, [r5, #3]
 80029be:	b1b3      	cbz	r3, 80029ee <xTaskGenericCreate+0xaa>
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 80029c0:	792b      	ldrb	r3, [r5, #4]
 80029c2:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 80029c6:	792b      	ldrb	r3, [r5, #4]
 80029c8:	b18b      	cbz	r3, 80029ee <xTaskGenericCreate+0xaa>
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 80029ca:	796b      	ldrb	r3, [r5, #5]
 80029cc:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 80029d0:	796b      	ldrb	r3, [r5, #5]
 80029d2:	b163      	cbz	r3, 80029ee <xTaskGenericCreate+0xaa>
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 80029d4:	79ab      	ldrb	r3, [r5, #6]
 80029d6:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 80029da:	79ab      	ldrb	r3, [r5, #6]
 80029dc:	b13b      	cbz	r3, 80029ee <xTaskGenericCreate+0xaa>
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 80029de:	79eb      	ldrb	r3, [r5, #7]
 80029e0:	f884 303b 	strb.w	r3, [r4, #59]	; 0x3b

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 80029e4:	79eb      	ldrb	r3, [r5, #7]
 80029e6:	b113      	cbz	r3, 80029ee <xTaskGenericCreate+0xaa>
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 80029e8:	7a2b      	ldrb	r3, [r5, #8]
 80029ea:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 80029ee:	2500      	movs	r5, #0
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 80029f0:	f104 0b04 	add.w	fp, r4, #4
 80029f4:	4658      	mov	r0, fp
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
 80029f6:	62e7      	str	r7, [r4, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 80029f8:	6427      	str	r7, [r4, #64]	; 0x40
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 80029fa:	f884 503d 	strb.w	r5, [r4, #61]	; 0x3d

	pxTCB->uxPriority = uxPriority;
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
 80029fe:	6465      	str	r5, [r4, #68]	; 0x44
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8002a00:	f001 fcbe 	bl	8004380 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 8002a04:	f104 0018 	add.w	r0, r4, #24
 8002a08:	f001 fcba 	bl	8004380 <vListInitialiseItem>
	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002a0c:	f1c7 0305 	rsb	r3, r7, #5
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
 8002a10:	64a5      	str	r5, [r4, #72]	; 0x48
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
	vListInitialiseItem( &( pxTCB->xEventListItem ) );

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 8002a12:	6124      	str	r4, [r4, #16]
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
		pxTCB->eNotifyState = eNotWaitingNotification;
 8002a14:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 8002a18:	6264      	str	r4, [r4, #36]	; 0x24
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8002a1a:	4630      	mov	r0, r6
 8002a1c:	4649      	mov	r1, r9
 8002a1e:	4652      	mov	r2, sl
	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002a20:	61a3      	str	r3, [r4, #24]
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8002a22:	f7ff f8e9 	bl	8001bf8 <pxPortInitialiseStack>
 8002a26:	6020      	str	r0, [r4, #0]
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
 8002a28:	f1b8 0f00 	cmp.w	r8, #0
 8002a2c:	d001      	beq.n	8002a32 <xTaskGenericCreate+0xee>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8002a2e:	f8c8 4000 	str.w	r4, [r8]

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
		{
			uxCurrentNumberOfTasks++;
 8002a32:	4d2b      	ldr	r5, [pc, #172]	; (8002ae0 <xTaskGenericCreate+0x19c>)
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
 8002a34:	f7ff f932 	bl	8001c9c <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 8002a38:	f8d5 30d0 	ldr.w	r3, [r5, #208]	; 0xd0
 8002a3c:	3301      	adds	r3, #1
 8002a3e:	f8c5 30d0 	str.w	r3, [r5, #208]	; 0xd0
			if( pxCurrentTCB == NULL )
 8002a42:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
 8002a46:	b3a3      	cbz	r3, 8002ab2 <xTaskGenericCreate+0x16e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 8002a48:	f8d5 30d8 	ldr.w	r3, [r5, #216]	; 0xd8
 8002a4c:	b933      	cbnz	r3, 8002a5c <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 8002a4e:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
 8002a52:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002a54:	429f      	cmp	r7, r3
					{
						pxCurrentTCB = pxNewTCB;
 8002a56:	bf28      	it	cs
 8002a58:	f8c5 40d4 	strcs.w	r4, [r5, #212]	; 0xd4
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8002a5c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8002a5e:	f8d5 20e0 	ldr.w	r2, [r5, #224]	; 0xe0
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 8002a62:	f8d5 30dc 	ldr.w	r3, [r5, #220]	; 0xdc
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8002a66:	2401      	movs	r4, #1
 8002a68:	fa04 f600 	lsl.w	r6, r4, r0
 8002a6c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002a70:	4332      	orrs	r2, r6
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 8002a72:	4423      	add	r3, r4
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8002a74:	4659      	mov	r1, fp
 8002a76:	eb05 0080 	add.w	r0, r5, r0, lsl #2
 8002a7a:	f8c5 20e0 	str.w	r2, [r5, #224]	; 0xe0
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 8002a7e:	f8c5 30dc 	str.w	r3, [r5, #220]	; 0xdc
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8002a82:	f001 fc81 	bl	8004388 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 8002a86:	f7ff f927 	bl	8001cd8 <vPortExitCritical>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
 8002a8a:	f8d5 20d8 	ldr.w	r2, [r5, #216]	; 0xd8
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 8002a8e:	4b14      	ldr	r3, [pc, #80]	; (8002ae0 <xTaskGenericCreate+0x19c>)
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
 8002a90:	b122      	cbz	r2, 8002a9c <xTaskGenericCreate+0x158>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 8002a92:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8002a96:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002a98:	429f      	cmp	r7, r3
 8002a9a:	d805      	bhi.n	8002aa8 <xTaskGenericCreate+0x164>
 8002a9c:	4620      	mov	r0, r4
 8002a9e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
BaseType_t xReturn;
TCB_t * pxNewTCB;
StackType_t *pxTopOfStack;

	configASSERT( pxTaskCode );
 8002aa2:	f7ff f8d9 	bl	8001c58 <ulPortSetInterruptMask>
 8002aa6:	e7fe      	b.n	8002aa6 <xTaskGenericCreate+0x162>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
			{
				taskYIELD_IF_USING_PREEMPTION();
 8002aa8:	f7ff f8ca 	bl	8001c40 <vPortYield>
 8002aac:	4620      	mov	r0, r4
 8002aae:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			uxCurrentNumberOfTasks++;
			if( pxCurrentTCB == NULL )
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 8002ab2:	f8c5 40d4 	str.w	r4, [r5, #212]	; 0xd4

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8002ab6:	f8d5 30d0 	ldr.w	r3, [r5, #208]	; 0xd0
 8002aba:	2b01      	cmp	r3, #1
 8002abc:	d1ce      	bne.n	8002a5c <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
 8002abe:	f001 f9a3 	bl	8003e08 <prvInitialiseTaskLists>
 8002ac2:	e7cb      	b.n	8002a5c <xTaskGenericCreate+0x118>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
 8002ac4:	4658      	mov	r0, fp
 8002ac6:	f001 fc37 	bl	8004338 <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8002aca:	f04f 30ff 	mov.w	r0, #4294967295
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
 8002ace:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002ad2:	0090      	lsls	r0, r2, #2
 8002ad4:	f001 fc00 	bl	80042d8 <pvPortMalloc>

		if( pxStack != NULL )
 8002ad8:	4683      	mov	fp, r0
 8002ada:	2800      	cmp	r0, #0
 8002adc:	d0f5      	beq.n	8002aca <xTaskGenericCreate+0x186>
 8002ade:	e747      	b.n	8002970 <xTaskGenericCreate+0x2c>
 8002ae0:	20000040 	.word	0x20000040

08002ae4 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
 8002ae4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002ae6:	4606      	mov	r6, r0

		taskENTER_CRITICAL();
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8002ae8:	4c30      	ldr	r4, [pc, #192]	; (8002bac <vTaskDelete+0xc8>)

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 8002aea:	f7ff f8d7 	bl	8001c9c <vPortEnterCritical>
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8002aee:	2e00      	cmp	r6, #0
 8002af0:	d054      	beq.n	8002b9c <vTaskDelete+0xb8>

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8002af2:	1d37      	adds	r7, r6, #4
 8002af4:	4638      	mov	r0, r7
 8002af6:	f001 fc71 	bl	80043dc <uxListRemove>
 8002afa:	b938      	cbnz	r0, 8002b0c <vTaskDelete+0x28>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8002afc:	6af1      	ldr	r1, [r6, #44]	; 0x2c
 8002afe:	482b      	ldr	r0, [pc, #172]	; (8002bac <vTaskDelete+0xc8>)
 8002b00:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 8002b04:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 8002b08:	2b00      	cmp	r3, #0
 8002b0a:	d03d      	beq.n	8002b88 <vTaskDelete+0xa4>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8002b0c:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8002b0e:	b11b      	cbz	r3, 8002b18 <vTaskDelete+0x34>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8002b10:	f106 0018 	add.w	r0, r6, #24
 8002b14:	f001 fc62 	bl	80043dc <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 8002b18:	4d24      	ldr	r5, [pc, #144]	; (8002bac <vTaskDelete+0xc8>)
 8002b1a:	4639      	mov	r1, r7
 8002b1c:	f105 00a0 	add.w	r0, r5, #160	; 0xa0
 8002b20:	f001 fc32 	bl	8004388 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
 8002b24:	f8d4 20e4 	ldr.w	r2, [r4, #228]	; 0xe4

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
 8002b28:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
 8002b2c:	3201      	adds	r2, #1

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
 8002b2e:	3301      	adds	r3, #1
 8002b30:	f8c4 30dc 	str.w	r3, [r4, #220]	; 0xdc
			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
 8002b34:	f8c4 20e4 	str.w	r2, [r4, #228]	; 0xe4
			can detect that the task lists need re-generating. */
			uxTaskNumber++;

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
 8002b38:	f7ff f8ce 	bl	8001cd8 <vPortExitCritical>

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
 8002b3c:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
 8002b40:	b35b      	cbz	r3, 8002b9a <vTaskDelete+0xb6>
		{
			if( pxTCB == pxCurrentTCB )
 8002b42:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
 8002b46:	429e      	cmp	r6, r3
 8002b48:	d018      	beq.n	8002b7c <vTaskDelete+0x98>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
 8002b4a:	f7ff f8a7 	bl	8001c9c <vPortEnterCritical>

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8002b4e:	f8d5 30c8 	ldr.w	r3, [r5, #200]	; 0xc8
 8002b52:	681b      	ldr	r3, [r3, #0]
 8002b54:	b153      	cbz	r3, 8002b6c <vTaskDelete+0x88>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8002b56:	f8d5 30c8 	ldr.w	r3, [r5, #200]	; 0xc8
 8002b5a:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 8002b5c:	68db      	ldr	r3, [r3, #12]
 8002b5e:	685b      	ldr	r3, [r3, #4]
 8002b60:	f8c5 30ec 	str.w	r3, [r5, #236]	; 0xec
					prvResetNextTaskUnblockTime();
				}
				taskEXIT_CRITICAL();
			}
		}
	}
 8002b64:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				the task that has just been deleted. */
				taskENTER_CRITICAL();
				{
					prvResetNextTaskUnblockTime();
				}
				taskEXIT_CRITICAL();
 8002b68:	f7ff b8b6 	b.w	8001cd8 <vPortExitCritical>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8002b6c:	f04f 33ff 	mov.w	r3, #4294967295
 8002b70:	f8c5 30ec 	str.w	r3, [r5, #236]	; 0xec
					prvResetNextTaskUnblockTime();
				}
				taskEXIT_CRITICAL();
			}
		}
	}
 8002b74:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				the task that has just been deleted. */
				taskENTER_CRITICAL();
				{
					prvResetNextTaskUnblockTime();
				}
				taskEXIT_CRITICAL();
 8002b78:	f7ff b8ae 	b.w	8001cd8 <vPortExitCritical>
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
		{
			if( pxTCB == pxCurrentTCB )
			{
				configASSERT( uxSchedulerSuspended == 0 );
 8002b7c:	f8d5 30e8 	ldr.w	r3, [r5, #232]	; 0xe8
 8002b80:	b17b      	cbz	r3, 8002ba2 <vTaskDelete+0xbe>
 8002b82:	f7ff f869 	bl	8001c58 <ulPortSetInterruptMask>
 8002b86:	e7fe      	b.n	8002b86 <vTaskDelete+0xa2>
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8002b88:	f8d0 30e0 	ldr.w	r3, [r0, #224]	; 0xe0
 8002b8c:	2201      	movs	r2, #1
 8002b8e:	408a      	lsls	r2, r1
 8002b90:	ea23 0302 	bic.w	r3, r3, r2
 8002b94:	f8c0 30e0 	str.w	r3, [r0, #224]	; 0xe0
 8002b98:	e7b8      	b.n	8002b0c <vTaskDelete+0x28>
 8002b9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

		taskENTER_CRITICAL();
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8002b9c:	f8d4 60d4 	ldr.w	r6, [r4, #212]	; 0xd4
 8002ba0:	e7a7      	b.n	8002af2 <vTaskDelete+0xe>
					prvResetNextTaskUnblockTime();
				}
				taskEXIT_CRITICAL();
			}
		}
	}
 8002ba2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
 8002ba6:	f7ff b84b 	b.w	8001c40 <vPortYield>
 8002baa:	bf00      	nop
 8002bac:	20000040 	.word	0x20000040

08002bb0 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
 8002bb0:	b510      	push	{r4, lr}
 8002bb2:	4604      	mov	r4, r0
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
 8002bb4:	f7ff f872 	bl	8001c9c <vPortEnterCritical>
		{
			/* If null is passed in here then it is the priority of the that
			called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
 8002bb8:	b124      	cbz	r4, 8002bc4 <uxTaskPriorityGet+0x14>
			uxReturn = pxTCB->uxPriority;
 8002bba:	6ae4      	ldr	r4, [r4, #44]	; 0x2c
		}
		taskEXIT_CRITICAL();
 8002bbc:	f7ff f88c 	bl	8001cd8 <vPortExitCritical>

		return uxReturn;
	}
 8002bc0:	4620      	mov	r0, r4
 8002bc2:	bd10      	pop	{r4, pc}

		taskENTER_CRITICAL();
		{
			/* If null is passed in here then it is the priority of the that
			called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
 8002bc4:	4b03      	ldr	r3, [pc, #12]	; (8002bd4 <uxTaskPriorityGet+0x24>)
 8002bc6:	f8d3 40d4 	ldr.w	r4, [r3, #212]	; 0xd4
			uxReturn = pxTCB->uxPriority;
 8002bca:	6ae4      	ldr	r4, [r4, #44]	; 0x2c
		}
		taskEXIT_CRITICAL();
 8002bcc:	f7ff f884 	bl	8001cd8 <vPortExitCritical>

		return uxReturn;
	}
 8002bd0:	4620      	mov	r0, r4
 8002bd2:	bd10      	pop	{r4, pc}
 8002bd4:	20000040 	.word	0x20000040

08002bd8 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
	{
 8002bd8:	b510      	push	{r4, lr}
 8002bda:	4604      	mov	r4, r0
		below the maximum system call interrupt priority.  FreeRTOS maintains a
		separate interrupt safe API to ensure interrupt entry is as fast and as
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8002bdc:	f7ff f916 	bl	8001e0c <vPortValidateInterruptPriority>

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
 8002be0:	f7ff f83a 	bl	8001c58 <ulPortSetInterruptMask>
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
 8002be4:	b124      	cbz	r4, 8002bf0 <uxTaskPriorityGetFromISR+0x18>
			uxReturn = pxTCB->uxPriority;
 8002be6:	6ae4      	ldr	r4, [r4, #44]	; 0x2c
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
 8002be8:	f7ff f872 	bl	8001cd0 <vPortClearInterruptMask>

		return uxReturn;
	}
 8002bec:	4620      	mov	r0, r4
 8002bee:	bd10      	pop	{r4, pc}

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
 8002bf0:	4b03      	ldr	r3, [pc, #12]	; (8002c00 <uxTaskPriorityGetFromISR+0x28>)
 8002bf2:	f8d3 40d4 	ldr.w	r4, [r3, #212]	; 0xd4
			uxReturn = pxTCB->uxPriority;
 8002bf6:	6ae4      	ldr	r4, [r4, #44]	; 0x2c
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
 8002bf8:	f7ff f86a 	bl	8001cd0 <vPortClearInterruptMask>

		return uxReturn;
	}
 8002bfc:	4620      	mov	r0, r4
 8002bfe:	bd10      	pop	{r4, pc}
 8002c00:	20000040 	.word	0x20000040

08002c04 <vTaskPrioritySet>:
	{
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 8002c04:	2904      	cmp	r1, #4
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
 8002c06:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002c0a:	460e      	mov	r6, r1
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 8002c0c:	d834      	bhi.n	8002c78 <vTaskPrioritySet+0x74>
 8002c0e:	4604      	mov	r4, r0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
 8002c10:	f7ff f844 	bl	8001c9c <vPortEnterCritical>
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
 8002c14:	b39c      	cbz	r4, 8002c7e <vTaskPrioritySet+0x7a>

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
 8002c16:	6c23      	ldr	r3, [r4, #64]	; 0x40
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
 8002c18:	429e      	cmp	r6, r3
 8002c1a:	d022      	beq.n	8002c62 <vTaskPrioritySet+0x5e>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
				{
					if( pxTCB != pxCurrentTCB )
 8002c1c:	4d2d      	ldr	r5, [pc, #180]	; (8002cd4 <vTaskPrioritySet+0xd0>)

			if( uxCurrentBasePriority != uxNewPriority )
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
 8002c1e:	d924      	bls.n	8002c6a <vTaskPrioritySet+0x66>
				{
					if( pxTCB != pxCurrentTCB )
 8002c20:	f8d5 20d4 	ldr.w	r2, [r5, #212]	; 0xd4
 8002c24:	4294      	cmp	r4, r2
 8002c26:	d052      	beq.n	8002cce <vTaskPrioritySet+0xca>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 8002c28:	f8d5 20d4 	ldr.w	r2, [r5, #212]	; 0xd4
 8002c2c:	6ad7      	ldr	r7, [r2, #44]	; 0x2c
 8002c2e:	42be      	cmp	r6, r7
 8002c30:	bf34      	ite	cc
 8002c32:	2700      	movcc	r7, #0
 8002c34:	2701      	movcs	r7, #1
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 8002c36:	f8d4 802c 	ldr.w	r8, [r4, #44]	; 0x2c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 8002c3a:	6962      	ldr	r2, [r4, #20]

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 8002c3c:	4543      	cmp	r3, r8
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8002c3e:	69a3      	ldr	r3, [r4, #24]
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
					{
						pxTCB->uxPriority = uxNewPriority;
 8002c40:	bf08      	it	eq
 8002c42:	62e6      	streq	r6, [r4, #44]	; 0x2c
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8002c44:	2b00      	cmp	r3, #0

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 8002c46:	eb08 0388 	add.w	r3, r8, r8, lsl #2
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
 8002c4a:	6426      	str	r6, [r4, #64]	; 0x40

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 8002c4c:	eb05 0383 	add.w	r3, r5, r3, lsl #2

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002c50:	bfa4      	itt	ge
 8002c52:	f1c6 0605 	rsbge	r6, r6, #5
 8002c56:	61a6      	strge	r6, [r4, #24]

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 8002c58:	429a      	cmp	r2, r3
 8002c5a:	f8df 9078 	ldr.w	r9, [pc, #120]	; 8002cd4 <vTaskPrioritySet+0xd0>
 8002c5e:	d018      	beq.n	8002c92 <vTaskPrioritySet+0x8e>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired == pdTRUE )
 8002c60:	b98f      	cbnz	r7, 8002c86 <vTaskPrioritySet+0x82>
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
	}
 8002c62:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
 8002c66:	f7ff b837 	b.w	8001cd8 <vPortExitCritical>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
 8002c6a:	f8d5 70d4 	ldr.w	r7, [r5, #212]	; 0xd4
 8002c6e:	1be7      	subs	r7, r4, r7
 8002c70:	fab7 f787 	clz	r7, r7
 8002c74:	097f      	lsrs	r7, r7, #5
 8002c76:	e7de      	b.n	8002c36 <vTaskPrioritySet+0x32>
	{
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 8002c78:	f7fe ffee 	bl	8001c58 <ulPortSetInterruptMask>
 8002c7c:	e7fe      	b.n	8002c7c <vTaskPrioritySet+0x78>

		taskENTER_CRITICAL();
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
 8002c7e:	4b15      	ldr	r3, [pc, #84]	; (8002cd4 <vTaskPrioritySet+0xd0>)
 8002c80:	f8d3 40d4 	ldr.w	r4, [r3, #212]	; 0xd4
 8002c84:	e7c7      	b.n	8002c16 <vTaskPrioritySet+0x12>
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired == pdTRUE )
				{
					taskYIELD_IF_USING_PREEMPTION();
 8002c86:	f7fe ffdb 	bl	8001c40 <vPortYield>
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
	}
 8002c8a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
 8002c8e:	f7ff b823 	b.w	8001cd8 <vPortExitCritical>
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8002c92:	1d26      	adds	r6, r4, #4
 8002c94:	4630      	mov	r0, r6
 8002c96:	f001 fba1 	bl	80043dc <uxListRemove>
 8002c9a:	b940      	cbnz	r0, 8002cae <vTaskPrioritySet+0xaa>
					{
						/* It is known that the task is in its ready list so
						there is no need to check again and the port level
						reset macro can be called directly. */
						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
 8002c9c:	f8d9 30e0 	ldr.w	r3, [r9, #224]	; 0xe0
 8002ca0:	2201      	movs	r2, #1
 8002ca2:	fa02 f208 	lsl.w	r2, r2, r8
 8002ca6:	ea23 0302 	bic.w	r3, r3, r2
 8002caa:	f8c9 30e0 	str.w	r3, [r9, #224]	; 0xe0
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
 8002cae:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8002cb0:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
 8002cb4:	2201      	movs	r2, #1
 8002cb6:	4082      	lsls	r2, r0
 8002cb8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002cbc:	4313      	orrs	r3, r2
 8002cbe:	4631      	mov	r1, r6
 8002cc0:	eb05 0080 	add.w	r0, r5, r0, lsl #2
 8002cc4:	f8c5 30e0 	str.w	r3, [r5, #224]	; 0xe0
 8002cc8:	f001 fb5e 	bl	8004388 <vListInsertEnd>
 8002ccc:	e7c8      	b.n	8002c60 <vTaskPrioritySet+0x5c>

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
 8002cce:	2700      	movs	r7, #0
 8002cd0:	e7b1      	b.n	8002c36 <vTaskPrioritySet+0x32>
 8002cd2:	bf00      	nop
 8002cd4:	20000040 	.word	0x20000040

08002cd8 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
 8002cd8:	b570      	push	{r4, r5, r6, lr}
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;

		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );
 8002cda:	4605      	mov	r5, r0
 8002cdc:	b180      	cbz	r0, 8002d00 <vTaskResume+0x28>

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 8002cde:	4c1b      	ldr	r4, [pc, #108]	; (8002d4c <vTaskResume+0x74>)
 8002ce0:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 8002ce4:	4298      	cmp	r0, r3
 8002ce6:	d00a      	beq.n	8002cfe <vTaskResume+0x26>
		{
			taskENTER_CRITICAL();
 8002ce8:	f7fe ffd8 	bl	8001c9c <vPortEnterCritical>

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 8002cec:	696a      	ldr	r2, [r5, #20]
 8002cee:	f104 03b4 	add.w	r3, r4, #180	; 0xb4
 8002cf2:	429a      	cmp	r2, r3
 8002cf4:	d007      	beq.n	8002d06 <vTaskResume+0x2e>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 8002cf6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
 8002cfa:	f7fe bfed 	b.w	8001cd8 <vPortExitCritical>
 8002cfe:	bd70      	pop	{r4, r5, r6, pc}
	void vTaskResume( TaskHandle_t xTaskToResume )
	{
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;

		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );
 8002d00:	f7fe ffaa 	bl	8001c58 <ulPortSetInterruptMask>
 8002d04:	e7fe      	b.n	8002d04 <vTaskResume+0x2c>

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 8002d06:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8002d08:	f104 028c 	add.w	r2, r4, #140	; 0x8c
 8002d0c:	4293      	cmp	r3, r2
 8002d0e:	d0f2      	beq.n	8002cf6 <vTaskResume+0x1e>
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
		{
			taskENTER_CRITICAL();
			{
				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 8002d10:	2b00      	cmp	r3, #0
 8002d12:	d1f0      	bne.n	8002cf6 <vTaskResume+0x1e>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 8002d14:	1d2e      	adds	r6, r5, #4
 8002d16:	4630      	mov	r0, r6
 8002d18:	f001 fb60 	bl	80043dc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8002d1c:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8002d1e:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 8002d22:	2201      	movs	r2, #1
 8002d24:	4082      	lsls	r2, r0
 8002d26:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002d2a:	4313      	orrs	r3, r2
 8002d2c:	4631      	mov	r1, r6
 8002d2e:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 8002d32:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
 8002d36:	f001 fb27 	bl	8004388 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8002d3a:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 8002d3e:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8002d40:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002d42:	429a      	cmp	r2, r3
 8002d44:	d3d7      	bcc.n	8002cf6 <vTaskResume+0x1e>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
 8002d46:	f7fe ff7b 	bl	8001c40 <vPortYield>
 8002d4a:	e7d4      	b.n	8002cf6 <vTaskResume+0x1e>
 8002d4c:	20000040 	.word	0x20000040

08002d50 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
 8002d50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	BaseType_t xYieldRequired = pdFALSE;
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToResume );
 8002d54:	4606      	mov	r6, r0
 8002d56:	b188      	cbz	r0, 8002d7c <xTaskResumeFromISR+0x2c>
		below the maximum system call interrupt priority.  FreeRTOS maintains a
		separate interrupt safe API to ensure interrupt entry is as fast and as
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8002d58:	f7ff f858 	bl	8001e0c <vPortValidateInterruptPriority>

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8002d5c:	f7fe ff7c 	bl	8001c58 <ulPortSetInterruptMask>

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 8002d60:	4d23      	ldr	r5, [pc, #140]	; (8002df0 <xTaskResumeFromISR+0xa0>)
 8002d62:	6972      	ldr	r2, [r6, #20]
 8002d64:	f105 03b4 	add.w	r3, r5, #180	; 0xb4
 8002d68:	429a      	cmp	r2, r3
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8002d6a:	4607      	mov	r7, r0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 8002d6c:	d009      	beq.n	8002d82 <xTaskResumeFromISR+0x32>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8002d6e:	4638      	mov	r0, r7

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
 8002d70:	2400      	movs	r4, #0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8002d72:	f7fe ffad 	bl	8001cd0 <vPortClearInterruptMask>

		return xYieldRequired;
	}
 8002d76:	4620      	mov	r0, r4
 8002d78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	{
	BaseType_t xYieldRequired = pdFALSE;
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToResume );
 8002d7c:	f7fe ff6c 	bl	8001c58 <ulPortSetInterruptMask>
 8002d80:	e7fe      	b.n	8002d80 <xTaskResumeFromISR+0x30>

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 8002d82:	6ab4      	ldr	r4, [r6, #40]	; 0x28
 8002d84:	f105 008c 	add.w	r0, r5, #140	; 0x8c
 8002d88:	4284      	cmp	r4, r0
 8002d8a:	d0f0      	beq.n	8002d6e <xTaskResumeFromISR+0x1e>
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 8002d8c:	2c00      	cmp	r4, #0
 8002d8e:	d1ee      	bne.n	8002d6e <xTaskResumeFromISR+0x1e>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8002d90:	f8d5 30e8 	ldr.w	r3, [r5, #232]	; 0xe8
 8002d94:	bb0b      	cbnz	r3, 8002dda <xTaskResumeFromISR+0x8a>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8002d96:	f8d5 20d4 	ldr.w	r2, [r5, #212]	; 0xd4
 8002d9a:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8002d9c:	6ad4      	ldr	r4, [r2, #44]	; 0x2c
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 8002d9e:	f106 0804 	add.w	r8, r6, #4
				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8002da2:	42a3      	cmp	r3, r4
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 8002da4:	4640      	mov	r0, r8
				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8002da6:	bf34      	ite	cc
 8002da8:	2400      	movcc	r4, #0
 8002daa:	2401      	movcs	r4, #1
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 8002dac:	f001 fb16 	bl	80043dc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8002db0:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 8002db2:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
 8002db6:	2201      	movs	r2, #1
 8002db8:	4082      	lsls	r2, r0
 8002dba:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002dbe:	4313      	orrs	r3, r2
 8002dc0:	4641      	mov	r1, r8
 8002dc2:	eb05 0080 	add.w	r0, r5, r0, lsl #2
 8002dc6:	f8c5 30e0 	str.w	r3, [r5, #224]	; 0xe0
 8002dca:	f001 fadd 	bl	8004388 <vListInsertEnd>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8002dce:	4638      	mov	r0, r7
 8002dd0:	f7fe ff7e 	bl	8001cd0 <vPortClearInterruptMask>

		return xYieldRequired;
	}
 8002dd4:	4620      	mov	r0, r4
 8002dd6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 8002dda:	f106 0118 	add.w	r1, r6, #24
 8002dde:	f001 fad3 	bl	8004388 <vListInsertEnd>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8002de2:	4638      	mov	r0, r7
 8002de4:	f7fe ff74 	bl	8001cd0 <vPortClearInterruptMask>

		return xYieldRequired;
	}
 8002de8:	4620      	mov	r0, r4
 8002dea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002dee:	bf00      	nop
 8002df0:	20000040 	.word	0x20000040

08002df4 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 8002df4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002df6:	f44f 708c 	mov.w	r0, #280	; 0x118
 8002dfa:	f001 fa6d 	bl	80042d8 <pvPortMalloc>

		if( pxStack != NULL )
 8002dfe:	4605      	mov	r5, r0
 8002e00:	2800      	cmp	r0, #0
 8002e02:	f000 8082 	beq.w	8002f0a <vTaskStartScheduler+0x116>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 8002e06:	2050      	movs	r0, #80	; 0x50
 8002e08:	f001 fa66 	bl	80042d8 <pvPortMalloc>

			if( pxNewTCB != NULL )
 8002e0c:	4604      	mov	r4, r0
 8002e0e:	2800      	cmp	r0, #0
 8002e10:	f000 8088 	beq.w	8002f24 <vTaskStartScheduler+0x130>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
 8002e14:	6305      	str	r5, [r0, #48]	; 0x30
	{
		/* Avoid dependency on memset() if it is not required. */
		#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
		{
			/* Just to help debugging. */
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
 8002e16:	21a5      	movs	r1, #165	; 0xa5
 8002e18:	4628      	mov	r0, r5
 8002e1a:	f44f 728c 	mov.w	r2, #280	; 0x118
 8002e1e:	f001 fd2d 	bl	800487c <memset>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 8002e22:	6b23      	ldr	r3, [r4, #48]	; 0x30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 8002e24:	2500      	movs	r5, #0
 8002e26:	214c      	movs	r1, #76	; 0x4c
 8002e28:	2245      	movs	r2, #69	; 0x45
 8002e2a:	2649      	movs	r6, #73	; 0x49
 8002e2c:	2044      	movs	r0, #68	; 0x44
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8002e2e:	1d27      	adds	r7, r4, #4
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 8002e30:	f503 738a 	add.w	r3, r3, #276	; 0x114
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 8002e34:	f884 1036 	strb.w	r1, [r4, #54]	; 0x36
 8002e38:	f884 2037 	strb.w	r2, [r4, #55]	; 0x37
 8002e3c:	f884 6034 	strb.w	r6, [r4, #52]	; 0x34
 8002e40:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
 8002e44:	f884 5038 	strb.w	r5, [r4, #56]	; 0x38
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8002e48:	f884 503d 	strb.w	r5, [r4, #61]	; 0x3d
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
 8002e4c:	62e5      	str	r5, [r4, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 8002e4e:	6425      	str	r5, [r4, #64]	; 0x40
		pxTCB->uxMutexesHeld = 0;
 8002e50:	6465      	str	r5, [r4, #68]	; 0x44
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8002e52:	4638      	mov	r0, r7
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8002e54:	f023 0607 	bic.w	r6, r3, #7
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8002e58:	f001 fa92 	bl	8004380 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 8002e5c:	f104 0018 	add.w	r0, r4, #24
 8002e60:	f001 fa8e 	bl	8004380 <vListInitialiseItem>
	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002e64:	2305      	movs	r3, #5
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
 8002e66:	64a5      	str	r5, [r4, #72]	; 0x48
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8002e68:	462a      	mov	r2, r5
	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002e6a:	61a3      	str	r3, [r4, #24]
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
		pxTCB->eNotifyState = eNotWaitingNotification;
 8002e6c:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8002e70:	492f      	ldr	r1, [pc, #188]	; (8002f30 <vTaskStartScheduler+0x13c>)
 8002e72:	4630      	mov	r0, r6
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
	vListInitialiseItem( &( pxTCB->xEventListItem ) );

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 8002e74:	6124      	str	r4, [r4, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 8002e76:	6264      	str	r4, [r4, #36]	; 0x24
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8002e78:	f7fe febe 	bl	8001bf8 <pxPortInitialiseStack>

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
		{
			uxCurrentNumberOfTasks++;
 8002e7c:	4d2d      	ldr	r5, [pc, #180]	; (8002f34 <vTaskStartScheduler+0x140>)
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8002e7e:	6020      	str	r0, [r4, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
 8002e80:	f7fe ff0c 	bl	8001c9c <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 8002e84:	f8d5 30d0 	ldr.w	r3, [r5, #208]	; 0xd0
 8002e88:	3301      	adds	r3, #1
 8002e8a:	f8c5 30d0 	str.w	r3, [r5, #208]	; 0xd0
			if( pxCurrentTCB == NULL )
 8002e8e:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
 8002e92:	2b00      	cmp	r3, #0
 8002e94:	d03d      	beq.n	8002f12 <vTaskStartScheduler+0x11e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 8002e96:	f8d5 30d8 	ldr.w	r3, [r5, #216]	; 0xd8
 8002e9a:	b92b      	cbnz	r3, 8002ea8 <vTaskStartScheduler+0xb4>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 8002e9c:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
 8002ea0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002ea2:	b90b      	cbnz	r3, 8002ea8 <vTaskStartScheduler+0xb4>
					{
						pxCurrentTCB = pxNewTCB;
 8002ea4:	f8c5 40d4 	str.w	r4, [r5, #212]	; 0xd4
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8002ea8:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8002eaa:	f8d5 20e0 	ldr.w	r2, [r5, #224]	; 0xe0
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 8002eae:	f8d5 30dc 	ldr.w	r3, [r5, #220]	; 0xdc
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8002eb2:	2401      	movs	r4, #1
 8002eb4:	4084      	lsls	r4, r0
 8002eb6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002eba:	4322      	orrs	r2, r4
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 8002ebc:	3301      	adds	r3, #1
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8002ebe:	4639      	mov	r1, r7
 8002ec0:	eb05 0080 	add.w	r0, r5, r0, lsl #2
 8002ec4:	f8c5 20e0 	str.w	r2, [r5, #224]	; 0xe0
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 8002ec8:	f8c5 30dc 	str.w	r3, [r5, #220]	; 0xdc
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8002ecc:	f001 fa5c 	bl	8004388 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 8002ed0:	f7fe ff02 	bl	8001cd8 <vPortExitCritical>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
 8002ed4:	f8d5 20d8 	ldr.w	r2, [r5, #216]	; 0xd8
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 8002ed8:	4b16      	ldr	r3, [pc, #88]	; (8002f34 <vTaskStartScheduler+0x140>)
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
 8002eda:	b10a      	cbz	r2, 8002ee0 <vTaskStartScheduler+0xec>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 8002edc:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
		{
			xReturn = xTimerCreateTimerTask();
 8002ee0:	f000 ffba 	bl	8003e58 <xTimerCreateTimerTask>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 8002ee4:	2801      	cmp	r0, #1

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
		{
			xReturn = xTimerCreateTimerTask();
 8002ee6:	4604      	mov	r4, r0
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 8002ee8:	d10e      	bne.n	8002f08 <vTaskStartScheduler+0x114>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
 8002eea:	f7fe feb5 	bl	8001c58 <ulPortSetInterruptMask>
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
		xSchedulerRunning = pdTRUE;
		xTickCount = ( TickType_t ) 0U;
 8002eee:	2300      	movs	r3, #0
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
 8002ef0:	f04f 32ff 	mov.w	r2, #4294967295
 8002ef4:	f8c5 20ec 	str.w	r2, [r5, #236]	; 0xec
		xSchedulerRunning = pdTRUE;
 8002ef8:	f8c5 40d8 	str.w	r4, [r5, #216]	; 0xd8
		xTickCount = ( TickType_t ) 0U;
 8002efc:	f8c5 30f0 	str.w	r3, [r5, #240]	; 0xf0
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
 8002f00:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 8002f04:	f7fe bf3a 	b.w	8001d7c <xPortStartScheduler>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
 8002f08:	b100      	cbz	r0, 8002f0c <vTaskStartScheduler+0x118>
 8002f0a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002f0c:	f7fe fea4 	bl	8001c58 <ulPortSetInterruptMask>
 8002f10:	e7fe      	b.n	8002f10 <vTaskStartScheduler+0x11c>
			uxCurrentNumberOfTasks++;
			if( pxCurrentTCB == NULL )
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 8002f12:	f8c5 40d4 	str.w	r4, [r5, #212]	; 0xd4

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8002f16:	f8d5 30d0 	ldr.w	r3, [r5, #208]	; 0xd0
 8002f1a:	2b01      	cmp	r3, #1
 8002f1c:	d1c4      	bne.n	8002ea8 <vTaskStartScheduler+0xb4>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
 8002f1e:	f000 ff73 	bl	8003e08 <prvInitialiseTaskLists>
 8002f22:	e7c1      	b.n	8002ea8 <vTaskStartScheduler+0xb4>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
 8002f24:	4628      	mov	r0, r5
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
 8002f26:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
 8002f2a:	f001 ba05 	b.w	8004338 <vPortFree>
 8002f2e:	bf00      	nop
 8002f30:	080032ed 	.word	0x080032ed
 8002f34:	20000040 	.word	0x20000040

08002f38 <vTaskEndScheduler>:
	}
}
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
 8002f38:	b508      	push	{r3, lr}
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
 8002f3a:	f7fe fe8d 	bl	8001c58 <ulPortSetInterruptMask>
	xSchedulerRunning = pdFALSE;
 8002f3e:	4b04      	ldr	r3, [pc, #16]	; (8002f50 <vTaskEndScheduler+0x18>)
 8002f40:	2200      	movs	r2, #0
 8002f42:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
	vPortEndScheduler();
}
 8002f46:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
	xSchedulerRunning = pdFALSE;
	vPortEndScheduler();
 8002f4a:	f7fe be9b 	b.w	8001c84 <vPortEndScheduler>
 8002f4e:	bf00      	nop
 8002f50:	20000040 	.word	0x20000040

08002f54 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 8002f54:	4a03      	ldr	r2, [pc, #12]	; (8002f64 <vTaskSuspendAll+0x10>)
 8002f56:	f8d2 30e8 	ldr.w	r3, [r2, #232]	; 0xe8
 8002f5a:	3301      	adds	r3, #1
 8002f5c:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
 8002f60:	4770      	bx	lr
 8002f62:	bf00      	nop
 8002f64:	20000040 	.word	0x20000040

08002f68 <xTaskGetTickCount>:
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
 8002f68:	4b01      	ldr	r3, [pc, #4]	; (8002f70 <xTaskGetTickCount+0x8>)
 8002f6a:	f8d3 00f0 	ldr.w	r0, [r3, #240]	; 0xf0
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
}
 8002f6e:	4770      	bx	lr
 8002f70:	20000040 	.word	0x20000040

08002f74 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
 8002f74:	b508      	push	{r3, lr}
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8002f76:	f7fe ff49 	bl	8001e0c <vPortValidateInterruptPriority>

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
 8002f7a:	4b02      	ldr	r3, [pc, #8]	; (8002f84 <xTaskGetTickCountFromISR+0x10>)
 8002f7c:	f8d3 00f0 	ldr.w	r0, [r3, #240]	; 0xf0
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
 8002f80:	bd08      	pop	{r3, pc}
 8002f82:	bf00      	nop
 8002f84:	20000040 	.word	0x20000040

08002f88 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
 8002f88:	4b01      	ldr	r3, [pc, #4]	; (8002f90 <uxTaskGetNumberOfTasks+0x8>)
 8002f8a:	f8d3 00d0 	ldr.w	r0, [r3, #208]	; 0xd0
}
 8002f8e:	4770      	bx	lr
 8002f90:	20000040 	.word	0x20000040

08002f94 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 8002f94:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8002f98:	4c44      	ldr	r4, [pc, #272]	; (80030ac <xTaskIncrementTick+0x118>)
 8002f9a:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8002f9e:	b9bb      	cbnz	r3, 8002fd0 <xTaskIncrementTick+0x3c>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
 8002fa0:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
 8002fa4:	3301      	adds	r3, #1
 8002fa6:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 8002faa:	f8d4 70f0 	ldr.w	r7, [r4, #240]	; 0xf0

			if( xConstTickCount == ( TickType_t ) 0U )
 8002fae:	b1ef      	cbz	r7, 8002fec <xTaskIncrementTick+0x58>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
 8002fb0:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 8002fb4:	429f      	cmp	r7, r3
 8002fb6:	d221      	bcs.n	8002ffc <xTaskIncrementTick+0x68>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 8002fb8:	2500      	movs	r5, #0
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8002fba:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 8002fbe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002fc0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8002fc4:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
			{
				xSwitchRequired = pdTRUE;
 8002fc8:	2b02      	cmp	r3, #2
 8002fca:	bf28      	it	cs
 8002fcc:	2501      	movcs	r5, #1
 8002fce:	e005      	b.n	8002fdc <xTaskIncrementTick+0x48>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 8002fd0:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 8002fd4:	2500      	movs	r5, #0
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 8002fd6:	3301      	adds	r3, #1
 8002fd8:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 8002fdc:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
		{
			xSwitchRequired = pdTRUE;
 8002fe0:	2b00      	cmp	r3, #0
 8002fe2:	bf18      	it	ne
 8002fe4:	2501      	movne	r5, #1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 8002fe6:	4628      	mov	r0, r5
 8002fe8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			block. */
			const TickType_t xConstTickCount = xTickCount;

			if( xConstTickCount == ( TickType_t ) 0U )
			{
				taskSWITCH_DELAYED_LISTS();
 8002fec:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 8002ff0:	681b      	ldr	r3, [r3, #0]
 8002ff2:	2b00      	cmp	r3, #0
 8002ff4:	d03b      	beq.n	800306e <xTaskIncrementTick+0xda>
 8002ff6:	f7fe fe2f 	bl	8001c58 <ulPortSetInterruptMask>
 8002ffa:	e7fe      	b.n	8002ffa <xTaskIncrementTick+0x66>
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8002ffc:	f8df a0ac 	ldr.w	sl, [pc, #172]	; 80030ac <xTaskIncrementTick+0x118>
 8003000:	2500      	movs	r5, #0
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 8003002:	f04f 0901 	mov.w	r9, #1
 8003006:	e027      	b.n	8003058 <xTaskIncrementTick+0xc4>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8003008:	f8da 30c8 	ldr.w	r3, [sl, #200]	; 0xc8
 800300c:	68db      	ldr	r3, [r3, #12]
 800300e:	68de      	ldr	r6, [r3, #12]
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 8003010:	6873      	ldr	r3, [r6, #4]
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8003012:	f106 0804 	add.w	r8, r6, #4
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );

						if( xConstTickCount < xItemValue )
 8003016:	429f      	cmp	r7, r3
 8003018:	d326      	bcc.n	8003068 <xTaskIncrementTick+0xd4>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 800301a:	4640      	mov	r0, r8
 800301c:	f001 f9de 	bl	80043dc <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8003020:	6ab3      	ldr	r3, [r6, #40]	; 0x28
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8003022:	f106 0018 	add.w	r0, r6, #24
						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8003026:	b10b      	cbz	r3, 800302c <xTaskIncrementTick+0x98>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8003028:	f001 f9d8 	bl	80043dc <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 800302c:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 800302e:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 8003032:	fa09 f200 	lsl.w	r2, r9, r0
 8003036:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800303a:	4313      	orrs	r3, r2
 800303c:	4641      	mov	r1, r8
 800303e:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 8003042:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
 8003046:	f001 f99f 	bl	8004388 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800304a:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 800304e:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 8003050:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							{
								xSwitchRequired = pdTRUE;
 8003052:	429a      	cmp	r2, r3
 8003054:	bf28      	it	cs
 8003056:	2501      	movcs	r5, #1
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8003058:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 800305c:	4a13      	ldr	r2, [pc, #76]	; (80030ac <xTaskIncrementTick+0x118>)
 800305e:	681b      	ldr	r3, [r3, #0]
 8003060:	2b00      	cmp	r3, #0
 8003062:	d1d1      	bne.n	8003008 <xTaskIncrementTick+0x74>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
 8003064:	f04f 33ff 	mov.w	r3, #4294967295
 8003068:	f8c2 30ec 	str.w	r3, [r2, #236]	; 0xec
						break;
 800306c:	e7a5      	b.n	8002fba <xTaskIncrementTick+0x26>
			block. */
			const TickType_t xConstTickCount = xTickCount;

			if( xConstTickCount == ( TickType_t ) 0U )
			{
				taskSWITCH_DELAYED_LISTS();
 800306e:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 8003072:	f8d4 20cc 	ldr.w	r2, [r4, #204]	; 0xcc
 8003076:	f8c4 20c8 	str.w	r2, [r4, #200]	; 0xc8
 800307a:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
 800307e:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
 8003082:	3301      	adds	r3, #1
 8003084:	f8c4 30f4 	str.w	r3, [r4, #244]	; 0xf4

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8003088:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 800308c:	681b      	ldr	r3, [r3, #0]
 800308e:	b13b      	cbz	r3, 80030a0 <xTaskIncrementTick+0x10c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8003090:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 8003094:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 8003096:	68db      	ldr	r3, [r3, #12]
 8003098:	685b      	ldr	r3, [r3, #4]
 800309a:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 800309e:	e787      	b.n	8002fb0 <xTaskIncrementTick+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 80030a0:	f04f 33ff 	mov.w	r3, #4294967295
 80030a4:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
 80030a8:	e782      	b.n	8002fb0 <xTaskIncrementTick+0x1c>
 80030aa:	bf00      	nop
 80030ac:	20000040 	.word	0x20000040

080030b0 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 80030b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
 80030b4:	4c34      	ldr	r4, [pc, #208]	; (8003188 <xTaskResumeAll+0xd8>)
 80030b6:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 80030ba:	b913      	cbnz	r3, 80030c2 <xTaskResumeAll+0x12>
 80030bc:	f7fe fdcc 	bl	8001c58 <ulPortSetInterruptMask>
 80030c0:	e7fe      	b.n	80030c0 <xTaskResumeAll+0x10>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 80030c2:	f7fe fdeb 	bl	8001c9c <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 80030c6:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 80030ca:	3b01      	subs	r3, #1
 80030cc:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80030d0:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 80030d4:	bbbb      	cbnz	r3, 8003146 <xTaskResumeAll+0x96>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 80030d6:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
 80030da:	b3a3      	cbz	r3, 8003146 <xTaskResumeAll+0x96>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80030dc:	4625      	mov	r5, r4
 80030de:	46a2      	mov	sl, r4
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyList( pxTCB );
 80030e0:	2701      	movs	r7, #1
 80030e2:	e022      	b.n	800312a <xTaskResumeAll+0x7a>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 80030e4:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 80030e8:	68de      	ldr	r6, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 80030ea:	f106 0804 	add.w	r8, r6, #4
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80030ee:	f106 0018 	add.w	r0, r6, #24
 80030f2:	f001 f973 	bl	80043dc <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 80030f6:	4640      	mov	r0, r8
 80030f8:	f001 f970 	bl	80043dc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 80030fc:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 80030fe:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
 8003102:	fa07 f200 	lsl.w	r2, r7, r0
 8003106:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800310a:	4313      	orrs	r3, r2
 800310c:	4641      	mov	r1, r8
 800310e:	eb05 0080 	add.w	r0, r5, r0, lsl #2
 8003112:	f8c5 30e0 	str.w	r3, [r5, #224]	; 0xe0
 8003116:	f001 f937 	bl	8004388 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800311a:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
 800311e:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 8003120:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003122:	429a      	cmp	r2, r3
					{
						xYieldPending = pdTRUE;
 8003124:	bf28      	it	cs
 8003126:	f8ca 90fc 	strcs.w	r9, [sl, #252]	; 0xfc
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 800312a:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyList( pxTCB );
 800312e:	f04f 0901 	mov.w	r9, #1
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8003132:	4b15      	ldr	r3, [pc, #84]	; (8003188 <xTaskResumeAll+0xd8>)
 8003134:	2a00      	cmp	r2, #0
 8003136:	d1d5      	bne.n	80030e4 <xTaskResumeAll+0x34>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
 8003138:	f8d3 20f8 	ldr.w	r2, [r3, #248]	; 0xf8
 800313c:	b94a      	cbnz	r2, 8003152 <xTaskResumeAll+0xa2>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
 800313e:	f8d4 40fc 	ldr.w	r4, [r4, #252]	; 0xfc
 8003142:	2c01      	cmp	r4, #1
 8003144:	d019      	beq.n	800317a <xTaskResumeAll+0xca>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
 8003146:	2400      	movs	r4, #0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 8003148:	f7fe fdc6 	bl	8001cd8 <vPortExitCritical>

	return xAlreadyYielded;
}
 800314c:	4620      	mov	r0, r4
 800314e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 8003152:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 8003156:	2b00      	cmp	r3, #0
 8003158:	d0f1      	beq.n	800313e <xTaskResumeAll+0x8e>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
 800315a:	2501      	movs	r5, #1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
 800315c:	f7ff ff1a 	bl	8002f94 <xTaskIncrementTick>
 8003160:	b108      	cbz	r0, 8003166 <xTaskResumeAll+0xb6>
						{
							xYieldPending = pdTRUE;
 8003162:	f8c4 50fc 	str.w	r5, [r4, #252]	; 0xfc
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
 8003166:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 800316a:	3b01      	subs	r3, #1
 800316c:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 8003170:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 8003174:	2b00      	cmp	r3, #0
 8003176:	d1f1      	bne.n	800315c <xTaskResumeAll+0xac>
 8003178:	e7e1      	b.n	800313e <xTaskResumeAll+0x8e>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 800317a:	f7fe fd61 	bl	8001c40 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 800317e:	f7fe fdab 	bl	8001cd8 <vPortExitCritical>

	return xAlreadyYielded;
}
 8003182:	4620      	mov	r0, r4
 8003184:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8003188:	20000040 	.word	0x20000040

0800318c <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
 800318c:	b570      	push	{r4, r5, r6, lr}
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
 800318e:	2800      	cmp	r0, #0
 8003190:	d052      	beq.n	8003238 <vTaskDelayUntil+0xac>
		configASSERT( ( xTimeIncrement > 0U ) );
 8003192:	2900      	cmp	r1, #0
 8003194:	d04d      	beq.n	8003232 <vTaskDelayUntil+0xa6>
		configASSERT( uxSchedulerSuspended == 0 );
 8003196:	4d2e      	ldr	r5, [pc, #184]	; (8003250 <vTaskDelayUntil+0xc4>)
 8003198:	f8d5 30e8 	ldr.w	r3, [r5, #232]	; 0xe8
 800319c:	2b00      	cmp	r3, #0
 800319e:	d145      	bne.n	800322c <vTaskDelayUntil+0xa0>
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 80031a0:	f8d5 20e8 	ldr.w	r2, [r5, #232]	; 0xe8
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 80031a4:	6803      	ldr	r3, [r0, #0]
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 80031a6:	3201      	adds	r2, #1
 80031a8:	f8c5 20e8 	str.w	r2, [r5, #232]	; 0xe8

		vTaskSuspendAll();
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 80031ac:	f8d5 20f0 	ldr.w	r2, [r5, #240]	; 0xf0

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 80031b0:	185c      	adds	r4, r3, r1

			if( xConstTickCount < *pxPreviousWakeTime )
 80031b2:	429a      	cmp	r2, r3
 80031b4:	d32f      	bcc.n	8003216 <vTaskDelayUntil+0x8a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 80031b6:	42a3      	cmp	r3, r4
 80031b8:	d801      	bhi.n	80031be <vTaskDelayUntil+0x32>
 80031ba:	42a2      	cmp	r2, r4
 80031bc:	d22d      	bcs.n	800321a <vTaskDelayUntil+0x8e>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 80031be:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 80031c2:	6004      	str	r4, [r0, #0]
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 80031c4:	1d18      	adds	r0, r3, #4
 80031c6:	4e22      	ldr	r6, [pc, #136]	; (8003250 <vTaskDelayUntil+0xc4>)
 80031c8:	f001 f908 	bl	80043dc <uxListRemove>
 80031cc:	b950      	cbnz	r0, 80031e4 <vTaskDelayUntil+0x58>
				{
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 80031ce:	f8d6 30d4 	ldr.w	r3, [r6, #212]	; 0xd4
 80031d2:	2201      	movs	r2, #1
 80031d4:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 80031d6:	f8d6 30e0 	ldr.w	r3, [r6, #224]	; 0xe0
 80031da:	408a      	lsls	r2, r1
 80031dc:	ea23 0302 	bic.w	r3, r3, r2
 80031e0:	f8c6 30e0 	str.w	r3, [r6, #224]	; 0xe0
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 80031e4:	f8d5 20d4 	ldr.w	r2, [r5, #212]	; 0xd4

	if( xTimeToWake < xTickCount )
 80031e8:	f8d5 30f0 	ldr.w	r3, [r5, #240]	; 0xf0
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 80031ec:	6054      	str	r4, [r2, #4]

	if( xTimeToWake < xTickCount )
 80031ee:	429c      	cmp	r4, r3
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 80031f0:	4d17      	ldr	r5, [pc, #92]	; (8003250 <vTaskDelayUntil+0xc4>)

	if( xTimeToWake < xTickCount )
 80031f2:	d324      	bcc.n	800323e <vTaskDelayUntil+0xb2>
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 80031f4:	f8d5 00c8 	ldr.w	r0, [r5, #200]	; 0xc8
 80031f8:	f8d5 10d4 	ldr.w	r1, [r5, #212]	; 0xd4
 80031fc:	3104      	adds	r1, #4
 80031fe:	f001 f8d3 	bl	80043a8 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 8003202:	f8d5 30ec 	ldr.w	r3, [r5, #236]	; 0xec
 8003206:	429c      	cmp	r4, r3
		{
			xNextTaskUnblockTime = xTimeToWake;
 8003208:	bf38      	it	cc
 800320a:	f8c5 40ec 	strcc.w	r4, [r5, #236]	; 0xec
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 800320e:	f7ff ff4f 	bl	80030b0 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 8003212:	b138      	cbz	r0, 8003224 <vTaskDelayUntil+0x98>
 8003214:	bd70      	pop	{r4, r5, r6, pc}
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 8003216:	42a3      	cmp	r3, r4
 8003218:	d8cf      	bhi.n	80031ba <vTaskDelayUntil+0x2e>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 800321a:	6004      	str	r4, [r0, #0]
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 800321c:	f7ff ff48 	bl	80030b0 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 8003220:	2800      	cmp	r0, #0
 8003222:	d1f7      	bne.n	8003214 <vTaskDelayUntil+0x88>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 8003224:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
 8003228:	f7fe bd0a 	b.w	8001c40 <vPortYield>
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );
 800322c:	f7fe fd14 	bl	8001c58 <ulPortSetInterruptMask>
 8003230:	e7fe      	b.n	8003230 <vTaskDelayUntil+0xa4>
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
 8003232:	f7fe fd11 	bl	8001c58 <ulPortSetInterruptMask>
 8003236:	e7fe      	b.n	8003236 <vTaskDelayUntil+0xaa>
	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
 8003238:	f7fe fd0e 	bl	8001c58 <ulPortSetInterruptMask>
 800323c:	e7fe      	b.n	800323c <vTaskDelayUntil+0xb0>
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 800323e:	f8d5 00cc 	ldr.w	r0, [r5, #204]	; 0xcc
 8003242:	f8d5 10d4 	ldr.w	r1, [r5, #212]	; 0xd4
 8003246:	3104      	adds	r1, #4
 8003248:	f001 f8ae 	bl	80043a8 <vListInsert>
 800324c:	e7df      	b.n	800320e <vTaskDelayUntil+0x82>
 800324e:	bf00      	nop
 8003250:	20000040 	.word	0x20000040

08003254 <vTaskDelay>:
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 8003254:	b3b8      	cbz	r0, 80032c6 <vTaskDelay+0x72>
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 8003256:	b538      	push	{r3, r4, r5, lr}


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
 8003258:	4c23      	ldr	r4, [pc, #140]	; (80032e8 <vTaskDelay+0x94>)
 800325a:	4603      	mov	r3, r0
 800325c:	f8d4 20e8 	ldr.w	r2, [r4, #232]	; 0xe8
 8003260:	bb9a      	cbnz	r2, 80032ca <vTaskDelay+0x76>
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 8003262:	f8d4 20e8 	ldr.w	r2, [r4, #232]	; 0xe8
 8003266:	3201      	adds	r2, #1
 8003268:	f8c4 20e8 	str.w	r2, [r4, #232]	; 0xe8
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 800326c:	f8d4 50f0 	ldr.w	r5, [r4, #240]	; 0xf0

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8003270:	f8d4 00d4 	ldr.w	r0, [r4, #212]	; 0xd4
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 8003274:	441d      	add	r5, r3

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8003276:	3004      	adds	r0, #4
 8003278:	f001 f8b0 	bl	80043dc <uxListRemove>
 800327c:	b950      	cbnz	r0, 8003294 <vTaskDelay+0x40>
				{
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 800327e:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 8003282:	2201      	movs	r2, #1
 8003284:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8003286:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 800328a:	408a      	lsls	r2, r1
 800328c:	ea23 0302 	bic.w	r3, r3, r2
 8003290:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8003294:	f8d4 20d4 	ldr.w	r2, [r4, #212]	; 0xd4

	if( xTimeToWake < xTickCount )
 8003298:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 800329c:	6055      	str	r5, [r2, #4]

	if( xTimeToWake < xTickCount )
 800329e:	429d      	cmp	r5, r3
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 80032a0:	4c11      	ldr	r4, [pc, #68]	; (80032e8 <vTaskDelay+0x94>)

	if( xTimeToWake < xTickCount )
 80032a2:	d319      	bcc.n	80032d8 <vTaskDelay+0x84>
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 80032a4:	f8d4 00c8 	ldr.w	r0, [r4, #200]	; 0xc8
 80032a8:	f8d4 10d4 	ldr.w	r1, [r4, #212]	; 0xd4
 80032ac:	3104      	adds	r1, #4
 80032ae:	f001 f87b 	bl	80043a8 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 80032b2:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 80032b6:	429d      	cmp	r5, r3
		{
			xNextTaskUnblockTime = xTimeToWake;
 80032b8:	bf38      	it	cc
 80032ba:	f8c4 50ec 	strcc.w	r5, [r4, #236]	; 0xec
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
			}
			xAlreadyYielded = xTaskResumeAll();
 80032be:	f7ff fef7 	bl	80030b0 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 80032c2:	b128      	cbz	r0, 80032d0 <vTaskDelay+0x7c>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 80032c4:	bd38      	pop	{r3, r4, r5, pc}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
 80032c6:	f7fe bcbb 	b.w	8001c40 <vPortYield>


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
 80032ca:	f7fe fcc5 	bl	8001c58 <ulPortSetInterruptMask>
 80032ce:	e7fe      	b.n	80032ce <vTaskDelay+0x7a>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 80032d0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
 80032d4:	f7fe bcb4 	b.w	8001c40 <vPortYield>
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 80032d8:	f8d4 00cc 	ldr.w	r0, [r4, #204]	; 0xcc
 80032dc:	f8d4 10d4 	ldr.w	r1, [r4, #212]	; 0xd4
 80032e0:	3104      	adds	r1, #4
 80032e2:	f001 f861 	bl	80043a8 <vListInsert>
 80032e6:	e7ea      	b.n	80032be <vTaskDelay+0x6a>
 80032e8:	20000040 	.word	0x20000040

080032ec <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 80032ec:	4e1b      	ldr	r6, [pc, #108]	; (800335c <prvIdleTask+0x70>)
 80032ee:	b580      	push	{r7, lr}
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
 80032f0:	4634      	mov	r4, r6
 80032f2:	4637      	mov	r7, r6
 80032f4:	46b0      	mov	r8, r6
 80032f6:	e009      	b.n	800330c <prvIdleTask+0x20>
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 80032f8:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 80032fc:	f8d4 50a0 	ldr.w	r5, [r4, #160]	; 0xa0
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 8003300:	3301      	adds	r3, #1
 8003302:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
			}
			( void ) xTaskResumeAll();
 8003306:	f7ff fed3 	bl	80030b0 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 800330a:	b965      	cbnz	r5, 8003326 <prvIdleTask+0x3a>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
 800330c:	f8d6 30e4 	ldr.w	r3, [r6, #228]	; 0xe4
 8003310:	2b00      	cmp	r3, #0
 8003312:	d1f1      	bne.n	80032f8 <prvIdleTask+0xc>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8003314:	f8d8 3000 	ldr.w	r3, [r8]
 8003318:	2b01      	cmp	r3, #1
 800331a:	d901      	bls.n	8003320 <prvIdleTask+0x34>
			{
				taskYIELD();
 800331c:	f7fe fc90 	bl	8001c40 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
 8003320:	f7fd f828 	bl	8000374 <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
 8003324:	e7f2      	b.n	800330c <prvIdleTask+0x20>

			if( xListIsEmpty == pdFALSE )
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 8003326:	f7fe fcb9 	bl	8001c9c <vPortEnterCritical>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 800332a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800332e:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8003330:	1d28      	adds	r0, r5, #4
 8003332:	f001 f853 	bl	80043dc <uxListRemove>
					--uxCurrentNumberOfTasks;
 8003336:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 800333a:	3b01      	subs	r3, #1
 800333c:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
					--uxTasksDeleted;
 8003340:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8003344:	3b01      	subs	r3, #1
 8003346:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
				}
				taskEXIT_CRITICAL();
 800334a:	f7fe fcc5 	bl	8001cd8 <vPortExitCritical>
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
 800334e:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8003350:	f000 fff2 	bl	8004338 <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
 8003354:	4628      	mov	r0, r5
 8003356:	f000 ffef 	bl	8004338 <vPortFree>
 800335a:	e7d7      	b.n	800330c <prvIdleTask+0x20>
 800335c:	20000040 	.word	0x20000040

08003360 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 8003360:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8003362:	4c22      	ldr	r4, [pc, #136]	; (80033ec <vTaskSwitchContext+0x8c>)
 8003364:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8003368:	2b00      	cmp	r3, #0
 800336a:	d13b      	bne.n	80033e4 <vTaskSwitchContext+0x84>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
 800336c:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
				ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();
 8003370:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 8003374:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003376:	681a      	ldr	r2, [r3, #0]
 8003378:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 800337c:	d022      	beq.n	80033c4 <vTaskSwitchContext+0x64>
 800337e:	f8d4 00d4 	ldr.w	r0, [r4, #212]	; 0xd4
 8003382:	f8d4 10d4 	ldr.w	r1, [r4, #212]	; 0xd4
 8003386:	3134      	adds	r1, #52	; 0x34
 8003388:	f7fc fff6 	bl	8000378 <vApplicationStackOverflowHook>

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800338c:	4817      	ldr	r0, [pc, #92]	; (80033ec <vTaskSwitchContext+0x8c>)
 800338e:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
	{
	uint8_t ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 8003392:	fab3 f383 	clz	r3, r3
 8003396:	b2db      	uxtb	r3, r3
 8003398:	f1c3 031f 	rsb	r3, r3, #31
 800339c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80033a0:	009b      	lsls	r3, r3, #2
 80033a2:	58e2      	ldr	r2, [r4, r3]
 80033a4:	18e1      	adds	r1, r4, r3
 80033a6:	b1d2      	cbz	r2, 80033de <vTaskSwitchContext+0x7e>
 80033a8:	684a      	ldr	r2, [r1, #4]
 80033aa:	3308      	adds	r3, #8
 80033ac:	6852      	ldr	r2, [r2, #4]
 80033ae:	4403      	add	r3, r0
 80033b0:	429a      	cmp	r2, r3
 80033b2:	604a      	str	r2, [r1, #4]
 80033b4:	bf08      	it	eq
 80033b6:	6852      	ldreq	r2, [r2, #4]
 80033b8:	68d3      	ldr	r3, [r2, #12]
 80033ba:	bf08      	it	eq
 80033bc:	604a      	streq	r2, [r1, #4]
 80033be:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4
 80033c2:	bd10      	pop	{r4, pc}
				ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();
 80033c4:	685a      	ldr	r2, [r3, #4]
 80033c6:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 80033ca:	d1d8      	bne.n	800337e <vTaskSwitchContext+0x1e>
 80033cc:	689a      	ldr	r2, [r3, #8]
 80033ce:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 80033d2:	d1d4      	bne.n	800337e <vTaskSwitchContext+0x1e>
 80033d4:	68db      	ldr	r3, [r3, #12]
 80033d6:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
 80033da:	d1d0      	bne.n	800337e <vTaskSwitchContext+0x1e>
 80033dc:	e7d6      	b.n	800338c <vTaskSwitchContext+0x2c>

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 80033de:	f7fe fc3b 	bl	8001c58 <ulPortSetInterruptMask>
 80033e2:	e7fe      	b.n	80033e2 <vTaskSwitchContext+0x82>
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 80033e4:	2301      	movs	r3, #1
 80033e6:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
 80033ea:	bd10      	pop	{r4, pc}
 80033ec:	20000040 	.word	0x20000040

080033f0 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
 80033f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80033f2:	4605      	mov	r5, r0

		taskENTER_CRITICAL();
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 80033f4:	4e31      	ldr	r6, [pc, #196]	; (80034bc <vTaskSuspend+0xcc>)

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 80033f6:	f7fe fc51 	bl	8001c9c <vPortEnterCritical>
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 80033fa:	2d00      	cmp	r5, #0
 80033fc:	d043      	beq.n	8003486 <vTaskSuspend+0x96>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 80033fe:	1d2f      	adds	r7, r5, #4
 8003400:	4638      	mov	r0, r7
 8003402:	f000 ffeb 	bl	80043dc <uxListRemove>
 8003406:	b930      	cbnz	r0, 8003416 <vTaskSuspend+0x26>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8003408:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 800340a:	482c      	ldr	r0, [pc, #176]	; (80034bc <vTaskSuspend+0xcc>)
 800340c:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 8003410:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
 8003414:	b1ab      	cbz	r3, 8003442 <vTaskSuspend+0x52>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8003416:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8003418:	b11b      	cbz	r3, 8003422 <vTaskSuspend+0x32>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800341a:	f105 0018 	add.w	r0, r5, #24
 800341e:	f000 ffdd 	bl	80043dc <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 8003422:	4c26      	ldr	r4, [pc, #152]	; (80034bc <vTaskSuspend+0xcc>)
 8003424:	4639      	mov	r1, r7
 8003426:	f104 00b4 	add.w	r0, r4, #180	; 0xb4
 800342a:	f000 ffad 	bl	8004388 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
 800342e:	f7fe fc53 	bl	8001cd8 <vPortExitCritical>

		if( pxTCB == pxCurrentTCB )
 8003432:	f8d6 30d4 	ldr.w	r3, [r6, #212]	; 0xd4
 8003436:	429d      	cmp	r5, r3
		{
			if( xSchedulerRunning != pdFALSE )
 8003438:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
		}
		taskEXIT_CRITICAL();

		if( pxTCB == pxCurrentTCB )
 800343c:	d026      	beq.n	800348c <vTaskSuspend+0x9c>
				}
			}
		}
		else
		{
			if( xSchedulerRunning != pdFALSE )
 800343e:	b94b      	cbnz	r3, 8003454 <vTaskSuspend+0x64>
 8003440:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8003442:	f8d0 30e0 	ldr.w	r3, [r0, #224]	; 0xe0
 8003446:	2201      	movs	r2, #1
 8003448:	408a      	lsls	r2, r1
 800344a:	ea23 0302 	bic.w	r3, r3, r2
 800344e:	f8c0 30e0 	str.w	r3, [r0, #224]	; 0xe0
 8003452:	e7e0      	b.n	8003416 <vTaskSuspend+0x26>
			if( xSchedulerRunning != pdFALSE )
			{
				/* A task other than the currently running task was suspended,
				reset the next expected unblock time in case it referred to the
				task that is now in the Suspended state. */
				taskENTER_CRITICAL();
 8003454:	f7fe fc22 	bl	8001c9c <vPortEnterCritical>

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8003458:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 800345c:	681b      	ldr	r3, [r3, #0]
 800345e:	b93b      	cbnz	r3, 8003470 <vTaskSuspend+0x80>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8003460:	f04f 33ff 	mov.w	r3, #4294967295
 8003464:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 8003468:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				task that is now in the Suspended state. */
				taskENTER_CRITICAL();
				{
					prvResetNextTaskUnblockTime();
				}
				taskEXIT_CRITICAL();
 800346c:	f7fe bc34 	b.w	8001cd8 <vPortExitCritical>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8003470:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 8003474:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 8003476:	68db      	ldr	r3, [r3, #12]
 8003478:	685b      	ldr	r3, [r3, #4]
 800347a:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 800347e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				task that is now in the Suspended state. */
				taskENTER_CRITICAL();
				{
					prvResetNextTaskUnblockTime();
				}
				taskEXIT_CRITICAL();
 8003482:	f7fe bc29 	b.w	8001cd8 <vPortExitCritical>

		taskENTER_CRITICAL();
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 8003486:	f8d6 50d4 	ldr.w	r5, [r6, #212]	; 0xd4
 800348a:	e7b8      	b.n	80033fe <vTaskSuspend+0xe>
		}
		taskEXIT_CRITICAL();

		if( pxTCB == pxCurrentTCB )
		{
			if( xSchedulerRunning != pdFALSE )
 800348c:	b12b      	cbz	r3, 800349a <vTaskSuspend+0xaa>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
 800348e:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8003492:	b15b      	cbz	r3, 80034ac <vTaskSuspend+0xbc>
 8003494:	f7fe fbe0 	bl	8001c58 <ulPortSetInterruptMask>
 8003498:	e7fe      	b.n	8003498 <vTaskSuspend+0xa8>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 800349a:	f8d4 20d0 	ldr.w	r2, [r4, #208]	; 0xd0
 800349e:	f8d4 10b4 	ldr.w	r1, [r4, #180]	; 0xb4
 80034a2:	4291      	cmp	r1, r2
 80034a4:	d106      	bne.n	80034b4 <vTaskSuspend+0xc4>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
 80034a6:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4
 80034aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 80034ac:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		{
			if( xSchedulerRunning != pdFALSE )
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
 80034b0:	f7fe bbc6 	b.w	8001c40 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 80034b4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
 80034b8:	f7ff bf52 	b.w	8003360 <vTaskSwitchContext>
 80034bc:	20000040 	.word	0x20000040

080034c0 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
 80034c0:	b538      	push	{r3, r4, r5, lr}
TickType_t xTimeToWake;

	configASSERT( pxEventList );
 80034c2:	2800      	cmp	r0, #0
 80034c4:	d043      	beq.n	800354e <vTaskPlaceOnEventList+0x8e>

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80034c6:	4c23      	ldr	r4, [pc, #140]	; (8003554 <vTaskPlaceOnEventList+0x94>)
 80034c8:	460d      	mov	r5, r1
 80034ca:	f8d4 10d4 	ldr.w	r1, [r4, #212]	; 0xd4
 80034ce:	3118      	adds	r1, #24
 80034d0:	f000 ff6a 	bl	80043a8 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 80034d4:	f8d4 00d4 	ldr.w	r0, [r4, #212]	; 0xd4
 80034d8:	3004      	adds	r0, #4
 80034da:	f000 ff7f 	bl	80043dc <uxListRemove>
 80034de:	b950      	cbnz	r0, 80034f6 <vTaskPlaceOnEventList+0x36>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 80034e0:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 80034e4:	2201      	movs	r2, #1
 80034e6:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 80034e8:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 80034ec:	408a      	lsls	r2, r1
 80034ee:	ea23 0302 	bic.w	r3, r3, r2
 80034f2:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
 80034f6:	1c6b      	adds	r3, r5, #1
 80034f8:	d021      	beq.n	800353e <vTaskPlaceOnEventList+0x7e>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
 80034fa:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 80034fe:	f8d4 10d4 	ldr.w	r1, [r4, #212]	; 0xd4

	if( xTimeToWake < xTickCount )
 8003502:	f8d4 20f0 	ldr.w	r2, [r4, #240]	; 0xf0
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
 8003506:	441d      	add	r5, r3
static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
 8003508:	4295      	cmp	r5, r2
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 800350a:	604d      	str	r5, [r1, #4]
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
 800350c:	4c11      	ldr	r4, [pc, #68]	; (8003554 <vTaskPlaceOnEventList+0x94>)
static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
 800350e:	d30d      	bcc.n	800352c <vTaskPlaceOnEventList+0x6c>
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8003510:	f8d4 00c8 	ldr.w	r0, [r4, #200]	; 0xc8
 8003514:	f8d4 10d4 	ldr.w	r1, [r4, #212]	; 0xd4
 8003518:	3104      	adds	r1, #4
 800351a:	f000 ff45 	bl	80043a8 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 800351e:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 8003522:	429d      	cmp	r5, r3
		{
			xNextTaskUnblockTime = xTimeToWake;
 8003524:	bf38      	it	cc
 8003526:	f8c4 50ec 	strcc.w	r5, [r4, #236]	; 0xec
 800352a:	bd38      	pop	{r3, r4, r5, pc}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 800352c:	f8d4 00cc 	ldr.w	r0, [r4, #204]	; 0xcc
 8003530:	f8d4 10d4 	ldr.w	r1, [r4, #212]	; 0xd4
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8003534:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8003538:	3104      	adds	r1, #4
 800353a:	f000 bf35 	b.w	80043a8 <vListInsert>
		if( xTicksToWait == portMAX_DELAY )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 800353e:	f8d4 10d4 	ldr.w	r1, [r4, #212]	; 0xd4
 8003542:	4805      	ldr	r0, [pc, #20]	; (8003558 <vTaskPlaceOnEventList+0x98>)
 8003544:	3104      	adds	r1, #4
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8003546:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		if( xTicksToWait == portMAX_DELAY )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 800354a:	f000 bf1d 	b.w	8004388 <vListInsertEnd>

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
TickType_t xTimeToWake;

	configASSERT( pxEventList );
 800354e:	f7fe fb83 	bl	8001c58 <ulPortSetInterruptMask>
 8003552:	e7fe      	b.n	8003552 <vTaskPlaceOnEventList+0x92>
 8003554:	20000040 	.word	0x20000040
 8003558:	200000f4 	.word	0x200000f4

0800355c <vTaskPlaceOnUnorderedEventList>:
	#endif /* INCLUDE_vTaskSuspend */
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
 800355c:	b570      	push	{r4, r5, r6, lr}
TickType_t xTimeToWake;

	configASSERT( pxEventList );
 800355e:	2800      	cmp	r0, #0
 8003560:	d03e      	beq.n	80035e0 <vTaskPlaceOnUnorderedEventList+0x84>

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event groups implementation. */
	configASSERT( uxSchedulerSuspended != 0 );
 8003562:	4c29      	ldr	r4, [pc, #164]	; (8003608 <vTaskPlaceOnUnorderedEventList+0xac>)
 8003564:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8003568:	b913      	cbnz	r3, 8003570 <vTaskPlaceOnUnorderedEventList+0x14>
 800356a:	f7fe fb75 	bl	8001c58 <ulPortSetInterruptMask>
 800356e:	e7fe      	b.n	800356e <vTaskPlaceOnUnorderedEventList+0x12>

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 8003570:	f8d4 60d4 	ldr.w	r6, [r4, #212]	; 0xd4
 8003574:	4615      	mov	r5, r2
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8003576:	f8d4 20d4 	ldr.w	r2, [r4, #212]	; 0xd4
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 800357a:	f041 4300 	orr.w	r3, r1, #2147483648	; 0x80000000
 800357e:	61b3      	str	r3, [r6, #24]
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8003580:	f102 0118 	add.w	r1, r2, #24
 8003584:	f000 ff00 	bl	8004388 <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8003588:	f8d4 00d4 	ldr.w	r0, [r4, #212]	; 0xd4
 800358c:	3004      	adds	r0, #4
 800358e:	f000 ff25 	bl	80043dc <uxListRemove>
 8003592:	b950      	cbnz	r0, 80035aa <vTaskPlaceOnUnorderedEventList+0x4e>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 8003594:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 8003598:	2101      	movs	r1, #1
 800359a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800359c:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 80035a0:	4091      	lsls	r1, r2
 80035a2:	ea23 0301 	bic.w	r3, r3, r1
 80035a6:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
 80035aa:	1c6b      	adds	r3, r5, #1
 80035ac:	d024      	beq.n	80035f8 <vTaskPlaceOnUnorderedEventList+0x9c>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
 80035ae:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 80035b2:	f8d4 10d4 	ldr.w	r1, [r4, #212]	; 0xd4

	if( xTimeToWake < xTickCount )
 80035b6:	f8d4 20f0 	ldr.w	r2, [r4, #240]	; 0xf0
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
 80035ba:	441d      	add	r5, r3
static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
 80035bc:	4295      	cmp	r5, r2
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 80035be:	604d      	str	r5, [r1, #4]
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
 80035c0:	4c11      	ldr	r4, [pc, #68]	; (8003608 <vTaskPlaceOnUnorderedEventList+0xac>)
static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
 80035c2:	d310      	bcc.n	80035e6 <vTaskPlaceOnUnorderedEventList+0x8a>
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 80035c4:	f8d4 00c8 	ldr.w	r0, [r4, #200]	; 0xc8
 80035c8:	f8d4 10d4 	ldr.w	r1, [r4, #212]	; 0xd4
 80035cc:	3104      	adds	r1, #4
 80035ce:	f000 feeb 	bl	80043a8 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 80035d2:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 80035d6:	429d      	cmp	r5, r3
		{
			xNextTaskUnblockTime = xTimeToWake;
 80035d8:	bf38      	it	cc
 80035da:	f8c4 50ec 	strcc.w	r5, [r4, #236]	; 0xec
 80035de:	bd70      	pop	{r4, r5, r6, pc}

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
TickType_t xTimeToWake;

	configASSERT( pxEventList );
 80035e0:	f7fe fb3a 	bl	8001c58 <ulPortSetInterruptMask>
 80035e4:	e7fe      	b.n	80035e4 <vTaskPlaceOnUnorderedEventList+0x88>
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 80035e6:	f8d4 00cc 	ldr.w	r0, [r4, #204]	; 0xcc
 80035ea:	f8d4 10d4 	ldr.w	r1, [r4, #212]	; 0xd4
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 80035ee:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 80035f2:	3104      	adds	r1, #4
 80035f4:	f000 bed8 	b.w	80043a8 <vListInsert>
		if( xTicksToWait == portMAX_DELAY )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 80035f8:	f8d4 10d4 	ldr.w	r1, [r4, #212]	; 0xd4
 80035fc:	4803      	ldr	r0, [pc, #12]	; (800360c <vTaskPlaceOnUnorderedEventList+0xb0>)
 80035fe:	3104      	adds	r1, #4
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8003600:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		if( xTicksToWait == portMAX_DELAY )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8003604:	f000 bec0 	b.w	8004388 <vListInsertEnd>
 8003608:	20000040 	.word	0x20000040
 800360c:	200000f4 	.word	0x200000f4

08003610 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 8003610:	b570      	push	{r4, r5, r6, lr}
	TickType_t xTimeToWake;

		configASSERT( pxEventList );
 8003612:	2800      	cmp	r0, #0
 8003614:	d044      	beq.n	80036a0 <vTaskPlaceOnEventListRestricted+0x90>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8003616:	4c24      	ldr	r4, [pc, #144]	; (80036a8 <vTaskPlaceOnEventListRestricted+0x98>)
 8003618:	460d      	mov	r5, r1
 800361a:	f8d4 10d4 	ldr.w	r1, [r4, #212]	; 0xd4
 800361e:	4616      	mov	r6, r2
 8003620:	3118      	adds	r1, #24
 8003622:	f000 feb1 	bl	8004388 <vListInsertEnd>

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called with the scheduler locked so interrupts will not
		access the lists at the same time. */
		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8003626:	f8d4 00d4 	ldr.w	r0, [r4, #212]	; 0xd4
 800362a:	3004      	adds	r0, #4
 800362c:	f000 fed6 	bl	80043dc <uxListRemove>
 8003630:	b950      	cbnz	r0, 8003648 <vTaskPlaceOnEventListRestricted+0x38>
		{
			/* The current task must be in a ready list, so there is no need to
			check, and the port reset macro can be called directly. */
			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 8003632:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 8003636:	2101      	movs	r1, #1
 8003638:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800363a:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 800363e:	4091      	lsls	r1, r2
 8003640:	ea23 0301 	bic.w	r3, r3, r1
 8003644:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
		Ready state when the event it is waiting indefinitely for occurs).
		Blocking indefinitely is useful when using tickless idle mode as when
		all tasks are blocked indefinitely all timers can be turned off. */
		#if( INCLUDE_vTaskSuspend == 1 )
		{
			if( xWaitIndefinitely == pdTRUE )
 8003648:	2e01      	cmp	r6, #1
 800364a:	d021      	beq.n	8003690 <vTaskPlaceOnEventListRestricted+0x80>
			else
			{
				/* Calculate the time at which the task should be woken if the
				event does not occur.  This may overflow but this doesn't
				matter. */
				xTimeToWake = xTickCount + xTicksToWait;
 800364c:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8003650:	f8d4 10d4 	ldr.w	r1, [r4, #212]	; 0xd4

	if( xTimeToWake < xTickCount )
 8003654:	f8d4 20f0 	ldr.w	r2, [r4, #240]	; 0xf0
			else
			{
				/* Calculate the time at which the task should be woken if the
				event does not occur.  This may overflow but this doesn't
				matter. */
				xTimeToWake = xTickCount + xTicksToWait;
 8003658:	441d      	add	r5, r3
static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
 800365a:	4295      	cmp	r5, r2
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 800365c:	604d      	str	r5, [r1, #4]
			else
			{
				/* Calculate the time at which the task should be woken if the
				event does not occur.  This may overflow but this doesn't
				matter. */
				xTimeToWake = xTickCount + xTicksToWait;
 800365e:	4c12      	ldr	r4, [pc, #72]	; (80036a8 <vTaskPlaceOnEventListRestricted+0x98>)
static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
 8003660:	d30d      	bcc.n	800367e <vTaskPlaceOnEventListRestricted+0x6e>
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8003662:	f8d4 00c8 	ldr.w	r0, [r4, #200]	; 0xc8
 8003666:	f8d4 10d4 	ldr.w	r1, [r4, #212]	; 0xd4
 800366a:	3104      	adds	r1, #4
 800366c:	f000 fe9c 	bl	80043a8 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 8003670:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 8003674:	429d      	cmp	r5, r3
		{
			xNextTaskUnblockTime = xTimeToWake;
 8003676:	bf38      	it	cc
 8003678:	f8c4 50ec 	strcc.w	r5, [r4, #236]	; 0xec
 800367c:	bd70      	pop	{r4, r5, r6, pc}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 800367e:	f8d4 00cc 	ldr.w	r0, [r4, #204]	; 0xcc
 8003682:	f8d4 10d4 	ldr.w	r1, [r4, #212]	; 0xd4
			/* Remove compiler warnings when INCLUDE_vTaskSuspend() is not
			defined. */
			( void ) xWaitIndefinitely;
		}
		#endif
	}
 8003686:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 800368a:	3104      	adds	r1, #4
 800368c:	f000 be8c 	b.w	80043a8 <vListInsert>
			if( xWaitIndefinitely == pdTRUE )
			{
				/* Add the task to the suspended task list instead of a delayed
				task list to ensure the task is not woken by a timing event.  It
				will block indefinitely. */
				vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8003690:	f8d4 10d4 	ldr.w	r1, [r4, #212]	; 0xd4
 8003694:	4805      	ldr	r0, [pc, #20]	; (80036ac <vTaskPlaceOnEventListRestricted+0x9c>)
 8003696:	3104      	adds	r1, #4
			/* Remove compiler warnings when INCLUDE_vTaskSuspend() is not
			defined. */
			( void ) xWaitIndefinitely;
		}
		#endif
	}
 8003698:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			if( xWaitIndefinitely == pdTRUE )
			{
				/* Add the task to the suspended task list instead of a delayed
				task list to ensure the task is not woken by a timing event.  It
				will block indefinitely. */
				vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 800369c:	f000 be74 	b.w	8004388 <vListInsertEnd>

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
	TickType_t xTimeToWake;

		configASSERT( pxEventList );
 80036a0:	f7fe fada 	bl	8001c58 <ulPortSetInterruptMask>
 80036a4:	e7fe      	b.n	80036a4 <vTaskPlaceOnEventListRestricted+0x94>
 80036a6:	bf00      	nop
 80036a8:	20000040 	.word	0x20000040
 80036ac:	200000f4 	.word	0x200000f4

080036b0 <xTaskRemoveFromEventList>:
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 80036b0:	68c3      	ldr	r3, [r0, #12]

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 80036b2:	b570      	push	{r4, r5, r6, lr}
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 80036b4:	68dd      	ldr	r5, [r3, #12]
	configASSERT( pxUnblockedTCB );
 80036b6:	b36d      	cbz	r5, 8003714 <xTaskRemoveFromEventList+0x64>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 80036b8:	f105 0618 	add.w	r6, r5, #24

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80036bc:	4c17      	ldr	r4, [pc, #92]	; (800371c <xTaskRemoveFromEventList+0x6c>)

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 80036be:	4630      	mov	r0, r6
 80036c0:	f000 fe8c 	bl	80043dc <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80036c4:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 80036c8:	b9f3      	cbnz	r3, 8003708 <xTaskRemoveFromEventList+0x58>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 80036ca:	1d2e      	adds	r6, r5, #4
 80036cc:	4630      	mov	r0, r6
 80036ce:	f000 fe85 	bl	80043dc <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 80036d2:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 80036d4:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 80036d8:	2201      	movs	r2, #1
 80036da:	4082      	lsls	r2, r0
 80036dc:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80036e0:	4313      	orrs	r3, r2
 80036e2:	4631      	mov	r1, r6
 80036e4:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 80036e8:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
 80036ec:	f000 fe4c 	bl	8004388 <vListInsertEnd>
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 80036f0:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 80036f4:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 80036f6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80036f8:	4b08      	ldr	r3, [pc, #32]	; (800371c <xTaskRemoveFromEventList+0x6c>)
 80036fa:	4291      	cmp	r1, r2
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 80036fc:	bf86      	itte	hi
 80036fe:	2001      	movhi	r0, #1
 8003700:	f8c3 00fc 	strhi.w	r0, [r3, #252]	; 0xfc
	}
	else
	{
		xReturn = pdFALSE;
 8003704:	2000      	movls	r0, #0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
 8003706:	bd70      	pop	{r4, r5, r6, pc}
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8003708:	4631      	mov	r1, r6
 800370a:	f104 008c 	add.w	r0, r4, #140	; 0x8c
 800370e:	f000 fe3b 	bl	8004388 <vListInsertEnd>
 8003712:	e7ed      	b.n	80036f0 <xTaskRemoveFromEventList+0x40>
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
	configASSERT( pxUnblockedTCB );
 8003714:	f7fe faa0 	bl	8001c58 <ulPortSetInterruptMask>
 8003718:	e7fe      	b.n	8003718 <xTaskRemoveFromEventList+0x68>
 800371a:	bf00      	nop
 800371c:	20000040 	.word	0x20000040

08003720 <xTaskRemoveFromUnorderedEventList>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
 8003720:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TCB_t *pxUnblockedTCB;
BaseType_t xReturn;

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );
 8003722:	4d18      	ldr	r5, [pc, #96]	; (8003784 <xTaskRemoveFromUnorderedEventList+0x64>)
 8003724:	f8d5 30e8 	ldr.w	r3, [r5, #232]	; 0xe8
 8003728:	b32b      	cbz	r3, 8003776 <xTaskRemoveFromUnorderedEventList+0x56>
	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
 800372a:	68c6      	ldr	r6, [r0, #12]
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 800372c:	f041 4300 	orr.w	r3, r1, #2147483648	; 0x80000000
 8003730:	6003      	str	r3, [r0, #0]

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
	configASSERT( pxUnblockedTCB );
 8003732:	b31e      	cbz	r6, 800377c <xTaskRemoveFromUnorderedEventList+0x5c>
	( void ) uxListRemove( pxEventListItem );

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 8003734:	1d37      	adds	r7, r6, #4

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
 8003736:	f000 fe51 	bl	80043dc <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 800373a:	4638      	mov	r0, r7
 800373c:	f000 fe4e 	bl	80043dc <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
 8003740:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 8003742:	2401      	movs	r4, #1
 8003744:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
 8003748:	fa04 f200 	lsl.w	r2, r4, r0
 800374c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8003750:	eb05 0080 	add.w	r0, r5, r0, lsl #2
 8003754:	4313      	orrs	r3, r2
 8003756:	4639      	mov	r1, r7
 8003758:	f8c5 30e0 	str.w	r3, [r5, #224]	; 0xe0
 800375c:	f000 fe14 	bl	8004388 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8003760:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
 8003764:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 8003766:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003768:	429a      	cmp	r2, r3
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
 800376a:	bf86      	itte	hi
 800376c:	4620      	movhi	r0, r4

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 800376e:	f8c5 40fc 	strhi.w	r4, [r5, #252]	; 0xfc
	}
	else
	{
		xReturn = pdFALSE;
 8003772:	2000      	movls	r0, #0
	}

	return xReturn;
}
 8003774:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
TCB_t *pxUnblockedTCB;
BaseType_t xReturn;

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );
 8003776:	f7fe fa6f 	bl	8001c58 <ulPortSetInterruptMask>
 800377a:	e7fe      	b.n	800377a <xTaskRemoveFromUnorderedEventList+0x5a>
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
	configASSERT( pxUnblockedTCB );
 800377c:	f7fe fa6c 	bl	8001c58 <ulPortSetInterruptMask>
 8003780:	e7fe      	b.n	8003780 <xTaskRemoveFromUnorderedEventList+0x60>
 8003782:	bf00      	nop
 8003784:	20000040 	.word	0x20000040

08003788 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 8003788:	b508      	push	{r3, lr}
	configASSERT( pxTimeOut );
 800378a:	b138      	cbz	r0, 800379c <vTaskSetTimeOutState+0x14>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 800378c:	4b05      	ldr	r3, [pc, #20]	; (80037a4 <vTaskSetTimeOutState+0x1c>)
 800378e:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
	pxTimeOut->xTimeOnEntering = xTickCount;
 8003792:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003796:	e880 000c 	stmia.w	r0, {r2, r3}
 800379a:	bd08      	pop	{r3, pc}
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
 800379c:	f7fe fa5c 	bl	8001c58 <ulPortSetInterruptMask>
 80037a0:	e7fe      	b.n	80037a0 <vTaskSetTimeOutState+0x18>
 80037a2:	bf00      	nop
 80037a4:	20000040 	.word	0x20000040

080037a8 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
 80037a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
BaseType_t xReturn;

	configASSERT( pxTimeOut );
 80037aa:	4604      	mov	r4, r0
 80037ac:	b378      	cbz	r0, 800380e <xTaskCheckForTimeOut+0x66>
 80037ae:	460e      	mov	r6, r1
	configASSERT( pxTicksToWait );
 80037b0:	b351      	cbz	r1, 8003808 <xTaskCheckForTimeOut+0x60>

	taskENTER_CRITICAL();
 80037b2:	f7fe fa73 	bl	8001c9c <vPortEnterCritical>

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 80037b6:	6832      	ldr	r2, [r6, #0]
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 80037b8:	4816      	ldr	r0, [pc, #88]	; (8003814 <xTaskCheckForTimeOut+0x6c>)

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 80037ba:	1c53      	adds	r3, r2, #1
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 80037bc:	f8d0 50f0 	ldr.w	r5, [r0, #240]	; 0xf0

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 80037c0:	d01d      	beq.n	80037fe <xTaskCheckForTimeOut+0x56>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 80037c2:	f8d0 30f4 	ldr.w	r3, [r0, #244]	; 0xf4
 80037c6:	6821      	ldr	r1, [r4, #0]
 80037c8:	4299      	cmp	r1, r3
 80037ca:	6863      	ldr	r3, [r4, #4]
 80037cc:	d001      	beq.n	80037d2 <xTaskCheckForTimeOut+0x2a>
 80037ce:	429d      	cmp	r5, r3
 80037d0:	d210      	bcs.n	80037f4 <xTaskCheckForTimeOut+0x4c>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
 80037d2:	1ae9      	subs	r1, r5, r3
 80037d4:	428a      	cmp	r2, r1
 80037d6:	d90d      	bls.n	80037f4 <xTaskCheckForTimeOut+0x4c>
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 80037d8:	f8d0 70f4 	ldr.w	r7, [r0, #244]	; 0xf4
 80037dc:	1b52      	subs	r2, r2, r5
	pxTimeOut->xTimeOnEntering = xTickCount;
 80037de:	f8d0 10f0 	ldr.w	r1, [r0, #240]	; 0xf0
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
 80037e2:	4413      	add	r3, r2
 80037e4:	6033      	str	r3, [r6, #0]
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
 80037e6:	2500      	movs	r5, #0
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 80037e8:	6027      	str	r7, [r4, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 80037ea:	6061      	str	r1, [r4, #4]
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
 80037ec:	f7fe fa74 	bl	8001cd8 <vPortExitCritical>

	return xReturn;
}
 80037f0:	4628      	mov	r0, r5
 80037f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
 80037f4:	2501      	movs	r5, #1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
 80037f6:	f7fe fa6f 	bl	8001cd8 <vPortExitCritical>

	return xReturn;
}
 80037fa:	4628      	mov	r0, r5
 80037fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
 80037fe:	2500      	movs	r5, #0
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
 8003800:	f7fe fa6a 	bl	8001cd8 <vPortExitCritical>

	return xReturn;
}
 8003804:	4628      	mov	r0, r5
 8003806:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );
 8003808:	f7fe fa26 	bl	8001c58 <ulPortSetInterruptMask>
 800380c:	e7fe      	b.n	800380c <xTaskCheckForTimeOut+0x64>

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
BaseType_t xReturn;

	configASSERT( pxTimeOut );
 800380e:	f7fe fa23 	bl	8001c58 <ulPortSetInterruptMask>
 8003812:	e7fe      	b.n	8003812 <xTaskCheckForTimeOut+0x6a>
 8003814:	20000040 	.word	0x20000040

08003818 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
 8003818:	4b02      	ldr	r3, [pc, #8]	; (8003824 <vTaskMissedYield+0xc>)
 800381a:	2201      	movs	r2, #1
 800381c:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
 8003820:	4770      	bx	lr
 8003822:	bf00      	nop
 8003824:	20000040 	.word	0x20000040

08003828 <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 8003828:	4b01      	ldr	r3, [pc, #4]	; (8003830 <xTaskGetCurrentTaskHandle+0x8>)
 800382a:	f8d3 00d4 	ldr.w	r0, [r3, #212]	; 0xd4

		return xReturn;
	}
 800382e:	4770      	bx	lr
 8003830:	20000040 	.word	0x20000040

08003834 <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
 8003834:	4b06      	ldr	r3, [pc, #24]	; (8003850 <xTaskGetSchedulerState+0x1c>)
 8003836:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
 800383a:	b132      	cbz	r2, 800384a <xTaskGetSchedulerState+0x16>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800383c:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8003840:	2b00      	cmp	r3, #0
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
 8003842:	bf0c      	ite	eq
 8003844:	2002      	moveq	r0, #2
 8003846:	2000      	movne	r0, #0
 8003848:	4770      	bx	lr
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
 800384a:	2001      	movs	r0, #1
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
 800384c:	4770      	bx	lr
 800384e:	bf00      	nop
 8003850:	20000040 	.word	0x20000040

08003854 <vTaskPriorityInherit>:
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
 8003854:	2800      	cmp	r0, #0
 8003856:	d047      	beq.n	80038e8 <vTaskPriorityInherit+0x94>
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
 8003858:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		if( pxMutexHolder != NULL )
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 800385a:	4c24      	ldr	r4, [pc, #144]	; (80038ec <vTaskPriorityInherit+0x98>)
 800385c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800385e:	f8d4 20d4 	ldr.w	r2, [r4, #212]	; 0xd4
 8003862:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8003864:	4293      	cmp	r3, r2
 8003866:	d214      	bcs.n	8003892 <vTaskPriorityInherit+0x3e>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8003868:	6982      	ldr	r2, [r0, #24]
 800386a:	2a00      	cmp	r2, #0
 800386c:	db05      	blt.n	800387a <vTaskPriorityInherit+0x26>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800386e:	f8d4 20d4 	ldr.w	r2, [r4, #212]	; 0xd4
 8003872:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8003874:	f1c2 0205 	rsb	r2, r2, #5
 8003878:	6182      	str	r2, [r0, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 800387a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800387e:	6942      	ldr	r2, [r0, #20]
 8003880:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8003884:	429a      	cmp	r2, r3
 8003886:	4d19      	ldr	r5, [pc, #100]	; (80038ec <vTaskPriorityInherit+0x98>)
 8003888:	d004      	beq.n	8003894 <vTaskPriorityInherit+0x40>
					prvAddTaskToReadyList( pxTCB );
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 800388a:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
 800388e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003890:	62c3      	str	r3, [r0, #44]	; 0x2c
 8003892:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8003894:	1d07      	adds	r7, r0, #4
 8003896:	4606      	mov	r6, r0
 8003898:	4638      	mov	r0, r7
 800389a:	f000 fd9f 	bl	80043dc <uxListRemove>
 800389e:	b970      	cbnz	r0, 80038be <vTaskPriorityInherit+0x6a>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 80038a0:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 80038a2:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 80038a6:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
 80038aa:	b942      	cbnz	r2, 80038be <vTaskPriorityInherit+0x6a>
 80038ac:	f8d5 20e0 	ldr.w	r2, [r5, #224]	; 0xe0
 80038b0:	2101      	movs	r1, #1
 80038b2:	fa01 f303 	lsl.w	r3, r1, r3
 80038b6:	ea22 0303 	bic.w	r3, r2, r3
 80038ba:	f8c5 30e0 	str.w	r3, [r5, #224]	; 0xe0
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 80038be:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
					prvAddTaskToReadyList( pxTCB );
 80038c2:	2501      	movs	r5, #1
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 80038c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 80038c6:	f8d4 20e0 	ldr.w	r2, [r4, #224]	; 0xe0
 80038ca:	409d      	lsls	r5, r3
 80038cc:	eb03 0083 	add.w	r0, r3, r3, lsl #2
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 80038d0:	62f3      	str	r3, [r6, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 80038d2:	ea45 0302 	orr.w	r3, r5, r2
 80038d6:	4639      	mov	r1, r7
 80038d8:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 80038dc:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 80038e0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
					prvAddTaskToReadyList( pxTCB );
 80038e4:	f000 bd50 	b.w	8004388 <vListInsertEnd>
 80038e8:	4770      	bx	lr
 80038ea:	bf00      	nop
 80038ec:	20000040 	.word	0x20000040

080038f0 <xTaskPriorityDisinherit>:
	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
 80038f0:	b148      	cbz	r0, 8003906 <xTaskPriorityDisinherit+0x16>
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
 80038f2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		{
			/* A task can only have an inherited priority if it holds the mutex.
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
 80038f4:	4d21      	ldr	r5, [pc, #132]	; (800397c <xTaskPriorityDisinherit+0x8c>)
 80038f6:	4604      	mov	r4, r0
 80038f8:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
 80038fc:	4298      	cmp	r0, r3
 80038fe:	d004      	beq.n	800390a <xTaskPriorityDisinherit+0x1a>
 8003900:	f7fe f9aa 	bl	8001c58 <ulPortSetInterruptMask>
 8003904:	e7fe      	b.n	8003904 <xTaskPriorityDisinherit+0x14>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
 8003906:	2000      	movs	r0, #0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
 8003908:	4770      	bx	lr
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
 800390a:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800390c:	b143      	cbz	r3, 8003920 <xTaskPriorityDisinherit+0x30>
			( pxTCB->uxMutexesHeld )--;

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800390e:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8003910:	6c02      	ldr	r2, [r0, #64]	; 0x40
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
 8003912:	3b01      	subs	r3, #1

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8003914:	4291      	cmp	r1, r2
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
 8003916:	6443      	str	r3, [r0, #68]	; 0x44

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8003918:	d000      	beq.n	800391c <xTaskPriorityDisinherit+0x2c>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 800391a:	b123      	cbz	r3, 8003926 <xTaskPriorityDisinherit+0x36>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
 800391c:	2000      	movs	r0, #0
 800391e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
 8003920:	f7fe f99a 	bl	8001c58 <ulPortSetInterruptMask>
 8003924:	e7fe      	b.n	8003924 <xTaskPriorityDisinherit+0x34>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8003926:	1d07      	adds	r7, r0, #4
 8003928:	4638      	mov	r0, r7
 800392a:	f000 fd57 	bl	80043dc <uxListRemove>
 800392e:	b968      	cbnz	r0, 800394c <xTaskPriorityDisinherit+0x5c>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8003930:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8003932:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 8003936:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 800393a:	b93b      	cbnz	r3, 800394c <xTaskPriorityDisinherit+0x5c>
 800393c:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
 8003940:	2201      	movs	r2, #1
 8003942:	4082      	lsls	r2, r0
 8003944:	ea23 0302 	bic.w	r3, r3, r2
 8003948:	f8c5 30e0 	str.w	r3, [r5, #224]	; 0xe0
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 800394c:	6c23      	ldr	r3, [r4, #64]	; 0x40

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
					prvAddTaskToReadyList( pxTCB );
 800394e:	f8d5 20e0 	ldr.w	r2, [r5, #224]	; 0xe0
 8003952:	2601      	movs	r6, #1
					pxTCB->uxPriority = pxTCB->uxBasePriority;

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003954:	f1c3 0e05 	rsb	lr, r3, #5
					prvAddTaskToReadyList( pxTCB );
 8003958:	fa06 fc03 	lsl.w	ip, r6, r3
 800395c:	eb03 0083 	add.w	r0, r3, r3, lsl #2
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8003960:	62e3      	str	r3, [r4, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
					prvAddTaskToReadyList( pxTCB );
 8003962:	eb05 0080 	add.w	r0, r5, r0, lsl #2
 8003966:	ea4c 0302 	orr.w	r3, ip, r2
 800396a:	4639      	mov	r1, r7
					pxTCB->uxPriority = pxTCB->uxBasePriority;

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800396c:	f8c4 e018 	str.w	lr, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 8003970:	f8c5 30e0 	str.w	r3, [r5, #224]	; 0xe0
 8003974:	f000 fd08 	bl	8004388 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
 8003978:	4630      	mov	r0, r6
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
 800397a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800397c:	20000040 	.word	0x20000040

08003980 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 8003980:	4b06      	ldr	r3, [pc, #24]	; (800399c <uxTaskResetEventItemValue+0x1c>)
 8003982:	f8d3 10d4 	ldr.w	r1, [r3, #212]	; 0xd4

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003986:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
 800398a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 800398e:	6988      	ldr	r0, [r1, #24]

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003990:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003992:	f1c3 0305 	rsb	r3, r3, #5
 8003996:	6193      	str	r3, [r2, #24]

	return uxReturn;
}
 8003998:	4770      	bx	lr
 800399a:	bf00      	nop
 800399c:	20000040 	.word	0x20000040

080039a0 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
 80039a0:	4b05      	ldr	r3, [pc, #20]	; (80039b8 <pvTaskIncrementMutexHeldCount+0x18>)
 80039a2:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
 80039a6:	b122      	cbz	r2, 80039b2 <pvTaskIncrementMutexHeldCount+0x12>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
 80039a8:	f8d3 10d4 	ldr.w	r1, [r3, #212]	; 0xd4
 80039ac:	6c4a      	ldr	r2, [r1, #68]	; 0x44
 80039ae:	3201      	adds	r2, #1
 80039b0:	644a      	str	r2, [r1, #68]	; 0x44
		}

		return pxCurrentTCB;
 80039b2:	f8d3 00d4 	ldr.w	r0, [r3, #212]	; 0xd4
	}
 80039b6:	4770      	bx	lr
 80039b8:	20000040 	.word	0x20000040

080039bc <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
 80039bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t ulReturn;

		taskENTER_CRITICAL();
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 80039be:	4c34      	ldr	r4, [pc, #208]	; (8003a90 <ulTaskNotifyTake+0xd4>)
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
 80039c0:	4606      	mov	r6, r0
 80039c2:	460d      	mov	r5, r1
	TickType_t xTimeToWake;
	uint32_t ulReturn;

		taskENTER_CRITICAL();
 80039c4:	f7fe f96a 	bl	8001c9c <vPortEnterCritical>
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 80039c8:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 80039cc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80039ce:	b92b      	cbnz	r3, 80039dc <ulTaskNotifyTake+0x20>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
 80039d0:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 80039d4:	2701      	movs	r7, #1
 80039d6:	f883 704c 	strb.w	r7, [r3, #76]	; 0x4c

				if( xTicksToWait > ( TickType_t ) 0 )
 80039da:	b9e5      	cbnz	r5, 8003a16 <ulTaskNotifyTake+0x5a>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 80039dc:	f7fe f97c 	bl	8001cd8 <vPortExitCritical>

		taskENTER_CRITICAL();
 80039e0:	f7fe f95c 	bl	8001c9c <vPortEnterCritical>
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
 80039e4:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 80039e8:	4a29      	ldr	r2, [pc, #164]	; (8003a90 <ulTaskNotifyTake+0xd4>)
 80039ea:	6c9d      	ldr	r5, [r3, #72]	; 0x48

			if( ulReturn != 0UL )
 80039ec:	b12d      	cbz	r5, 80039fa <ulTaskNotifyTake+0x3e>
			{
				if( xClearCountOnExit != pdFALSE )
 80039ee:	b96e      	cbnz	r6, 8003a0c <ulTaskNotifyTake+0x50>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
				}
				else
				{
					( pxCurrentTCB->ulNotifiedValue )--;
 80039f0:	f8d2 20d4 	ldr.w	r2, [r2, #212]	; 0xd4
 80039f4:	6c93      	ldr	r3, [r2, #72]	; 0x48
 80039f6:	3b01      	subs	r3, #1
 80039f8:	6493      	str	r3, [r2, #72]	; 0x48
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
 80039fa:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 80039fe:	2200      	movs	r2, #0
 8003a00:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
		}
		taskEXIT_CRITICAL();
 8003a04:	f7fe f968 	bl	8001cd8 <vPortExitCritical>

		return ulReturn;
	}
 8003a08:	4628      	mov	r0, r5
 8003a0a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
 8003a0c:	f8d2 30d4 	ldr.w	r3, [r2, #212]	; 0xd4
 8003a10:	2200      	movs	r2, #0
 8003a12:	649a      	str	r2, [r3, #72]	; 0x48
 8003a14:	e7f1      	b.n	80039fa <ulTaskNotifyTake+0x3e>

				if( xTicksToWait > ( TickType_t ) 0 )
				{
					/* The task is going to block.  First it must be removed
					from the ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8003a16:	f8d4 00d4 	ldr.w	r0, [r4, #212]	; 0xd4
 8003a1a:	3004      	adds	r0, #4
 8003a1c:	f000 fcde 	bl	80043dc <uxListRemove>
 8003a20:	b948      	cbnz	r0, 8003a36 <ulTaskNotifyTake+0x7a>
					{
						/* The current task must be in a ready list, so there is
						no need to check, and the port reset macro can be called
						directly. */
						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 8003a22:	f8d4 20d4 	ldr.w	r2, [r4, #212]	; 0xd4
 8003a26:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 8003a2a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8003a2c:	4097      	lsls	r7, r2
 8003a2e:	ea23 0707 	bic.w	r7, r3, r7
 8003a32:	f8c4 70e0 	str.w	r7, [r4, #224]	; 0xe0
						mtCOVERAGE_TEST_MARKER();
					}

					#if ( INCLUDE_vTaskSuspend == 1 )
					{
						if( xTicksToWait == portMAX_DELAY )
 8003a36:	1c6b      	adds	r3, r5, #1
 8003a38:	d022      	beq.n	8003a80 <ulTaskNotifyTake+0xc4>
						{
							/* Calculate the time at which the task should be
							woken if no notification events occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
 8003a3a:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8003a3e:	f8d4 10d4 	ldr.w	r1, [r4, #212]	; 0xd4

	if( xTimeToWake < xTickCount )
 8003a42:	f8d4 20f0 	ldr.w	r2, [r4, #240]	; 0xf0
						{
							/* Calculate the time at which the task should be
							woken if no notification events occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
 8003a46:	441d      	add	r5, r3
static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
 8003a48:	4295      	cmp	r5, r2
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8003a4a:	604d      	str	r5, [r1, #4]
						{
							/* Calculate the time at which the task should be
							woken if no notification events occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
 8003a4c:	4f10      	ldr	r7, [pc, #64]	; (8003a90 <ulTaskNotifyTake+0xd4>)
static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
 8003a4e:	d30f      	bcc.n	8003a70 <ulTaskNotifyTake+0xb4>
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8003a50:	f8d7 00c8 	ldr.w	r0, [r7, #200]	; 0xc8
 8003a54:	f8d7 10d4 	ldr.w	r1, [r7, #212]	; 0xd4
 8003a58:	3104      	adds	r1, #4
 8003a5a:	f000 fca5 	bl	80043a8 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 8003a5e:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 8003a62:	429d      	cmp	r5, r3
		{
			xNextTaskUnblockTime = xTimeToWake;
 8003a64:	bf38      	it	cc
 8003a66:	f8c7 50ec 	strcc.w	r5, [r7, #236]	; 0xec

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
 8003a6a:	f7fe f8e9 	bl	8001c40 <vPortYield>
 8003a6e:	e7b5      	b.n	80039dc <ulTaskNotifyTake+0x20>
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8003a70:	f8d7 00cc 	ldr.w	r0, [r7, #204]	; 0xcc
 8003a74:	f8d7 10d4 	ldr.w	r1, [r7, #212]	; 0xd4
 8003a78:	3104      	adds	r1, #4
 8003a7a:	f000 fc95 	bl	80043a8 <vListInsert>
 8003a7e:	e7f4      	b.n	8003a6a <ulTaskNotifyTake+0xae>
						{
							/* Add the task to the suspended task list instead
							of a delayed task list to ensure the task is not
							woken by a timing event.  It will block
							indefinitely. */
							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8003a80:	f8d4 10d4 	ldr.w	r1, [r4, #212]	; 0xd4
 8003a84:	4803      	ldr	r0, [pc, #12]	; (8003a94 <ulTaskNotifyTake+0xd8>)
 8003a86:	3104      	adds	r1, #4
 8003a88:	f000 fc7e 	bl	8004388 <vListInsertEnd>
 8003a8c:	e7ed      	b.n	8003a6a <ulTaskNotifyTake+0xae>
 8003a8e:	bf00      	nop
 8003a90:	20000040 	.word	0x20000040
 8003a94:	200000f4 	.word	0x200000f4

08003a98 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
 8003a98:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	BaseType_t xReturn;

		taskENTER_CRITICAL();
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->eNotifyState != eNotified )
 8003a9c:	4c3d      	ldr	r4, [pc, #244]	; (8003b94 <xTaskNotifyWait+0xfc>)
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
 8003a9e:	461f      	mov	r7, r3
 8003aa0:	4680      	mov	r8, r0
 8003aa2:	460e      	mov	r6, r1
 8003aa4:	4615      	mov	r5, r2
	TickType_t xTimeToWake;
	BaseType_t xReturn;

		taskENTER_CRITICAL();
 8003aa6:	f7fe f8f9 	bl	8001c9c <vPortEnterCritical>
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->eNotifyState != eNotified )
 8003aaa:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 8003aae:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 8003ab2:	2b02      	cmp	r3, #2
 8003ab4:	d00c      	beq.n	8003ad0 <xTaskNotifyWait+0x38>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 8003ab6:	f8d4 10d4 	ldr.w	r1, [r4, #212]	; 0xd4

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
 8003aba:	f04f 0901 	mov.w	r9, #1
			if( pxCurrentTCB->eNotifyState != eNotified )
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 8003abe:	6c8a      	ldr	r2, [r1, #72]	; 0x48
 8003ac0:	ea22 0008 	bic.w	r0, r2, r8
 8003ac4:	6488      	str	r0, [r1, #72]	; 0x48

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
 8003ac6:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 8003aca:	f883 904c 	strb.w	r9, [r3, #76]	; 0x4c

				if( xTicksToWait > ( TickType_t ) 0 )
 8003ace:	bb07      	cbnz	r7, 8003b12 <xTaskNotifyWait+0x7a>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 8003ad0:	f7fe f902 	bl	8001cd8 <vPortExitCritical>

		taskENTER_CRITICAL();
 8003ad4:	f7fe f8e2 	bl	8001c9c <vPortEnterCritical>
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
 8003ad8:	b11d      	cbz	r5, 8003ae2 <xTaskNotifyWait+0x4a>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
 8003ada:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 8003ade:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8003ae0:	602b      	str	r3, [r5, #0]

			/* If eNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
 8003ae2:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 8003ae6:	4a2b      	ldr	r2, [pc, #172]	; (8003b94 <xTaskNotifyWait+0xfc>)
 8003ae8:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 8003aec:	2b01      	cmp	r3, #1
 8003aee:	d046      	beq.n	8003b7e <xTaskNotifyWait+0xe6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 8003af0:	f8d2 30d4 	ldr.w	r3, [r2, #212]	; 0xd4
				xReturn = pdTRUE;
 8003af4:	2501      	movs	r5, #1
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 8003af6:	6c99      	ldr	r1, [r3, #72]	; 0x48
 8003af8:	ea21 0106 	bic.w	r1, r1, r6
 8003afc:	6499      	str	r1, [r3, #72]	; 0x48
				xReturn = pdTRUE;
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
 8003afe:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 8003b02:	2200      	movs	r2, #0
 8003b04:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
		}
		taskEXIT_CRITICAL();
 8003b08:	f7fe f8e6 	bl	8001cd8 <vPortExitCritical>

		return xReturn;
	}
 8003b0c:	4628      	mov	r0, r5
 8003b0e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

				if( xTicksToWait > ( TickType_t ) 0 )
				{
					/* The task is going to block.  First it must be removed
					from the	ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8003b12:	f8d4 00d4 	ldr.w	r0, [r4, #212]	; 0xd4
 8003b16:	3004      	adds	r0, #4
 8003b18:	f000 fc60 	bl	80043dc <uxListRemove>
 8003b1c:	b950      	cbnz	r0, 8003b34 <xTaskNotifyWait+0x9c>
					{
						/* The current task must be in a ready list, so there is
						no need to check, and the port reset macro can be called
						directly. */
						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 8003b1e:	f8d4 20d4 	ldr.w	r2, [r4, #212]	; 0xd4
 8003b22:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 8003b26:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8003b28:	fa09 f902 	lsl.w	r9, r9, r2
 8003b2c:	ea23 0309 	bic.w	r3, r3, r9
 8003b30:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
						mtCOVERAGE_TEST_MARKER();
					}

					#if ( INCLUDE_vTaskSuspend == 1 )
					{
						if( xTicksToWait == portMAX_DELAY )
 8003b34:	1c7b      	adds	r3, r7, #1
 8003b36:	d01b      	beq.n	8003b70 <xTaskNotifyWait+0xd8>
						{
							/* Calculate the time at which the task should be
							woken if no notification events occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
 8003b38:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8003b3c:	f8d4 10d4 	ldr.w	r1, [r4, #212]	; 0xd4

	if( xTimeToWake < xTickCount )
 8003b40:	f8d4 20f0 	ldr.w	r2, [r4, #240]	; 0xf0
						{
							/* Calculate the time at which the task should be
							woken if no notification events occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
 8003b44:	441f      	add	r7, r3
static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
 8003b46:	4297      	cmp	r7, r2
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8003b48:	604f      	str	r7, [r1, #4]
						{
							/* Calculate the time at which the task should be
							woken if no notification events occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
 8003b4a:	f8df 8048 	ldr.w	r8, [pc, #72]	; 8003b94 <xTaskNotifyWait+0xfc>
static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
 8003b4e:	d318      	bcc.n	8003b82 <xTaskNotifyWait+0xea>
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8003b50:	f8d8 00c8 	ldr.w	r0, [r8, #200]	; 0xc8
 8003b54:	f8d8 10d4 	ldr.w	r1, [r8, #212]	; 0xd4
 8003b58:	3104      	adds	r1, #4
 8003b5a:	f000 fc25 	bl	80043a8 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 8003b5e:	f8d8 30ec 	ldr.w	r3, [r8, #236]	; 0xec
 8003b62:	429f      	cmp	r7, r3
		{
			xNextTaskUnblockTime = xTimeToWake;
 8003b64:	bf38      	it	cc
 8003b66:	f8c8 70ec 	strcc.w	r7, [r8, #236]	; 0xec

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
 8003b6a:	f7fe f869 	bl	8001c40 <vPortYield>
 8003b6e:	e7af      	b.n	8003ad0 <xTaskNotifyWait+0x38>
						{
							/* Add the task to the suspended task list instead
							of a delayed task list to ensure the task is not
							woken by a timing event.  It will block
							indefinitely. */
							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8003b70:	f8d4 10d4 	ldr.w	r1, [r4, #212]	; 0xd4
 8003b74:	4808      	ldr	r0, [pc, #32]	; (8003b98 <xTaskNotifyWait+0x100>)
 8003b76:	3104      	adds	r1, #4
 8003b78:	f000 fc06 	bl	8004388 <vListInsertEnd>
 8003b7c:	e7f5      	b.n	8003b6a <xTaskNotifyWait+0xd2>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
 8003b7e:	2500      	movs	r5, #0
 8003b80:	e7bd      	b.n	8003afe <xTaskNotifyWait+0x66>
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8003b82:	f8d8 00cc 	ldr.w	r0, [r8, #204]	; 0xcc
 8003b86:	f8d8 10d4 	ldr.w	r1, [r8, #212]	; 0xd4
 8003b8a:	3104      	adds	r1, #4
 8003b8c:	f000 fc0c 	bl	80043a8 <vListInsert>
 8003b90:	e7eb      	b.n	8003b6a <xTaskNotifyWait+0xd2>
 8003b92:	bf00      	nop
 8003b94:	20000040 	.word	0x20000040
 8003b98:	200000f4 	.word	0x200000f4

08003b9c <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
 8003b9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	BaseType_t xReturn = pdPASS;

		configASSERT( xTaskToNotify );
 8003b9e:	4604      	mov	r4, r0
 8003ba0:	2800      	cmp	r0, #0
 8003ba2:	d046      	beq.n	8003c32 <xTaskGenericNotify+0x96>
 8003ba4:	461d      	mov	r5, r3
 8003ba6:	460f      	mov	r7, r1
 8003ba8:	4616      	mov	r6, r2
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
 8003baa:	f7fe f877 	bl	8001c9c <vPortEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
 8003bae:	b10d      	cbz	r5, 8003bb4 <xTaskGenericNotify+0x18>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 8003bb0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8003bb2:	602b      	str	r3, [r5, #0]
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
 8003bb4:	f894 504c 	ldrb.w	r5, [r4, #76]	; 0x4c

			pxTCB->eNotifyState = eNotified;
 8003bb8:	2202      	movs	r2, #2

			switch( eAction )
 8003bba:	1e73      	subs	r3, r6, #1
			if( pulPreviousNotificationValue != NULL )
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
 8003bbc:	b2ed      	uxtb	r5, r5

			pxTCB->eNotifyState = eNotified;
 8003bbe:	f884 204c 	strb.w	r2, [r4, #76]	; 0x4c

			switch( eAction )
 8003bc2:	2b03      	cmp	r3, #3
 8003bc4:	d804      	bhi.n	8003bd0 <xTaskGenericNotify+0x34>
 8003bc6:	e8df f003 	tbb	[pc, r3]
 8003bca:	0a29      	.short	0x0a29
 8003bcc:	2d02      	.short	0x2d02
					break;

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
					{
						pxTCB->ulNotifiedValue = ulValue;
 8003bce:	64a7      	str	r7, [r4, #72]	; 0x48

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
 8003bd0:	2d01      	cmp	r5, #1
 8003bd2:	d00a      	beq.n	8003bea <xTaskGenericNotify+0x4e>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
 8003bd4:	2501      	movs	r5, #1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 8003bd6:	f7fe f87f 	bl	8001cd8 <vPortExitCritical>

		return xReturn;
	}
 8003bda:	4628      	mov	r0, r5
 8003bdc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
 8003bde:	6ca3      	ldr	r3, [r4, #72]	; 0x48

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
 8003be0:	2d01      	cmp	r5, #1
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
 8003be2:	f103 0301 	add.w	r3, r3, #1
 8003be6:	64a3      	str	r3, [r4, #72]	; 0x48

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
 8003be8:	d1f4      	bne.n	8003bd4 <xTaskGenericNotify+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8003bea:	1d27      	adds	r7, r4, #4
				prvAddTaskToReadyList( pxTCB );
 8003bec:	4e18      	ldr	r6, [pc, #96]	; (8003c50 <xTaskGenericNotify+0xb4>)

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
			{
				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8003bee:	4638      	mov	r0, r7
 8003bf0:	f000 fbf4 	bl	80043dc <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
 8003bf4:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8003bf6:	f8d6 30e0 	ldr.w	r3, [r6, #224]	; 0xe0
 8003bfa:	fa05 f200 	lsl.w	r2, r5, r0
 8003bfe:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8003c02:	4313      	orrs	r3, r2
 8003c04:	4639      	mov	r1, r7
 8003c06:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 8003c0a:	f8c6 30e0 	str.w	r3, [r6, #224]	; 0xe0
 8003c0e:	f000 fbbb 	bl	8004388 <vListInsertEnd>

				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 8003c12:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003c14:	b183      	cbz	r3, 8003c38 <xTaskGenericNotify+0x9c>
 8003c16:	f7fe f81f 	bl	8001c58 <ulPortSetInterruptMask>
 8003c1a:	e7fe      	b.n	8003c1a <xTaskGenericNotify+0x7e>
			pxTCB->eNotifyState = eNotified;

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
 8003c1c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8003c1e:	431f      	orrs	r7, r3
 8003c20:	64a7      	str	r7, [r4, #72]	; 0x48
					break;
 8003c22:	e7d5      	b.n	8003bd0 <xTaskGenericNotify+0x34>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
 8003c24:	2d02      	cmp	r5, #2
 8003c26:	d1d2      	bne.n	8003bce <xTaskGenericNotify+0x32>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
 8003c28:	2500      	movs	r5, #0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 8003c2a:	f7fe f855 	bl	8001cd8 <vPortExitCritical>

		return xReturn;
	}
 8003c2e:	4628      	mov	r0, r5
 8003c30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	{
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	BaseType_t xReturn = pdPASS;

		configASSERT( xTaskToNotify );
 8003c32:	f7fe f811 	bl	8001c58 <ulPortSetInterruptMask>
 8003c36:	e7fe      	b.n	8003c36 <xTaskGenericNotify+0x9a>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8003c38:	f8d6 30d4 	ldr.w	r3, [r6, #212]	; 0xd4
 8003c3c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8003c3e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003c40:	429a      	cmp	r2, r3
 8003c42:	d9c7      	bls.n	8003bd4 <xTaskGenericNotify+0x38>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
 8003c44:	f7fd fffc 	bl	8001c40 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 8003c48:	f7fe f846 	bl	8001cd8 <vPortExitCritical>

		return xReturn;
	}
 8003c4c:	4628      	mov	r0, r5
 8003c4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003c50:	20000040 	.word	0x20000040

08003c54 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
 8003c54:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003c58:	f8dd 8020 	ldr.w	r8, [sp, #32]
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
 8003c5c:	4604      	mov	r4, r0
 8003c5e:	2800      	cmp	r0, #0
 8003c60:	d039      	beq.n	8003cd6 <xTaskGenericNotifyFromISR+0x82>
 8003c62:	4689      	mov	r9, r1
 8003c64:	4616      	mov	r6, r2
 8003c66:	461d      	mov	r5, r3
		below the maximum system call interrupt priority.  FreeRTOS maintains a
		separate interrupt safe API to ensure interrupt entry is as fast and as
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8003c68:	f7fe f8d0 	bl	8001e0c <vPortValidateInterruptPriority>

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8003c6c:	f7fd fff4 	bl	8001c58 <ulPortSetInterruptMask>
 8003c70:	4607      	mov	r7, r0
		{
			if( pulPreviousNotificationValue != NULL )
 8003c72:	b10d      	cbz	r5, 8003c78 <xTaskGenericNotifyFromISR+0x24>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 8003c74:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8003c76:	602b      	str	r3, [r5, #0]
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
 8003c78:	f894 504c 	ldrb.w	r5, [r4, #76]	; 0x4c
			pxTCB->eNotifyState = eNotified;
 8003c7c:	2202      	movs	r2, #2

			switch( eAction )
 8003c7e:	1e73      	subs	r3, r6, #1
			if( pulPreviousNotificationValue != NULL )
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
 8003c80:	b2ed      	uxtb	r5, r5
			pxTCB->eNotifyState = eNotified;
 8003c82:	f884 204c 	strb.w	r2, [r4, #76]	; 0x4c

			switch( eAction )
 8003c86:	2b03      	cmp	r3, #3
 8003c88:	d805      	bhi.n	8003c96 <xTaskGenericNotifyFromISR+0x42>
 8003c8a:	e8df f003 	tbb	[pc, r3]
 8003c8e:	1216      	.short	0x1216
 8003c90:	1b02      	.short	0x1b02
					break;

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
					{
						pxTCB->ulNotifiedValue = ulValue;
 8003c92:	f8c4 9048 	str.w	r9, [r4, #72]	; 0x48

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
 8003c96:	2d01      	cmp	r5, #1
 8003c98:	d104      	bne.n	8003ca4 <xTaskGenericNotifyFromISR+0x50>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 8003c9a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003c9c:	b1f3      	cbz	r3, 8003cdc <xTaskGenericNotifyFromISR+0x88>
 8003c9e:	f7fd ffdb 	bl	8001c58 <ulPortSetInterruptMask>
 8003ca2:	e7fe      	b.n	8003ca2 <xTaskGenericNotifyFromISR+0x4e>
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8003ca4:	4638      	mov	r0, r7
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
 8003ca6:	2401      	movs	r4, #1
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8003ca8:	f7fe f812 	bl	8001cd0 <vPortClearInterruptMask>

		return xReturn;
	}
 8003cac:	4620      	mov	r0, r4
 8003cae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
 8003cb2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8003cb4:	3301      	adds	r3, #1
 8003cb6:	64a3      	str	r3, [r4, #72]	; 0x48
					break;
 8003cb8:	e7ed      	b.n	8003c96 <xTaskGenericNotifyFromISR+0x42>
			pxTCB->eNotifyState = eNotified;

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
 8003cba:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8003cbc:	ea49 0303 	orr.w	r3, r9, r3
 8003cc0:	64a3      	str	r3, [r4, #72]	; 0x48
					break;
 8003cc2:	e7e8      	b.n	8003c96 <xTaskGenericNotifyFromISR+0x42>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
 8003cc4:	2d02      	cmp	r5, #2
 8003cc6:	d1e4      	bne.n	8003c92 <xTaskGenericNotifyFromISR+0x3e>
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8003cc8:	4638      	mov	r0, r7
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
 8003cca:	2400      	movs	r4, #0
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8003ccc:	f7fe f800 	bl	8001cd0 <vPortClearInterruptMask>

		return xReturn;
	}
 8003cd0:	4620      	mov	r0, r4
 8003cd2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
 8003cd6:	f7fd ffbf 	bl	8001c58 <ulPortSetInterruptMask>
 8003cda:	e7fe      	b.n	8003cda <xTaskGenericNotifyFromISR+0x86>
			if( eOriginalNotifyState == eWaitingNotification )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8003cdc:	4e17      	ldr	r6, [pc, #92]	; (8003d3c <xTaskGenericNotifyFromISR+0xe8>)
 8003cde:	f8d6 30e8 	ldr.w	r3, [r6, #232]	; 0xe8
 8003ce2:	bb23      	cbnz	r3, 8003d2e <xTaskGenericNotifyFromISR+0xda>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8003ce4:	f104 0904 	add.w	r9, r4, #4
 8003ce8:	4648      	mov	r0, r9
 8003cea:	f000 fb77 	bl	80043dc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8003cee:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8003cf0:	f8d6 30e0 	ldr.w	r3, [r6, #224]	; 0xe0
 8003cf4:	4085      	lsls	r5, r0
 8003cf6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8003cfa:	431d      	orrs	r5, r3
 8003cfc:	4649      	mov	r1, r9
 8003cfe:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 8003d02:	f8c6 50e0 	str.w	r5, [r6, #224]	; 0xe0
 8003d06:	f000 fb3f 	bl	8004388 <vListInsertEnd>
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8003d0a:	f8d6 30d4 	ldr.w	r3, [r6, #212]	; 0xd4
 8003d0e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8003d10:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003d12:	429a      	cmp	r2, r3
 8003d14:	d9c6      	bls.n	8003ca4 <xTaskGenericNotifyFromISR+0x50>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
 8003d16:	f1b8 0f00 	cmp.w	r8, #0
 8003d1a:	d0c3      	beq.n	8003ca4 <xTaskGenericNotifyFromISR+0x50>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
 8003d1c:	2401      	movs	r4, #1
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8003d1e:	4638      	mov	r0, r7
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
 8003d20:	f8c8 4000 	str.w	r4, [r8]
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8003d24:	f7fd ffd4 	bl	8001cd0 <vPortClearInterruptMask>

		return xReturn;
	}
 8003d28:	4620      	mov	r0, r4
 8003d2a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 8003d2e:	f106 008c 	add.w	r0, r6, #140	; 0x8c
 8003d32:	f104 0118 	add.w	r1, r4, #24
 8003d36:	f000 fb27 	bl	8004388 <vListInsertEnd>
 8003d3a:	e7e6      	b.n	8003d0a <xTaskGenericNotifyFromISR+0xb6>
 8003d3c:	20000040 	.word	0x20000040

08003d40 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
 8003d40:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
 8003d44:	4604      	mov	r4, r0
 8003d46:	2800      	cmp	r0, #0
 8003d48:	d03a      	beq.n	8003dc0 <vTaskNotifyGiveFromISR+0x80>
 8003d4a:	460f      	mov	r7, r1
		below the maximum system call interrupt priority.  FreeRTOS maintains a
		separate interrupt safe API to ensure interrupt entry is as fast and as
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8003d4c:	f7fe f85e 	bl	8001e0c <vPortValidateInterruptPriority>

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8003d50:	f7fd ff82 	bl	8001c58 <ulPortSetInterruptMask>
		{
			eOriginalNotifyState = pxTCB->eNotifyState;
			pxTCB->eNotifyState = eNotified;
 8003d54:	2302      	movs	r3, #2

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			eOriginalNotifyState = pxTCB->eNotifyState;
 8003d56:	f894 604c 	ldrb.w	r6, [r4, #76]	; 0x4c
			pxTCB->eNotifyState = eNotified;
 8003d5a:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
 8003d5e:	6ca3      	ldr	r3, [r4, #72]	; 0x48

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			eOriginalNotifyState = pxTCB->eNotifyState;
 8003d60:	b2f6      	uxtb	r6, r6
			pxTCB->eNotifyState = eNotified;

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
 8003d62:	3301      	adds	r3, #1

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
 8003d64:	2e01      	cmp	r6, #1
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8003d66:	4680      	mov	r8, r0
			eOriginalNotifyState = pxTCB->eNotifyState;
			pxTCB->eNotifyState = eNotified;

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
 8003d68:	64a3      	str	r3, [r4, #72]	; 0x48

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
 8003d6a:	d124      	bne.n	8003db6 <vTaskNotifyGiveFromISR+0x76>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 8003d6c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003d6e:	b113      	cbz	r3, 8003d76 <vTaskNotifyGiveFromISR+0x36>
 8003d70:	f7fd ff72 	bl	8001c58 <ulPortSetInterruptMask>
 8003d74:	e7fe      	b.n	8003d74 <vTaskNotifyGiveFromISR+0x34>

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8003d76:	4d17      	ldr	r5, [pc, #92]	; (8003dd4 <vTaskNotifyGiveFromISR+0x94>)
 8003d78:	f8d5 30e8 	ldr.w	r3, [r5, #232]	; 0xe8
 8003d7c:	bb1b      	cbnz	r3, 8003dc6 <vTaskNotifyGiveFromISR+0x86>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8003d7e:	f104 0904 	add.w	r9, r4, #4
 8003d82:	4648      	mov	r0, r9
 8003d84:	f000 fb2a 	bl	80043dc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8003d88:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8003d8a:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
 8003d8e:	4086      	lsls	r6, r0
 8003d90:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8003d94:	431e      	orrs	r6, r3
 8003d96:	4649      	mov	r1, r9
 8003d98:	eb05 0080 	add.w	r0, r5, r0, lsl #2
 8003d9c:	f8c5 60e0 	str.w	r6, [r5, #224]	; 0xe0
 8003da0:	f000 faf2 	bl	8004388 <vListInsertEnd>
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8003da4:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
 8003da8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8003daa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003dac:	429a      	cmp	r2, r3
 8003dae:	d902      	bls.n	8003db6 <vTaskNotifyGiveFromISR+0x76>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
 8003db0:	b10f      	cbz	r7, 8003db6 <vTaskNotifyGiveFromISR+0x76>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
 8003db2:	2301      	movs	r3, #1
 8003db4:	603b      	str	r3, [r7, #0]
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8003db6:	4640      	mov	r0, r8
	}
 8003db8:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8003dbc:	f7fd bf88 	b.w	8001cd0 <vPortClearInterruptMask>
	{
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
 8003dc0:	f7fd ff4a 	bl	8001c58 <ulPortSetInterruptMask>
 8003dc4:	e7fe      	b.n	8003dc4 <vTaskNotifyGiveFromISR+0x84>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 8003dc6:	f105 008c 	add.w	r0, r5, #140	; 0x8c
 8003dca:	f104 0118 	add.w	r1, r4, #24
 8003dce:	f000 fadb 	bl	8004388 <vListInsertEnd>
 8003dd2:	e7e7      	b.n	8003da4 <vTaskNotifyGiveFromISR+0x64>
 8003dd4:	20000040 	.word	0x20000040

08003dd8 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
 8003dd8:	b510      	push	{r4, lr}

		pxTCB = ( TCB_t * ) xTask;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( pxTCB );
 8003dda:	4604      	mov	r4, r0
 8003ddc:	b170      	cbz	r0, 8003dfc <xTaskNotifyStateClear+0x24>

		taskENTER_CRITICAL();
 8003dde:	f7fd ff5d 	bl	8001c9c <vPortEnterCritical>
		{
			if( pxTCB->eNotifyState == eNotified )
 8003de2:	f894 304c 	ldrb.w	r3, [r4, #76]	; 0x4c
 8003de6:	2b02      	cmp	r3, #2
			{
				pxTCB->eNotifyState = eNotWaitingNotification;
 8003de8:	bf05      	ittet	eq
 8003dea:	2300      	moveq	r3, #0
 8003dec:	f884 304c 	strbeq.w	r3, [r4, #76]	; 0x4c
				xReturn = pdPASS;
			}
			else
			{
				xReturn = pdFAIL;
 8003df0:	2400      	movne	r4, #0
		taskENTER_CRITICAL();
		{
			if( pxTCB->eNotifyState == eNotified )
			{
				pxTCB->eNotifyState = eNotWaitingNotification;
				xReturn = pdPASS;
 8003df2:	2401      	moveq	r4, #1
			else
			{
				xReturn = pdFAIL;
			}
		}
		taskEXIT_CRITICAL();
 8003df4:	f7fd ff70 	bl	8001cd8 <vPortExitCritical>

		return xReturn;
	}
 8003df8:	4620      	mov	r0, r4
 8003dfa:	bd10      	pop	{r4, pc}

		pxTCB = ( TCB_t * ) xTask;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( pxTCB );
 8003dfc:	4b01      	ldr	r3, [pc, #4]	; (8003e04 <xTaskNotifyStateClear+0x2c>)
 8003dfe:	f8d3 40d4 	ldr.w	r4, [r3, #212]	; 0xd4
 8003e02:	e7ec      	b.n	8003dde <xTaskNotifyStateClear+0x6>
 8003e04:	20000040 	.word	0x20000040

08003e08 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 8003e08:	b570      	push	{r4, r5, r6, lr}
 8003e0a:	4e12      	ldr	r6, [pc, #72]	; (8003e54 <prvInitialiseTaskLists+0x4c>)
 8003e0c:	2400      	movs	r4, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8003e0e:	1930      	adds	r0, r6, r4
 8003e10:	3414      	adds	r4, #20
 8003e12:	f000 faa9 	bl	8004368 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8003e16:	2c64      	cmp	r4, #100	; 0x64
 8003e18:	4d0e      	ldr	r5, [pc, #56]	; (8003e54 <prvInitialiseTaskLists+0x4c>)
 8003e1a:	d1f8      	bne.n	8003e0e <prvInitialiseTaskLists+0x6>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 8003e1c:	f105 0664 	add.w	r6, r5, #100	; 0x64
 8003e20:	4630      	mov	r0, r6
	vListInitialise( &xDelayedTaskList2 );
 8003e22:	f105 0478 	add.w	r4, r5, #120	; 0x78
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 8003e26:	f000 fa9f 	bl	8004368 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8003e2a:	4620      	mov	r0, r4
 8003e2c:	f000 fa9c 	bl	8004368 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8003e30:	f105 008c 	add.w	r0, r5, #140	; 0x8c
 8003e34:	f000 fa98 	bl	8004368 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 8003e38:	f105 00a0 	add.w	r0, r5, #160	; 0xa0
 8003e3c:	f000 fa94 	bl	8004368 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 8003e40:	f105 00b4 	add.w	r0, r5, #180	; 0xb4
 8003e44:	f000 fa90 	bl	8004368 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 8003e48:	f8c5 60c8 	str.w	r6, [r5, #200]	; 0xc8
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8003e4c:	f8c5 40cc 	str.w	r4, [r5, #204]	; 0xcc
 8003e50:	bd70      	pop	{r4, r5, r6, pc}
 8003e52:	bf00      	nop
 8003e54:	20000040 	.word	0x20000040

08003e58 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
 8003e58:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
 8003e5a:	4c18      	ldr	r4, [pc, #96]	; (8003ebc <xTimerCreateTimerTask+0x64>)
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
 8003e5c:	b085      	sub	sp, #20
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 8003e5e:	f7fd ff1d 	bl	8001c9c <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
 8003e62:	6827      	ldr	r7, [r4, #0]
 8003e64:	b18f      	cbz	r7, 8003e8a <xTimerCreateTimerTask+0x32>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 8003e66:	f7fd ff37 	bl	8001cd8 <vPortExitCritical>
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();

	if( xTimerQueue != NULL )
 8003e6a:	6823      	ldr	r3, [r4, #0]
 8003e6c:	b31b      	cbz	r3, 8003eb6 <xTimerCreateTimerTask+0x5e>
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
 8003e6e:	2300      	movs	r3, #0
 8003e70:	2203      	movs	r2, #3
 8003e72:	e88d 000c 	stmia.w	sp, {r2, r3}
 8003e76:	9302      	str	r3, [sp, #8]
 8003e78:	9303      	str	r3, [sp, #12]
 8003e7a:	4811      	ldr	r0, [pc, #68]	; (8003ec0 <xTimerCreateTimerTask+0x68>)
 8003e7c:	4911      	ldr	r1, [pc, #68]	; (8003ec4 <xTimerCreateTimerTask+0x6c>)
 8003e7e:	2246      	movs	r2, #70	; 0x46
 8003e80:	f7fe fd60 	bl	8002944 <xTaskGenericCreate>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
 8003e84:	b1b8      	cbz	r0, 8003eb6 <xTimerCreateTimerTask+0x5e>
	return xReturn;
}
 8003e86:	b005      	add	sp, #20
 8003e88:	bdf0      	pop	{r4, r5, r6, r7, pc}
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
 8003e8a:	1d26      	adds	r6, r4, #4
 8003e8c:	4630      	mov	r0, r6
			vListInitialise( &xActiveTimerList2 );
 8003e8e:	f104 0518 	add.w	r5, r4, #24
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
 8003e92:	f000 fa69 	bl	8004368 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 8003e96:	4628      	mov	r0, r5
 8003e98:	f000 fa66 	bl	8004368 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8003e9c:	463a      	mov	r2, r7
 8003e9e:	2005      	movs	r0, #5
 8003ea0:	210c      	movs	r1, #12
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
			vListInitialise( &xActiveTimerList2 );
			pxCurrentTimerList = &xActiveTimerList1;
 8003ea2:	62e6      	str	r6, [r4, #44]	; 0x2c
			pxOverflowTimerList = &xActiveTimerList2;
 8003ea4:	6325      	str	r5, [r4, #48]	; 0x30
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8003ea6:	f7fe f84f 	bl	8001f48 <xQueueGenericCreate>
 8003eaa:	6020      	str	r0, [r4, #0]
			configASSERT( xTimerQueue );
 8003eac:	2800      	cmp	r0, #0
 8003eae:	d1da      	bne.n	8003e66 <xTimerCreateTimerTask+0xe>
 8003eb0:	f7fd fed2 	bl	8001c58 <ulPortSetInterruptMask>
 8003eb4:	e7fe      	b.n	8003eb4 <xTimerCreateTimerTask+0x5c>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
 8003eb6:	f7fd fecf 	bl	8001c58 <ulPortSetInterruptMask>
 8003eba:	e7fe      	b.n	8003eba <xTimerCreateTimerTask+0x62>
 8003ebc:	20000140 	.word	0x20000140
 8003ec0:	08003fa5 	.word	0x08003fa5
 8003ec4:	08004920 	.word	0x08004920

08003ec8 <xTimerCreate>:
	return xReturn;
}
/*-----------------------------------------------------------*/

TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 8003ec8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
Timer_t *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
 8003ecc:	460e      	mov	r6, r1
	return xReturn;
}
/*-----------------------------------------------------------*/

TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 8003ece:	b083      	sub	sp, #12
Timer_t *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
 8003ed0:	b1e9      	cbz	r1, 8003f0e <xTimerCreate+0x46>
 8003ed2:	4682      	mov	sl, r0
	{
		pxNewTimer = NULL;
	}
	else
	{
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
 8003ed4:	2028      	movs	r0, #40	; 0x28
 8003ed6:	4691      	mov	r9, r2
 8003ed8:	461f      	mov	r7, r3
 8003eda:	f000 f9fd 	bl	80042d8 <pvPortMalloc>
		if( pxNewTimer != NULL )
 8003ede:	4604      	mov	r4, r0
 8003ee0:	b188      	cbz	r0, 8003f06 <xTimerCreate+0x3e>
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
 8003ee2:	4d19      	ldr	r5, [pc, #100]	; (8003f48 <xTimerCreate+0x80>)
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 8003ee4:	f7fd feda 	bl	8001c9c <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
 8003ee8:	682a      	ldr	r2, [r5, #0]
 8003eea:	b19a      	cbz	r2, 8003f14 <xTimerCreate+0x4c>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 8003eec:	f7fd fef4 	bl	8001cd8 <vPortExitCritical>
			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
			pxNewTimer->uxAutoReload = uxAutoReload;
			pxNewTimer->pvTimerID = pvTimerID;
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8003ef0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
 8003ef2:	f8c4 a000 	str.w	sl, [r4]
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 8003ef6:	61a6      	str	r6, [r4, #24]
			pxNewTimer->uxAutoReload = uxAutoReload;
 8003ef8:	f8c4 901c 	str.w	r9, [r4, #28]
			pxNewTimer->pvTimerID = pvTimerID;
 8003efc:	6227      	str	r7, [r4, #32]
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8003efe:	6263      	str	r3, [r4, #36]	; 0x24
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 8003f00:	1d20      	adds	r0, r4, #4
 8003f02:	f000 fa3d 	bl	8004380 <vListInitialiseItem>

	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	return ( TimerHandle_t ) pxNewTimer;
}
 8003f06:	4620      	mov	r0, r4
 8003f08:	b003      	add	sp, #12
 8003f0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			traceTIMER_CREATE_FAILED();
		}
	}

	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
 8003f0e:	f7fd fea3 	bl	8001c58 <ulPortSetInterruptMask>
 8003f12:	e7fe      	b.n	8003f12 <xTimerCreate+0x4a>
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
 8003f14:	f105 0804 	add.w	r8, r5, #4
 8003f18:	4640      	mov	r0, r8
			vListInitialise( &xActiveTimerList2 );
 8003f1a:	f105 0b18 	add.w	fp, r5, #24
 8003f1e:	9201      	str	r2, [sp, #4]
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
 8003f20:	f000 fa22 	bl	8004368 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 8003f24:	4658      	mov	r0, fp
 8003f26:	f000 fa1f 	bl	8004368 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8003f2a:	9a01      	ldr	r2, [sp, #4]
 8003f2c:	2005      	movs	r0, #5
 8003f2e:	210c      	movs	r1, #12
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
			vListInitialise( &xActiveTimerList2 );
			pxCurrentTimerList = &xActiveTimerList1;
 8003f30:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
			pxOverflowTimerList = &xActiveTimerList2;
 8003f34:	f8c5 b030 	str.w	fp, [r5, #48]	; 0x30
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8003f38:	f7fe f806 	bl	8001f48 <xQueueGenericCreate>
 8003f3c:	6028      	str	r0, [r5, #0]
			configASSERT( xTimerQueue );
 8003f3e:	2800      	cmp	r0, #0
 8003f40:	d1d4      	bne.n	8003eec <xTimerCreate+0x24>
 8003f42:	f7fd fe89 	bl	8001c58 <ulPortSetInterruptMask>
 8003f46:	e7fe      	b.n	8003f46 <xTimerCreate+0x7e>
 8003f48:	20000140 	.word	0x20000140

08003f4c <xTimerGenericCommand>:
	return ( TimerHandle_t ) pxNewTimer;
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
 8003f4c:	b530      	push	{r4, r5, lr}
BaseType_t xReturn = pdFAIL;
DaemonTaskMessage_t xMessage;

	configASSERT( xTimer );
 8003f4e:	4605      	mov	r5, r0
	return ( TimerHandle_t ) pxNewTimer;
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
 8003f50:	b085      	sub	sp, #20
BaseType_t xReturn = pdFAIL;
DaemonTaskMessage_t xMessage;

	configASSERT( xTimer );
 8003f52:	b310      	cbz	r0, 8003f9a <xTimerGenericCommand+0x4e>

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 8003f54:	4c12      	ldr	r4, [pc, #72]	; (8003fa0 <xTimerGenericCommand+0x54>)
 8003f56:	6820      	ldr	r0, [r4, #0]
 8003f58:	b170      	cbz	r0, 8003f78 <xTimerGenericCommand+0x2c>
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 8003f5a:	2905      	cmp	r1, #5
	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 8003f5c:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 8003f5e:	9202      	str	r2, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
 8003f60:	9503      	str	r5, [sp, #12]

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 8003f62:	dc0b      	bgt.n	8003f7c <xTimerGenericCommand+0x30>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8003f64:	f7ff fc66 	bl	8003834 <xTaskGetSchedulerState>
 8003f68:	2802      	cmp	r0, #2
 8003f6a:	d00e      	beq.n	8003f8a <xTimerGenericCommand+0x3e>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 8003f6c:	2200      	movs	r2, #0
 8003f6e:	6820      	ldr	r0, [r4, #0]
 8003f70:	4613      	mov	r3, r2
 8003f72:	a901      	add	r1, sp, #4
 8003f74:	f7fe f826 	bl	8001fc4 <xQueueGenericSend>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
 8003f78:	b005      	add	sp, #20
 8003f7a:	bd30      	pop	{r4, r5, pc}
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 8003f7c:	461a      	mov	r2, r3
 8003f7e:	a901      	add	r1, sp, #4
 8003f80:	2300      	movs	r3, #0
 8003f82:	f7fe f9a5 	bl	80022d0 <xQueueGenericSendFromISR>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
 8003f86:	b005      	add	sp, #20
 8003f88:	bd30      	pop	{r4, r5, pc}

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8003f8a:	6820      	ldr	r0, [r4, #0]
 8003f8c:	a901      	add	r1, sp, #4
 8003f8e:	9a08      	ldr	r2, [sp, #32]
 8003f90:	2300      	movs	r3, #0
 8003f92:	f7fe f817 	bl	8001fc4 <xQueueGenericSend>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
 8003f96:	b005      	add	sp, #20
 8003f98:	bd30      	pop	{r4, r5, pc}
BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
DaemonTaskMessage_t xMessage;

	configASSERT( xTimer );
 8003f9a:	f7fd fe5d 	bl	8001c58 <ulPortSetInterruptMask>
 8003f9e:	e7fe      	b.n	8003f9e <xTimerGenericCommand+0x52>
 8003fa0:	20000140 	.word	0x20000140

08003fa4 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
 8003fa4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003fa8:	4cb0      	ldr	r4, [pc, #704]	; (800426c <prvTimerTask+0x2c8>)
 8003faa:	b089      	sub	sp, #36	; 0x24
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8003fac:	4627      	mov	r7, r4

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8003fae:	46a0      	mov	r8, r4
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8003fb0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	if( *pxListWasEmpty == pdFALSE )
 8003fb2:	681d      	ldr	r5, [r3, #0]
 8003fb4:	b17d      	cbz	r5, 8003fd6 <prvTimerTask+0x32>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8003fb6:	68db      	ldr	r3, [r3, #12]
 8003fb8:	681d      	ldr	r5, [r3, #0]
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
 8003fba:	f7fe ffcb 	bl	8002f54 <vTaskSuspendAll>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 8003fbe:	f7fe ffd3 	bl	8002f68 <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
 8003fc2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 8003fc4:	4606      	mov	r6, r0

	if( xTimeNow < xLastTime )
 8003fc6:	4298      	cmp	r0, r3
 8003fc8:	d363      	bcc.n	8004092 <prvTimerTask+0xee>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8003fca:	4285      	cmp	r5, r0
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
	}

	xLastTime = xTimeNow;
 8003fcc:	6378      	str	r0, [r7, #52]	; 0x34
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8003fce:	f240 80cb 	bls.w	8004168 <prvTimerTask+0x1c4>
 8003fd2:	2200      	movs	r2, #0
 8003fd4:	e00d      	b.n	8003ff2 <prvTimerTask+0x4e>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
 8003fd6:	f7fe ffbd 	bl	8002f54 <vTaskSuspendAll>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 8003fda:	f7fe ffc5 	bl	8002f68 <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
 8003fde:	6b7b      	ldr	r3, [r7, #52]	; 0x34
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 8003fe0:	4606      	mov	r6, r0

	if( xTimeNow < xLastTime )
 8003fe2:	4298      	cmp	r0, r3
 8003fe4:	d355      	bcc.n	8004092 <prvTimerTask+0xee>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 8003fe6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
	}

	xLastTime = xTimeNow;
 8003fe8:	6378      	str	r0, [r7, #52]	; 0x34
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 8003fea:	681a      	ldr	r2, [r3, #0]
 8003fec:	fab2 f282 	clz	r2, r2
 8003ff0:	0952      	lsrs	r2, r2, #5
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 8003ff2:	1ba9      	subs	r1, r5, r6
 8003ff4:	6820      	ldr	r0, [r4, #0]
 8003ff6:	f7fe fc37 	bl	8002868 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
 8003ffa:	f7ff f859 	bl	80030b0 <xTaskResumeAll>
 8003ffe:	2800      	cmp	r0, #0
 8004000:	d074      	beq.n	80040ec <prvTimerTask+0x148>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8004002:	2200      	movs	r2, #0
 8004004:	4613      	mov	r3, r2
 8004006:	6820      	ldr	r0, [r4, #0]
 8004008:	a902      	add	r1, sp, #8
 800400a:	f7fe fa41 	bl	8002490 <xQueueGenericReceive>
 800400e:	2800      	cmp	r0, #0
 8004010:	d0ce      	beq.n	8003fb0 <prvTimerTask+0xc>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 8004012:	9b02      	ldr	r3, [sp, #8]
 8004014:	2b00      	cmp	r3, #0
 8004016:	dbf4      	blt.n	8004002 <prvTimerTask+0x5e>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 8004018:	9e04      	ldr	r6, [sp, #16]

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
 800401a:	6973      	ldr	r3, [r6, #20]
 800401c:	b113      	cbz	r3, 8004024 <prvTimerTask+0x80>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 800401e:	1d30      	adds	r0, r6, #4
 8004020:	f000 f9dc 	bl	80043dc <uxListRemove>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 8004024:	f7fe ffa0 	bl	8002f68 <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
 8004028:	6b63      	ldr	r3, [r4, #52]	; 0x34
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 800402a:	4682      	mov	sl, r0

	if( xTimeNow < xLastTime )
 800402c:	4298      	cmp	r0, r3
 800402e:	d325      	bcc.n	800407c <prvTimerTask+0xd8>
 8004030:	9a02      	ldr	r2, [sp, #8]
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
	}

	xLastTime = xTimeNow;
 8004032:	f8c4 a034 	str.w	sl, [r4, #52]	; 0x34
 8004036:	2a09      	cmp	r2, #9
 8004038:	d8e3      	bhi.n	8004002 <prvTimerTask+0x5e>
 800403a:	2301      	movs	r3, #1
 800403c:	4093      	lsls	r3, r2
 800403e:	f413 7f04 	tst.w	r3, #528	; 0x210
 8004042:	f040 80da 	bne.w	80041fa <prvTimerTask+0x256>
 8004046:	f013 0fc7 	tst.w	r3, #199	; 0xc7
 800404a:	f040 80c6 	bne.w	80041da <prvTimerTask+0x236>
 800404e:	069b      	lsls	r3, r3, #26
 8004050:	d5d7      	bpl.n	8004002 <prvTimerTask+0x5e>
					break;

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
 8004052:	4630      	mov	r0, r6
 8004054:	f000 f970 	bl	8004338 <vPortFree>
 8004058:	e7d3      	b.n	8004002 <prvTimerTask+0x5e>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800405a:	68da      	ldr	r2, [r3, #12]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 800405c:	f8d2 b00c 	ldr.w	fp, [r2, #12]
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8004060:	6815      	ldr	r5, [r2, #0]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8004062:	f10b 0904 	add.w	r9, fp, #4
 8004066:	4648      	mov	r0, r9
 8004068:	f000 f9b8 	bl	80043dc <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 800406c:	f8db 2024 	ldr.w	r2, [fp, #36]	; 0x24
 8004070:	4658      	mov	r0, fp
 8004072:	4790      	blx	r2

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 8004074:	f8db 201c 	ldr.w	r2, [fp, #28]
 8004078:	2a01      	cmp	r2, #1
 800407a:	d03a      	beq.n	80040f2 <prvTimerTask+0x14e>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 800407c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800407e:	681a      	ldr	r2, [r3, #0]
 8004080:	2a00      	cmp	r2, #0
 8004082:	d1ea      	bne.n	800405a <prvTimerTask+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
 8004084:	f8d8 2030 	ldr.w	r2, [r8, #48]	; 0x30
	pxOverflowTimerList = pxTemp;
 8004088:	f8c8 3030 	str.w	r3, [r8, #48]	; 0x30
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
 800408c:	f8c8 202c 	str.w	r2, [r8, #44]	; 0x2c
 8004090:	e7ce      	b.n	8004030 <prvTimerTask+0x8c>
	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 8004092:	f04f 0a00 	mov.w	sl, #0
 8004096:	e00e      	b.n	80040b6 <prvTimerTask+0x112>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8004098:	68db      	ldr	r3, [r3, #12]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 800409a:	68dd      	ldr	r5, [r3, #12]
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800409c:	f8d3 b000 	ldr.w	fp, [r3]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 80040a0:	f105 0904 	add.w	r9, r5, #4
 80040a4:	4648      	mov	r0, r9
 80040a6:	f000 f999 	bl	80043dc <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 80040aa:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80040ac:	4628      	mov	r0, r5
 80040ae:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 80040b0:	69eb      	ldr	r3, [r5, #28]
 80040b2:	2b01      	cmp	r3, #1
 80040b4:	d00e      	beq.n	80040d4 <prvTimerTask+0x130>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 80040b6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80040b8:	681a      	ldr	r2, [r3, #0]
 80040ba:	2a00      	cmp	r2, #0
 80040bc:	d1ec      	bne.n	8004098 <prvTimerTask+0xf4>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
 80040be:	f8d8 2030 	ldr.w	r2, [r8, #48]	; 0x30
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
	}

	xLastTime = xTimeNow;
 80040c2:	f8c8 6034 	str.w	r6, [r8, #52]	; 0x34
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
 80040c6:	f8c8 202c 	str.w	r2, [r8, #44]	; 0x2c
	pxOverflowTimerList = pxTemp;
 80040ca:	f8c8 3030 	str.w	r3, [r8, #48]	; 0x30
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
 80040ce:	f7fe ffef 	bl	80030b0 <xTaskResumeAll>
 80040d2:	e796      	b.n	8004002 <prvTimerTask+0x5e>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 80040d4:	69ab      	ldr	r3, [r5, #24]
 80040d6:	445b      	add	r3, fp
			if( xReloadTime > xNextExpireTime )
 80040d8:	455b      	cmp	r3, fp
 80040da:	d919      	bls.n	8004110 <prvTimerTask+0x16c>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 80040dc:	606b      	str	r3, [r5, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80040de:	4b63      	ldr	r3, [pc, #396]	; (800426c <prvTimerTask+0x2c8>)
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
			if( xReloadTime > xNextExpireTime )
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 80040e0:	612d      	str	r5, [r5, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80040e2:	4649      	mov	r1, r9
 80040e4:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 80040e6:	f000 f95f 	bl	80043a8 <vListInsert>
 80040ea:	e7e4      	b.n	80040b6 <prvTimerTask+0x112>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
 80040ec:	f7fd fda8 	bl	8001c40 <vPortYield>
 80040f0:	e787      	b.n	8004002 <prvTimerTask+0x5e>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 80040f2:	f8db 2018 	ldr.w	r2, [fp, #24]
 80040f6:	442a      	add	r2, r5
			if( xReloadTime > xNextExpireTime )
 80040f8:	42aa      	cmp	r2, r5
 80040fa:	d91f      	bls.n	800413c <prvTimerTask+0x198>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80040fc:	4b5b      	ldr	r3, [pc, #364]	; (800426c <prvTimerTask+0x2c8>)
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
			if( xReloadTime > xNextExpireTime )
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 80040fe:	f8cb 2004 	str.w	r2, [fp, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8004102:	f8cb b010 	str.w	fp, [fp, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8004106:	4649      	mov	r1, r9
 8004108:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 800410a:	f000 f94d 	bl	80043a8 <vListInsert>
 800410e:	e7b5      	b.n	800407c <prvTimerTask+0xd8>

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 8004110:	4b56      	ldr	r3, [pc, #344]	; (800426c <prvTimerTask+0x2c8>)
 8004112:	681b      	ldr	r3, [r3, #0]
 8004114:	b17b      	cbz	r3, 8004136 <prvTimerTask+0x192>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 8004116:	f8cd a014 	str.w	sl, [sp, #20]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 800411a:	f8cd b018 	str.w	fp, [sp, #24]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
 800411e:	9507      	str	r5, [sp, #28]

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8004120:	f7ff fb88 	bl	8003834 <xTaskGetSchedulerState>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8004124:	4951      	ldr	r1, [pc, #324]	; (800426c <prvTimerTask+0x2c8>)
 8004126:	2200      	movs	r2, #0
 8004128:	6808      	ldr	r0, [r1, #0]
 800412a:	4613      	mov	r3, r2
 800412c:	a905      	add	r1, sp, #20
 800412e:	f7fd ff49 	bl	8001fc4 <xQueueGenericSend>
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
				configASSERT( xResult );
 8004132:	2800      	cmp	r0, #0
 8004134:	d1bf      	bne.n	80040b6 <prvTimerTask+0x112>
 8004136:	f7fd fd8f 	bl	8001c58 <ulPortSetInterruptMask>
 800413a:	e7fe      	b.n	800413a <prvTimerTask+0x196>

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 800413c:	4b4b      	ldr	r3, [pc, #300]	; (800426c <prvTimerTask+0x2c8>)
 800413e:	681a      	ldr	r2, [r3, #0]
 8004140:	b17a      	cbz	r2, 8004162 <prvTimerTask+0x1be>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 8004142:	2300      	movs	r3, #0
 8004144:	9305      	str	r3, [sp, #20]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 8004146:	9506      	str	r5, [sp, #24]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
 8004148:	f8cd b01c 	str.w	fp, [sp, #28]

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 800414c:	f7ff fb72 	bl	8003834 <xTaskGetSchedulerState>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8004150:	4946      	ldr	r1, [pc, #280]	; (800426c <prvTimerTask+0x2c8>)
 8004152:	2200      	movs	r2, #0
 8004154:	6808      	ldr	r0, [r1, #0]
 8004156:	4613      	mov	r3, r2
 8004158:	a905      	add	r1, sp, #20
 800415a:	f7fd ff33 	bl	8001fc4 <xQueueGenericSend>
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
				configASSERT( xResult );
 800415e:	2800      	cmp	r0, #0
 8004160:	d18c      	bne.n	800407c <prvTimerTask+0xd8>
 8004162:	f7fd fd79 	bl	8001c58 <ulPortSetInterruptMask>
 8004166:	e7fe      	b.n	8004166 <prvTimerTask+0x1c2>
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
			{
				( void ) xTaskResumeAll();
 8004168:	f7fe ffa2 	bl	80030b0 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 800416c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800416e:	68db      	ldr	r3, [r3, #12]
 8004170:	f8d3 a00c 	ldr.w	sl, [r3, #12]

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8004174:	f10a 0b04 	add.w	fp, sl, #4
 8004178:	4658      	mov	r0, fp
 800417a:	f000 f92f 	bl	80043dc <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 800417e:	f8da 301c 	ldr.w	r3, [sl, #28]
 8004182:	2b01      	cmp	r3, #1
 8004184:	d004      	beq.n	8004190 <prvTimerTask+0x1ec>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8004186:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
 800418a:	4650      	mov	r0, sl
 800418c:	4798      	blx	r3
 800418e:	e738      	b.n	8004002 <prvTimerTask+0x5e>
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
 8004190:	f8da 3018 	ldr.w	r3, [sl, #24]
static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8004194:	f8ca a010 	str.w	sl, [sl, #16]
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
 8004198:	18ea      	adds	r2, r5, r3
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );

	if( xNextExpiryTime <= xTimeNow )
 800419a:	42b2      	cmp	r2, r6

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 800419c:	f8ca 2004 	str.w	r2, [sl, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );

	if( xNextExpiryTime <= xTimeNow )
 80041a0:	d816      	bhi.n	80041d0 <prvTimerTask+0x22c>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
 80041a2:	1b76      	subs	r6, r6, r5
 80041a4:	42b3      	cmp	r3, r6
 80041a6:	d838      	bhi.n	800421a <prvTimerTask+0x276>

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 80041a8:	683b      	ldr	r3, [r7, #0]
 80041aa:	b173      	cbz	r3, 80041ca <prvTimerTask+0x226>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 80041ac:	2600      	movs	r6, #0
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 80041ae:	9506      	str	r5, [sp, #24]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
 80041b0:	f8cd a01c 	str.w	sl, [sp, #28]
	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 80041b4:	9605      	str	r6, [sp, #20]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 80041b6:	f7ff fb3d 	bl	8003834 <xTaskGetSchedulerState>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 80041ba:	4632      	mov	r2, r6
 80041bc:	4633      	mov	r3, r6
 80041be:	6838      	ldr	r0, [r7, #0]
 80041c0:	a905      	add	r1, sp, #20
 80041c2:	f7fd feff 	bl	8001fc4 <xQueueGenericSend>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
			configASSERT( xResult );
 80041c6:	2800      	cmp	r0, #0
 80041c8:	d1dd      	bne.n	8004186 <prvTimerTask+0x1e2>
 80041ca:	f7fd fd45 	bl	8001c58 <ulPortSetInterruptMask>
 80041ce:	e7fe      	b.n	80041ce <prvTimerTask+0x22a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80041d0:	4659      	mov	r1, fp
 80041d2:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80041d4:	f000 f8e8 	bl	80043a8 <vListInsert>
 80041d8:	e7d5      	b.n	8004186 <prvTimerTask+0x1e2>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
 80041da:	9b03      	ldr	r3, [sp, #12]
 80041dc:	69b1      	ldr	r1, [r6, #24]
static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 80041de:	6136      	str	r6, [r6, #16]
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
 80041e0:	18ca      	adds	r2, r1, r3
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );

	if( xNextExpiryTime <= xTimeNow )
 80041e2:	4552      	cmp	r2, sl

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 80041e4:	6072      	str	r2, [r6, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );

	if( xNextExpiryTime <= xTimeNow )
 80041e6:	d91d      	bls.n	8004224 <prvTimerTask+0x280>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 80041e8:	4553      	cmp	r3, sl
 80041ea:	d901      	bls.n	80041f0 <prvTimerTask+0x24c>
 80041ec:	4293      	cmp	r3, r2
 80041ee:	d91d      	bls.n	800422c <prvTimerTask+0x288>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80041f0:	1d31      	adds	r1, r6, #4
 80041f2:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80041f4:	f000 f8d8 	bl	80043a8 <vListInsert>
 80041f8:	e703      	b.n	8004002 <prvTimerTask+0x5e>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 80041fa:	9b03      	ldr	r3, [sp, #12]
 80041fc:	61b3      	str	r3, [r6, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 80041fe:	b35b      	cbz	r3, 8004258 <prvTimerTask+0x2b4>
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 8004200:	4453      	add	r3, sl
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );

	if( xNextExpiryTime <= xTimeNow )
 8004202:	4553      	cmp	r3, sl

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8004204:	6073      	str	r3, [r6, #4]
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8004206:	4b19      	ldr	r3, [pc, #100]	; (800426c <prvTimerTask+0x2c8>)
static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8004208:	6136      	str	r6, [r6, #16]
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 800420a:	f106 0104 	add.w	r1, r6, #4
 800420e:	bf94      	ite	ls
 8004210:	6b18      	ldrls	r0, [r3, #48]	; 0x30
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8004212:	6ad8      	ldrhi	r0, [r3, #44]	; 0x2c
 8004214:	f000 f8c8 	bl	80043a8 <vListInsert>
 8004218:	e6f3      	b.n	8004002 <prvTimerTask+0x5e>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 800421a:	4659      	mov	r1, fp
 800421c:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800421e:	f000 f8c3 	bl	80043a8 <vListInsert>
 8004222:	e7b0      	b.n	8004186 <prvTimerTask+0x1e2>

	if( xNextExpiryTime <= xTimeNow )
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
 8004224:	ebc3 030a 	rsb	r3, r3, sl
 8004228:	4299      	cmp	r1, r3
 800422a:	d818      	bhi.n	800425e <prvTimerTask+0x2ba>
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 800422c:	6a73      	ldr	r3, [r6, #36]	; 0x24
 800422e:	4630      	mov	r0, r6
 8004230:	4798      	blx	r3
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 8004232:	69f3      	ldr	r3, [r6, #28]
 8004234:	2b01      	cmp	r3, #1
 8004236:	f47f aee4 	bne.w	8004002 <prvTimerTask+0x5e>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 800423a:	69b2      	ldr	r2, [r6, #24]
 800423c:	9b03      	ldr	r3, [sp, #12]
 800423e:	2100      	movs	r1, #0
 8004240:	441a      	add	r2, r3
 8004242:	4630      	mov	r0, r6
 8004244:	9100      	str	r1, [sp, #0]
 8004246:	460b      	mov	r3, r1
 8004248:	f7ff fe80 	bl	8003f4c <xTimerGenericCommand>
							configASSERT( xResult );
 800424c:	2800      	cmp	r0, #0
 800424e:	f47f aed8 	bne.w	8004002 <prvTimerTask+0x5e>
 8004252:	f7fd fd01 	bl	8001c58 <ulPortSetInterruptMask>
 8004256:	e7fe      	b.n	8004256 <prvTimerTask+0x2b2>
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 8004258:	f7fd fcfe 	bl	8001c58 <ulPortSetInterruptMask>
 800425c:	e7fe      	b.n	800425c <prvTimerTask+0x2b8>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 800425e:	4b03      	ldr	r3, [pc, #12]	; (800426c <prvTimerTask+0x2c8>)
 8004260:	1d31      	adds	r1, r6, #4
 8004262:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8004264:	f000 f8a0 	bl	80043a8 <vListInsert>
 8004268:	e6cb      	b.n	8004002 <prvTimerTask+0x5e>
 800426a:	bf00      	nop
 800426c:	20000140 	.word	0x20000140

08004270 <pcTimerGetTimerName>:

const char * pcTimerGetTimerName( TimerHandle_t xTimer )
{
Timer_t *pxTimer = ( Timer_t * ) xTimer;

	configASSERT( xTimer );
 8004270:	b108      	cbz	r0, 8004276 <pcTimerGetTimerName+0x6>
	return pxTimer->pcTimerName;
}
 8004272:	6800      	ldr	r0, [r0, #0]
 8004274:	4770      	bx	lr

#endif
/*-----------------------------------------------------------*/

const char * pcTimerGetTimerName( TimerHandle_t xTimer )
{
 8004276:	b508      	push	{r3, lr}
Timer_t *pxTimer = ( Timer_t * ) xTimer;

	configASSERT( xTimer );
 8004278:	f7fd fcee 	bl	8001c58 <ulPortSetInterruptMask>
 800427c:	e7fe      	b.n	800427c <pcTimerGetTimerName+0xc>
 800427e:	bf00      	nop

08004280 <xTimerIsTimerActive>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
{
 8004280:	b510      	push	{r4, lr}
BaseType_t xTimerIsInActiveList;
Timer_t *pxTimer = ( Timer_t * ) xTimer;

	configASSERT( xTimer );
 8004282:	4604      	mov	r4, r0
 8004284:	b148      	cbz	r0, 800429a <xTimerIsTimerActive+0x1a>

	/* Is the timer in the list of active timers? */
	taskENTER_CRITICAL();
 8004286:	f7fd fd09 	bl	8001c9c <vPortEnterCritical>
	{
		/* Checking to see if it is in the NULL list in effect checks to see if
		it is referenced from either the current or the overflow timer lists in
		one go, but the logic has to be reversed, hence the '!'. */
		xTimerIsInActiveList = ( BaseType_t ) !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
 800428a:	6964      	ldr	r4, [r4, #20]
 800428c:	3400      	adds	r4, #0
 800428e:	bf18      	it	ne
 8004290:	2401      	movne	r4, #1
	}
	taskEXIT_CRITICAL();
 8004292:	f7fd fd21 	bl	8001cd8 <vPortExitCritical>

	return xTimerIsInActiveList;
} /*lint !e818 Can't be pointer to const due to the typedef. */
 8004296:	4620      	mov	r0, r4
 8004298:	bd10      	pop	{r4, pc}
BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
{
BaseType_t xTimerIsInActiveList;
Timer_t *pxTimer = ( Timer_t * ) xTimer;

	configASSERT( xTimer );
 800429a:	f7fd fcdd 	bl	8001c58 <ulPortSetInterruptMask>
 800429e:	e7fe      	b.n	800429e <xTimerIsTimerActive+0x1e>

080042a0 <pvTimerGetTimerID>:
	return xTimerIsInActiveList;
} /*lint !e818 Can't be pointer to const due to the typedef. */
/*-----------------------------------------------------------*/

void *pvTimerGetTimerID( const TimerHandle_t xTimer )
{
 80042a0:	b510      	push	{r4, lr}
Timer_t * const pxTimer = ( Timer_t * ) xTimer;
void *pvReturn;

	configASSERT( xTimer );
 80042a2:	4604      	mov	r4, r0
 80042a4:	b130      	cbz	r0, 80042b4 <pvTimerGetTimerID+0x14>

	taskENTER_CRITICAL();
 80042a6:	f7fd fcf9 	bl	8001c9c <vPortEnterCritical>
	{
		pvReturn = pxTimer->pvTimerID;
 80042aa:	6a24      	ldr	r4, [r4, #32]
	}
	taskEXIT_CRITICAL();
 80042ac:	f7fd fd14 	bl	8001cd8 <vPortExitCritical>

	return pvReturn;
}
 80042b0:	4620      	mov	r0, r4
 80042b2:	bd10      	pop	{r4, pc}
void *pvTimerGetTimerID( const TimerHandle_t xTimer )
{
Timer_t * const pxTimer = ( Timer_t * ) xTimer;
void *pvReturn;

	configASSERT( xTimer );
 80042b4:	f7fd fcd0 	bl	8001c58 <ulPortSetInterruptMask>
 80042b8:	e7fe      	b.n	80042b8 <pvTimerGetTimerID+0x18>
 80042ba:	bf00      	nop

080042bc <vTimerSetTimerID>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
{
 80042bc:	b538      	push	{r3, r4, r5, lr}
Timer_t * const pxTimer = ( Timer_t * ) xTimer;

	configASSERT( xTimer );
 80042be:	4604      	mov	r4, r0
 80042c0:	b138      	cbz	r0, 80042d2 <vTimerSetTimerID+0x16>
 80042c2:	460d      	mov	r5, r1

	taskENTER_CRITICAL();
 80042c4:	f7fd fcea 	bl	8001c9c <vPortEnterCritical>
	{
		pxTimer->pvTimerID = pvNewID;
 80042c8:	6225      	str	r5, [r4, #32]
	}
	taskEXIT_CRITICAL();
}
 80042ca:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

	taskENTER_CRITICAL();
	{
		pxTimer->pvTimerID = pvNewID;
	}
	taskEXIT_CRITICAL();
 80042ce:	f7fd bd03 	b.w	8001cd8 <vPortExitCritical>

void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
{
Timer_t * const pxTimer = ( Timer_t * ) xTimer;

	configASSERT( xTimer );
 80042d2:	f7fd fcc1 	bl	8001c58 <ulPortSetInterruptMask>
 80042d6:	e7fe      	b.n	80042d6 <vTimerSetTimerID+0x1a>

080042d8 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 80042d8:	b538      	push	{r3, r4, r5, lr}
 80042da:	4604      	mov	r4, r0
void *pvReturn = NULL;
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if portBYTE_ALIGNMENT != 1
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 80042dc:	0743      	lsls	r3, r0, #29
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 80042de:	bf1c      	itt	ne
 80042e0:	f020 0407 	bicne.w	r4, r0, #7
 80042e4:	3408      	addne	r4, #8
		}
	#endif

	vTaskSuspendAll();
 80042e6:	f7fe fe35 	bl	8002f54 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 80042ea:	4b11      	ldr	r3, [pc, #68]	; (8004330 <pvPortMalloc+0x58>)
 80042ec:	681d      	ldr	r5, [r3, #0]
 80042ee:	b1c5      	cbz	r5, 8004322 <pvPortMalloc+0x4a>
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 80042f0:	f641 31f7 	movw	r1, #7159	; 0x1bf7
 80042f4:	4a0f      	ldr	r2, [pc, #60]	; (8004334 <pvPortMalloc+0x5c>)
 80042f6:	f8d2 3b0c 	ldr.w	r3, [r2, #2828]	; 0xb0c
 80042fa:	441c      	add	r4, r3
 80042fc:	428c      	cmp	r4, r1
 80042fe:	d809      	bhi.n	8004314 <pvPortMalloc+0x3c>
 8004300:	42a3      	cmp	r3, r4
 8004302:	d207      	bcs.n	8004314 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 8004304:	441d      	add	r5, r3
			xNextFreeByte += xWantedSize;
 8004306:	f8c2 4b0c 	str.w	r4, [r2, #2828]	; 0xb0c
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 800430a:	f7fe fed1 	bl	80030b0 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
 800430e:	b11d      	cbz	r5, 8004318 <pvPortMalloc+0x40>
		}
	}
	#endif

	return pvReturn;
}
 8004310:	4628      	mov	r0, r5
 8004312:	bd38      	pop	{r3, r4, r5, pc}
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 8004314:	f7fe fecc 	bl	80030b0 <xTaskResumeAll>
	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
 8004318:	2500      	movs	r5, #0
 800431a:	f7fc f827 	bl	800036c <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
}
 800431e:	4628      	mov	r0, r5
 8004320:	bd38      	pop	{r3, r4, r5, pc}
	vTaskSuspendAll();
	{
		if( pucAlignedHeap == NULL )
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 8004322:	f103 050c 	add.w	r5, r3, #12
 8004326:	f025 0507 	bic.w	r5, r5, #7
 800432a:	601d      	str	r5, [r3, #0]
 800432c:	e7e0      	b.n	80042f0 <pvPortMalloc+0x18>
 800432e:	bf00      	nop
 8004330:	20000178 	.word	0x20000178
 8004334:	20001270 	.word	0x20001270

08004338 <vPortFree>:
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
 8004338:	b118      	cbz	r0, 8004342 <vPortFree+0xa>
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 800433a:	b508      	push	{r3, lr}
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
 800433c:	f7fd fc8c 	bl	8001c58 <ulPortSetInterruptMask>
 8004340:	e7fe      	b.n	8004340 <vPortFree+0x8>
 8004342:	4770      	bx	lr

08004344 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
 8004344:	4b02      	ldr	r3, [pc, #8]	; (8004350 <vPortInitialiseBlocks+0xc>)
 8004346:	2200      	movs	r2, #0
 8004348:	f8c3 2b0c 	str.w	r2, [r3, #2828]	; 0xb0c
 800434c:	4770      	bx	lr
 800434e:	bf00      	nop
 8004350:	20001270 	.word	0x20001270

08004354 <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
 8004354:	4b03      	ldr	r3, [pc, #12]	; (8004364 <xPortGetFreeHeapSize+0x10>)
 8004356:	f8d3 0b0c 	ldr.w	r0, [r3, #2828]	; 0xb0c
}
 800435a:	f5c0 50df 	rsb	r0, r0, #7136	; 0x1be0
 800435e:	3018      	adds	r0, #24
 8004360:	4770      	bx	lr
 8004362:	bf00      	nop
 8004364:	20001270 	.word	0x20001270

08004368 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8004368:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800436c:	f04f 31ff 	mov.w	r1, #4294967295
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8004370:	2200      	movs	r2, #0
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8004372:	6081      	str	r1, [r0, #8]
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8004374:	e880 000c 	stmia.w	r0, {r2, r3}
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8004378:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800437a:	6103      	str	r3, [r0, #16]
 800437c:	4770      	bx	lr
 800437e:	bf00      	nop

08004380 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8004380:	2300      	movs	r3, #0
 8004382:	6103      	str	r3, [r0, #16]
 8004384:	4770      	bx	lr
 8004386:	bf00      	nop

08004388 <vListInsertEnd>:
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8004388:	e890 000c 	ldmia.w	r0, {r2, r3}
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 800438c:	b410      	push	{r4}

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800438e:	689c      	ldr	r4, [r3, #8]
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8004390:	3201      	adds	r2, #1

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8004392:	608c      	str	r4, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8004394:	689c      	ldr	r4, [r3, #8]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 8004396:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8004398:	6061      	str	r1, [r4, #4]
	pxIndex->pxPrevious = pxNewListItem;
 800439a:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
}
 800439c:	f85d 4b04 	ldr.w	r4, [sp], #4

	pxIndex->pxPrevious->pxNext = pxNewListItem;
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 80043a0:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 80043a2:	6002      	str	r2, [r0, #0]
}
 80043a4:	4770      	bx	lr
 80043a6:	bf00      	nop

080043a8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 80043a8:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 80043aa:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 80043ac:	1c6b      	adds	r3, r5, #1
 80043ae:	d011      	beq.n	80043d4 <vListInsert+0x2c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80043b0:	f100 0208 	add.w	r2, r0, #8
 80043b4:	e000      	b.n	80043b8 <vListInsert+0x10>
 80043b6:	461a      	mov	r2, r3
 80043b8:	6853      	ldr	r3, [r2, #4]
 80043ba:	681c      	ldr	r4, [r3, #0]
 80043bc:	42a5      	cmp	r5, r4
 80043be:	d2fa      	bcs.n	80043b6 <vListInsert+0xe>

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 80043c0:	6804      	ldr	r4, [r0, #0]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 80043c2:	604b      	str	r3, [r1, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 80043c4:	3401      	adds	r4, #1
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 80043c6:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 80043c8:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 80043ca:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 80043cc:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 80043ce:	6004      	str	r4, [r0, #0]
}
 80043d0:	bc30      	pop	{r4, r5}
 80043d2:	4770      	bx	lr
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 80043d4:	6902      	ldr	r2, [r0, #16]
 80043d6:	6853      	ldr	r3, [r2, #4]
 80043d8:	e7f2      	b.n	80043c0 <vListInsert+0x18>
 80043da:	bf00      	nop

080043dc <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 80043dc:	6843      	ldr	r3, [r0, #4]
 80043de:	6881      	ldr	r1, [r0, #8]

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 80043e0:	6902      	ldr	r2, [r0, #16]
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 80043e2:	b410      	push	{r4}
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 80043e4:	6099      	str	r1, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 80043e6:	6881      	ldr	r1, [r0, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 80043e8:	6854      	ldr	r4, [r2, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 80043ea:	604b      	str	r3, [r1, #4]
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
	( pxList->uxNumberOfItems )--;
 80043ec:	6813      	ldr	r3, [r2, #0]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 80043ee:	4284      	cmp	r4, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 80043f0:	bf08      	it	eq
 80043f2:	6051      	streq	r1, [r2, #4]
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
	( pxList->uxNumberOfItems )--;
 80043f4:	3b01      	subs	r3, #1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 80043f6:	2100      	movs	r1, #0
 80043f8:	6101      	str	r1, [r0, #16]
	( pxList->uxNumberOfItems )--;

	return pxList->uxNumberOfItems;
}
 80043fa:	f85d 4b04 	ldr.w	r4, [sp], #4
 80043fe:	4618      	mov	r0, r3
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
	( pxList->uxNumberOfItems )--;
 8004400:	6013      	str	r3, [r2, #0]

	return pxList->uxNumberOfItems;
}
 8004402:	4770      	bx	lr

08004404 <__aeabi_fmul>:
 8004404:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8004408:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 800440c:	bf1e      	ittt	ne
 800440e:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8004412:	ea92 0f0c 	teqne	r2, ip
 8004416:	ea93 0f0c 	teqne	r3, ip
 800441a:	d06f      	beq.n	80044fc <__aeabi_fmul+0xf8>
 800441c:	441a      	add	r2, r3
 800441e:	ea80 0c01 	eor.w	ip, r0, r1
 8004422:	0240      	lsls	r0, r0, #9
 8004424:	bf18      	it	ne
 8004426:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 800442a:	d01e      	beq.n	800446a <__aeabi_fmul+0x66>
 800442c:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8004430:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 8004434:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 8004438:	fba0 3101 	umull	r3, r1, r0, r1
 800443c:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8004440:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8004444:	bf3e      	ittt	cc
 8004446:	0049      	lslcc	r1, r1, #1
 8004448:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 800444c:	005b      	lslcc	r3, r3, #1
 800444e:	ea40 0001 	orr.w	r0, r0, r1
 8004452:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 8004456:	2afd      	cmp	r2, #253	; 0xfd
 8004458:	d81d      	bhi.n	8004496 <__aeabi_fmul+0x92>
 800445a:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 800445e:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8004462:	bf08      	it	eq
 8004464:	f020 0001 	biceq.w	r0, r0, #1
 8004468:	4770      	bx	lr
 800446a:	f090 0f00 	teq	r0, #0
 800446e:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8004472:	bf08      	it	eq
 8004474:	0249      	lsleq	r1, r1, #9
 8004476:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 800447a:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 800447e:	3a7f      	subs	r2, #127	; 0x7f
 8004480:	bfc2      	ittt	gt
 8004482:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8004486:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 800448a:	4770      	bxgt	lr
 800448c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8004490:	f04f 0300 	mov.w	r3, #0
 8004494:	3a01      	subs	r2, #1
 8004496:	dc5d      	bgt.n	8004554 <__aeabi_fmul+0x150>
 8004498:	f112 0f19 	cmn.w	r2, #25
 800449c:	bfdc      	itt	le
 800449e:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 80044a2:	4770      	bxle	lr
 80044a4:	f1c2 0200 	rsb	r2, r2, #0
 80044a8:	0041      	lsls	r1, r0, #1
 80044aa:	fa21 f102 	lsr.w	r1, r1, r2
 80044ae:	f1c2 0220 	rsb	r2, r2, #32
 80044b2:	fa00 fc02 	lsl.w	ip, r0, r2
 80044b6:	ea5f 0031 	movs.w	r0, r1, rrx
 80044ba:	f140 0000 	adc.w	r0, r0, #0
 80044be:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 80044c2:	bf08      	it	eq
 80044c4:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 80044c8:	4770      	bx	lr
 80044ca:	f092 0f00 	teq	r2, #0
 80044ce:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80044d2:	bf02      	ittt	eq
 80044d4:	0040      	lsleq	r0, r0, #1
 80044d6:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80044da:	3a01      	subeq	r2, #1
 80044dc:	d0f9      	beq.n	80044d2 <__aeabi_fmul+0xce>
 80044de:	ea40 000c 	orr.w	r0, r0, ip
 80044e2:	f093 0f00 	teq	r3, #0
 80044e6:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80044ea:	bf02      	ittt	eq
 80044ec:	0049      	lsleq	r1, r1, #1
 80044ee:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80044f2:	3b01      	subeq	r3, #1
 80044f4:	d0f9      	beq.n	80044ea <__aeabi_fmul+0xe6>
 80044f6:	ea41 010c 	orr.w	r1, r1, ip
 80044fa:	e78f      	b.n	800441c <__aeabi_fmul+0x18>
 80044fc:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8004500:	ea92 0f0c 	teq	r2, ip
 8004504:	bf18      	it	ne
 8004506:	ea93 0f0c 	teqne	r3, ip
 800450a:	d00a      	beq.n	8004522 <__aeabi_fmul+0x11e>
 800450c:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8004510:	bf18      	it	ne
 8004512:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8004516:	d1d8      	bne.n	80044ca <__aeabi_fmul+0xc6>
 8004518:	ea80 0001 	eor.w	r0, r0, r1
 800451c:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8004520:	4770      	bx	lr
 8004522:	f090 0f00 	teq	r0, #0
 8004526:	bf17      	itett	ne
 8004528:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 800452c:	4608      	moveq	r0, r1
 800452e:	f091 0f00 	teqne	r1, #0
 8004532:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 8004536:	d014      	beq.n	8004562 <__aeabi_fmul+0x15e>
 8004538:	ea92 0f0c 	teq	r2, ip
 800453c:	d101      	bne.n	8004542 <__aeabi_fmul+0x13e>
 800453e:	0242      	lsls	r2, r0, #9
 8004540:	d10f      	bne.n	8004562 <__aeabi_fmul+0x15e>
 8004542:	ea93 0f0c 	teq	r3, ip
 8004546:	d103      	bne.n	8004550 <__aeabi_fmul+0x14c>
 8004548:	024b      	lsls	r3, r1, #9
 800454a:	bf18      	it	ne
 800454c:	4608      	movne	r0, r1
 800454e:	d108      	bne.n	8004562 <__aeabi_fmul+0x15e>
 8004550:	ea80 0001 	eor.w	r0, r0, r1
 8004554:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8004558:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 800455c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8004560:	4770      	bx	lr
 8004562:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8004566:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 800456a:	4770      	bx	lr

0800456c <__aeabi_fdiv>:
 800456c:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8004570:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8004574:	bf1e      	ittt	ne
 8004576:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 800457a:	ea92 0f0c 	teqne	r2, ip
 800457e:	ea93 0f0c 	teqne	r3, ip
 8004582:	d069      	beq.n	8004658 <__aeabi_fdiv+0xec>
 8004584:	eba2 0203 	sub.w	r2, r2, r3
 8004588:	ea80 0c01 	eor.w	ip, r0, r1
 800458c:	0249      	lsls	r1, r1, #9
 800458e:	ea4f 2040 	mov.w	r0, r0, lsl #9
 8004592:	d037      	beq.n	8004604 <__aeabi_fdiv+0x98>
 8004594:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8004598:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 800459c:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 80045a0:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80045a4:	428b      	cmp	r3, r1
 80045a6:	bf38      	it	cc
 80045a8:	005b      	lslcc	r3, r3, #1
 80045aa:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 80045ae:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 80045b2:	428b      	cmp	r3, r1
 80045b4:	bf24      	itt	cs
 80045b6:	1a5b      	subcs	r3, r3, r1
 80045b8:	ea40 000c 	orrcs.w	r0, r0, ip
 80045bc:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 80045c0:	bf24      	itt	cs
 80045c2:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 80045c6:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80045ca:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 80045ce:	bf24      	itt	cs
 80045d0:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 80045d4:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80045d8:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 80045dc:	bf24      	itt	cs
 80045de:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 80045e2:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80045e6:	011b      	lsls	r3, r3, #4
 80045e8:	bf18      	it	ne
 80045ea:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 80045ee:	d1e0      	bne.n	80045b2 <__aeabi_fdiv+0x46>
 80045f0:	2afd      	cmp	r2, #253	; 0xfd
 80045f2:	f63f af50 	bhi.w	8004496 <__aeabi_fmul+0x92>
 80045f6:	428b      	cmp	r3, r1
 80045f8:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80045fc:	bf08      	it	eq
 80045fe:	f020 0001 	biceq.w	r0, r0, #1
 8004602:	4770      	bx	lr
 8004604:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8004608:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 800460c:	327f      	adds	r2, #127	; 0x7f
 800460e:	bfc2      	ittt	gt
 8004610:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8004614:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8004618:	4770      	bxgt	lr
 800461a:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 800461e:	f04f 0300 	mov.w	r3, #0
 8004622:	3a01      	subs	r2, #1
 8004624:	e737      	b.n	8004496 <__aeabi_fmul+0x92>
 8004626:	f092 0f00 	teq	r2, #0
 800462a:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 800462e:	bf02      	ittt	eq
 8004630:	0040      	lsleq	r0, r0, #1
 8004632:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8004636:	3a01      	subeq	r2, #1
 8004638:	d0f9      	beq.n	800462e <__aeabi_fdiv+0xc2>
 800463a:	ea40 000c 	orr.w	r0, r0, ip
 800463e:	f093 0f00 	teq	r3, #0
 8004642:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8004646:	bf02      	ittt	eq
 8004648:	0049      	lsleq	r1, r1, #1
 800464a:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 800464e:	3b01      	subeq	r3, #1
 8004650:	d0f9      	beq.n	8004646 <__aeabi_fdiv+0xda>
 8004652:	ea41 010c 	orr.w	r1, r1, ip
 8004656:	e795      	b.n	8004584 <__aeabi_fdiv+0x18>
 8004658:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 800465c:	ea92 0f0c 	teq	r2, ip
 8004660:	d108      	bne.n	8004674 <__aeabi_fdiv+0x108>
 8004662:	0242      	lsls	r2, r0, #9
 8004664:	f47f af7d 	bne.w	8004562 <__aeabi_fmul+0x15e>
 8004668:	ea93 0f0c 	teq	r3, ip
 800466c:	f47f af70 	bne.w	8004550 <__aeabi_fmul+0x14c>
 8004670:	4608      	mov	r0, r1
 8004672:	e776      	b.n	8004562 <__aeabi_fmul+0x15e>
 8004674:	ea93 0f0c 	teq	r3, ip
 8004678:	d104      	bne.n	8004684 <__aeabi_fdiv+0x118>
 800467a:	024b      	lsls	r3, r1, #9
 800467c:	f43f af4c 	beq.w	8004518 <__aeabi_fmul+0x114>
 8004680:	4608      	mov	r0, r1
 8004682:	e76e      	b.n	8004562 <__aeabi_fmul+0x15e>
 8004684:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8004688:	bf18      	it	ne
 800468a:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 800468e:	d1ca      	bne.n	8004626 <__aeabi_fdiv+0xba>
 8004690:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 8004694:	f47f af5c 	bne.w	8004550 <__aeabi_fmul+0x14c>
 8004698:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 800469c:	f47f af3c 	bne.w	8004518 <__aeabi_fmul+0x114>
 80046a0:	e75f      	b.n	8004562 <__aeabi_fmul+0x15e>
 80046a2:	bf00      	nop

080046a4 <__gesf2>:
 80046a4:	f04f 3cff 	mov.w	ip, #4294967295
 80046a8:	e006      	b.n	80046b8 <__cmpsf2+0x4>
 80046aa:	bf00      	nop

080046ac <__lesf2>:
 80046ac:	f04f 0c01 	mov.w	ip, #1
 80046b0:	e002      	b.n	80046b8 <__cmpsf2+0x4>
 80046b2:	bf00      	nop

080046b4 <__cmpsf2>:
 80046b4:	f04f 0c01 	mov.w	ip, #1
 80046b8:	f84d cd04 	str.w	ip, [sp, #-4]!
 80046bc:	ea4f 0240 	mov.w	r2, r0, lsl #1
 80046c0:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80046c4:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80046c8:	bf18      	it	ne
 80046ca:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80046ce:	d011      	beq.n	80046f4 <__cmpsf2+0x40>
 80046d0:	b001      	add	sp, #4
 80046d2:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
 80046d6:	bf18      	it	ne
 80046d8:	ea90 0f01 	teqne	r0, r1
 80046dc:	bf58      	it	pl
 80046de:	ebb2 0003 	subspl.w	r0, r2, r3
 80046e2:	bf88      	it	hi
 80046e4:	17c8      	asrhi	r0, r1, #31
 80046e6:	bf38      	it	cc
 80046e8:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
 80046ec:	bf18      	it	ne
 80046ee:	f040 0001 	orrne.w	r0, r0, #1
 80046f2:	4770      	bx	lr
 80046f4:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80046f8:	d102      	bne.n	8004700 <__cmpsf2+0x4c>
 80046fa:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 80046fe:	d105      	bne.n	800470c <__cmpsf2+0x58>
 8004700:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 8004704:	d1e4      	bne.n	80046d0 <__cmpsf2+0x1c>
 8004706:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 800470a:	d0e1      	beq.n	80046d0 <__cmpsf2+0x1c>
 800470c:	f85d 0b04 	ldr.w	r0, [sp], #4
 8004710:	4770      	bx	lr
 8004712:	bf00      	nop

08004714 <__aeabi_cfrcmple>:
 8004714:	4684      	mov	ip, r0
 8004716:	4608      	mov	r0, r1
 8004718:	4661      	mov	r1, ip
 800471a:	e7ff      	b.n	800471c <__aeabi_cfcmpeq>

0800471c <__aeabi_cfcmpeq>:
 800471c:	b50f      	push	{r0, r1, r2, r3, lr}
 800471e:	f7ff ffc9 	bl	80046b4 <__cmpsf2>
 8004722:	2800      	cmp	r0, #0
 8004724:	bf48      	it	mi
 8004726:	f110 0f00 	cmnmi.w	r0, #0
 800472a:	bd0f      	pop	{r0, r1, r2, r3, pc}

0800472c <__aeabi_fcmpeq>:
 800472c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8004730:	f7ff fff4 	bl	800471c <__aeabi_cfcmpeq>
 8004734:	bf0c      	ite	eq
 8004736:	2001      	moveq	r0, #1
 8004738:	2000      	movne	r0, #0
 800473a:	f85d fb08 	ldr.w	pc, [sp], #8
 800473e:	bf00      	nop

08004740 <__aeabi_fcmplt>:
 8004740:	f84d ed08 	str.w	lr, [sp, #-8]!
 8004744:	f7ff ffea 	bl	800471c <__aeabi_cfcmpeq>
 8004748:	bf34      	ite	cc
 800474a:	2001      	movcc	r0, #1
 800474c:	2000      	movcs	r0, #0
 800474e:	f85d fb08 	ldr.w	pc, [sp], #8
 8004752:	bf00      	nop

08004754 <__aeabi_fcmple>:
 8004754:	f84d ed08 	str.w	lr, [sp, #-8]!
 8004758:	f7ff ffe0 	bl	800471c <__aeabi_cfcmpeq>
 800475c:	bf94      	ite	ls
 800475e:	2001      	movls	r0, #1
 8004760:	2000      	movhi	r0, #0
 8004762:	f85d fb08 	ldr.w	pc, [sp], #8
 8004766:	bf00      	nop

08004768 <__aeabi_fcmpge>:
 8004768:	f84d ed08 	str.w	lr, [sp, #-8]!
 800476c:	f7ff ffd2 	bl	8004714 <__aeabi_cfrcmple>
 8004770:	bf94      	ite	ls
 8004772:	2001      	movls	r0, #1
 8004774:	2000      	movhi	r0, #0
 8004776:	f85d fb08 	ldr.w	pc, [sp], #8
 800477a:	bf00      	nop

0800477c <__aeabi_fcmpgt>:
 800477c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8004780:	f7ff ffc8 	bl	8004714 <__aeabi_cfrcmple>
 8004784:	bf34      	ite	cc
 8004786:	2001      	movcc	r0, #1
 8004788:	2000      	movcs	r0, #0
 800478a:	f85d fb08 	ldr.w	pc, [sp], #8
 800478e:	bf00      	nop

08004790 <memcpy>:
 8004790:	4684      	mov	ip, r0
 8004792:	ea41 0300 	orr.w	r3, r1, r0
 8004796:	f013 0303 	ands.w	r3, r3, #3
 800479a:	d149      	bne.n	8004830 <memcpy+0xa0>
 800479c:	3a40      	subs	r2, #64	; 0x40
 800479e:	d323      	bcc.n	80047e8 <memcpy+0x58>
 80047a0:	680b      	ldr	r3, [r1, #0]
 80047a2:	6003      	str	r3, [r0, #0]
 80047a4:	684b      	ldr	r3, [r1, #4]
 80047a6:	6043      	str	r3, [r0, #4]
 80047a8:	688b      	ldr	r3, [r1, #8]
 80047aa:	6083      	str	r3, [r0, #8]
 80047ac:	68cb      	ldr	r3, [r1, #12]
 80047ae:	60c3      	str	r3, [r0, #12]
 80047b0:	690b      	ldr	r3, [r1, #16]
 80047b2:	6103      	str	r3, [r0, #16]
 80047b4:	694b      	ldr	r3, [r1, #20]
 80047b6:	6143      	str	r3, [r0, #20]
 80047b8:	698b      	ldr	r3, [r1, #24]
 80047ba:	6183      	str	r3, [r0, #24]
 80047bc:	69cb      	ldr	r3, [r1, #28]
 80047be:	61c3      	str	r3, [r0, #28]
 80047c0:	6a0b      	ldr	r3, [r1, #32]
 80047c2:	6203      	str	r3, [r0, #32]
 80047c4:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 80047c6:	6243      	str	r3, [r0, #36]	; 0x24
 80047c8:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 80047ca:	6283      	str	r3, [r0, #40]	; 0x28
 80047cc:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 80047ce:	62c3      	str	r3, [r0, #44]	; 0x2c
 80047d0:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 80047d2:	6303      	str	r3, [r0, #48]	; 0x30
 80047d4:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 80047d6:	6343      	str	r3, [r0, #52]	; 0x34
 80047d8:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 80047da:	6383      	str	r3, [r0, #56]	; 0x38
 80047dc:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 80047de:	63c3      	str	r3, [r0, #60]	; 0x3c
 80047e0:	3040      	adds	r0, #64	; 0x40
 80047e2:	3140      	adds	r1, #64	; 0x40
 80047e4:	3a40      	subs	r2, #64	; 0x40
 80047e6:	d2db      	bcs.n	80047a0 <memcpy+0x10>
 80047e8:	3230      	adds	r2, #48	; 0x30
 80047ea:	d30b      	bcc.n	8004804 <memcpy+0x74>
 80047ec:	680b      	ldr	r3, [r1, #0]
 80047ee:	6003      	str	r3, [r0, #0]
 80047f0:	684b      	ldr	r3, [r1, #4]
 80047f2:	6043      	str	r3, [r0, #4]
 80047f4:	688b      	ldr	r3, [r1, #8]
 80047f6:	6083      	str	r3, [r0, #8]
 80047f8:	68cb      	ldr	r3, [r1, #12]
 80047fa:	60c3      	str	r3, [r0, #12]
 80047fc:	3010      	adds	r0, #16
 80047fe:	3110      	adds	r1, #16
 8004800:	3a10      	subs	r2, #16
 8004802:	d2f3      	bcs.n	80047ec <memcpy+0x5c>
 8004804:	320c      	adds	r2, #12
 8004806:	d305      	bcc.n	8004814 <memcpy+0x84>
 8004808:	f851 3b04 	ldr.w	r3, [r1], #4
 800480c:	f840 3b04 	str.w	r3, [r0], #4
 8004810:	3a04      	subs	r2, #4
 8004812:	d2f9      	bcs.n	8004808 <memcpy+0x78>
 8004814:	3204      	adds	r2, #4
 8004816:	d008      	beq.n	800482a <memcpy+0x9a>
 8004818:	07d2      	lsls	r2, r2, #31
 800481a:	bf1c      	itt	ne
 800481c:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8004820:	f800 3b01 	strbne.w	r3, [r0], #1
 8004824:	d301      	bcc.n	800482a <memcpy+0x9a>
 8004826:	880b      	ldrh	r3, [r1, #0]
 8004828:	8003      	strh	r3, [r0, #0]
 800482a:	4660      	mov	r0, ip
 800482c:	4770      	bx	lr
 800482e:	bf00      	nop
 8004830:	2a08      	cmp	r2, #8
 8004832:	d313      	bcc.n	800485c <memcpy+0xcc>
 8004834:	078b      	lsls	r3, r1, #30
 8004836:	d0b1      	beq.n	800479c <memcpy+0xc>
 8004838:	f010 0303 	ands.w	r3, r0, #3
 800483c:	d0ae      	beq.n	800479c <memcpy+0xc>
 800483e:	f1c3 0304 	rsb	r3, r3, #4
 8004842:	1ad2      	subs	r2, r2, r3
 8004844:	07db      	lsls	r3, r3, #31
 8004846:	bf1c      	itt	ne
 8004848:	f811 3b01 	ldrbne.w	r3, [r1], #1
 800484c:	f800 3b01 	strbne.w	r3, [r0], #1
 8004850:	d3a4      	bcc.n	800479c <memcpy+0xc>
 8004852:	f831 3b02 	ldrh.w	r3, [r1], #2
 8004856:	f820 3b02 	strh.w	r3, [r0], #2
 800485a:	e79f      	b.n	800479c <memcpy+0xc>
 800485c:	3a04      	subs	r2, #4
 800485e:	d3d9      	bcc.n	8004814 <memcpy+0x84>
 8004860:	3a01      	subs	r2, #1
 8004862:	f811 3b01 	ldrb.w	r3, [r1], #1
 8004866:	f800 3b01 	strb.w	r3, [r0], #1
 800486a:	d2f9      	bcs.n	8004860 <memcpy+0xd0>
 800486c:	780b      	ldrb	r3, [r1, #0]
 800486e:	7003      	strb	r3, [r0, #0]
 8004870:	784b      	ldrb	r3, [r1, #1]
 8004872:	7043      	strb	r3, [r0, #1]
 8004874:	788b      	ldrb	r3, [r1, #2]
 8004876:	7083      	strb	r3, [r0, #2]
 8004878:	4660      	mov	r0, ip
 800487a:	4770      	bx	lr

0800487c <memset>:
 800487c:	b470      	push	{r4, r5, r6}
 800487e:	0784      	lsls	r4, r0, #30
 8004880:	d046      	beq.n	8004910 <memset+0x94>
 8004882:	1e54      	subs	r4, r2, #1
 8004884:	2a00      	cmp	r2, #0
 8004886:	d041      	beq.n	800490c <memset+0x90>
 8004888:	b2cd      	uxtb	r5, r1
 800488a:	4603      	mov	r3, r0
 800488c:	e002      	b.n	8004894 <memset+0x18>
 800488e:	1e62      	subs	r2, r4, #1
 8004890:	b3e4      	cbz	r4, 800490c <memset+0x90>
 8004892:	4614      	mov	r4, r2
 8004894:	f803 5b01 	strb.w	r5, [r3], #1
 8004898:	079a      	lsls	r2, r3, #30
 800489a:	d1f8      	bne.n	800488e <memset+0x12>
 800489c:	2c03      	cmp	r4, #3
 800489e:	d92e      	bls.n	80048fe <memset+0x82>
 80048a0:	b2cd      	uxtb	r5, r1
 80048a2:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 80048a6:	2c0f      	cmp	r4, #15
 80048a8:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 80048ac:	d919      	bls.n	80048e2 <memset+0x66>
 80048ae:	4626      	mov	r6, r4
 80048b0:	f103 0210 	add.w	r2, r3, #16
 80048b4:	3e10      	subs	r6, #16
 80048b6:	2e0f      	cmp	r6, #15
 80048b8:	f842 5c10 	str.w	r5, [r2, #-16]
 80048bc:	f842 5c0c 	str.w	r5, [r2, #-12]
 80048c0:	f842 5c08 	str.w	r5, [r2, #-8]
 80048c4:	f842 5c04 	str.w	r5, [r2, #-4]
 80048c8:	f102 0210 	add.w	r2, r2, #16
 80048cc:	d8f2      	bhi.n	80048b4 <memset+0x38>
 80048ce:	f1a4 0210 	sub.w	r2, r4, #16
 80048d2:	f022 020f 	bic.w	r2, r2, #15
 80048d6:	f004 040f 	and.w	r4, r4, #15
 80048da:	3210      	adds	r2, #16
 80048dc:	2c03      	cmp	r4, #3
 80048de:	4413      	add	r3, r2
 80048e0:	d90d      	bls.n	80048fe <memset+0x82>
 80048e2:	461e      	mov	r6, r3
 80048e4:	4622      	mov	r2, r4
 80048e6:	3a04      	subs	r2, #4
 80048e8:	2a03      	cmp	r2, #3
 80048ea:	f846 5b04 	str.w	r5, [r6], #4
 80048ee:	d8fa      	bhi.n	80048e6 <memset+0x6a>
 80048f0:	1f22      	subs	r2, r4, #4
 80048f2:	f022 0203 	bic.w	r2, r2, #3
 80048f6:	3204      	adds	r2, #4
 80048f8:	4413      	add	r3, r2
 80048fa:	f004 0403 	and.w	r4, r4, #3
 80048fe:	b12c      	cbz	r4, 800490c <memset+0x90>
 8004900:	b2c9      	uxtb	r1, r1
 8004902:	441c      	add	r4, r3
 8004904:	f803 1b01 	strb.w	r1, [r3], #1
 8004908:	42a3      	cmp	r3, r4
 800490a:	d1fb      	bne.n	8004904 <memset+0x88>
 800490c:	bc70      	pop	{r4, r5, r6}
 800490e:	4770      	bx	lr
 8004910:	4614      	mov	r4, r2
 8004912:	4603      	mov	r3, r0
 8004914:	e7c2      	b.n	800489c <memset+0x20>
 8004916:	bf00      	nop
